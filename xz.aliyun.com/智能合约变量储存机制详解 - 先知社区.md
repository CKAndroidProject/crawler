> 原文链接: https://xz.aliyun.com/t/9837 


智能合约变量储存机制详解

# 0x01 前言

最近在研究以太坊存储机制，写一篇文章总结一下

# 0x02 存储机制

每个在以太坊虚拟机（EVM）中运行的智能合约的状态都在链上永久地存储着。这些值存储在一个巨大的数组中，数组的长度为2^256，下标从零开始且每一个数组能够储存32字节(256个比特)长度的值。并且存储是稀疏的，并没有那么密集。

# 0x03 变量类型

Solidity的数据变量类型分为两类
- 值类型-value type
- 引用类型-reference type
下面列举常用的变量类型

## 值类型
- 布尔型(bool) 2bit(0/1)
- 整型(int/uint)  根据关键字的不同表示不同长度，int8表示8bits有符号数
- 定长浮点型(fixed/ufixed) Solidity 还没有完全支持定长浮点型。可以声明定长浮点型的变量，但不能给它们赋值或把它们赋值给其他变量
- 地址类型(adress) 160bits
<li>地址类型成员变量(balance,transfer....)  <ul>
- .balance  uint256(256bits)
- transfer()  uint256(256bits)
## 引用类型
<li>不定长字节数组类型(bytes[]/byte[],string,uint[]....)
</li>
<li>结构体(struct)
</li>
- 映射(mapping)
# 0x04 简单分析

写一个简单值类型的合约

```
web3.eth.getStorageAt(address, position [, defaultBlock] [, callback])
```

```
pragma solidity ^0.4.25;

contract TEST`{`
    bool a=false;
    bool b=true;
    int16 c=32767;
    uint16 d=0x32;
    byte e=10;
    bytes1 f=11;
    bytes2 g=22;
    uint h=0x1; //uint是uint256的简称
    address i=0xbc6581e11c216B17aDf5192E209a7F95a49e6837;
`}`
```

## 变长数组

# 0x06 字符串类型
- a，b slot0
- c        slot1
- d        slot2
# 0x08 映射类型

# 0x10 解题练习

```
`web3.eth.getStorageAt(address, position [, defaultBlock] [, callback])`
```
- `address`：String - 要读取的地址
- `position`：Number - 存储中的索引编号
- `defaultBlock`：Number|String - 可选，使用该参数覆盖 web3.eth.defaultBlock 属性值
- `callback`：Function - 可选的回调函数, 其第一个参数为错误对象，第二个参数为结果。
举两个简单的题目

## [题目一](https://ethernaut.openzeppelin.com/) --Vault

```
web3.eth.getStorageAt(contract.address, 1)
```

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

contract Vault `{`
  bool public locked;
  bytes32 private password;

  constructor(bytes32 _password) public `{`
    locked = true;
    password = _password;
  `}`

  function unlock(bytes32 _password) public `{`
    if (password == _password) `{`
      locked = false;
    `}`
  `}`
`}`
```

```
`web3.eth.getStorageAt(contract.address, 1)`
```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210708231101-b4ea2696-dffe-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20210708231101-b4ea2696-dffe-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210708231137-ca3fe2ba-dffe-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20210708231137-ca3fe2ba-dffe-1.png)

直接使用

```
contract.unlock("A very strong secret password :\)")//密码错误
```

```
`contract.unlock("A very strong secret password :\)")//密码错误`
```

```
contract.unlock(web3.utils.hexToBytes('0x412076657279207374726f6e67207365637265742070617373776f7264203a29'))
```

```
`contract.unlock(web3.utils.hexToBytes('0x412076657279207374726f6e67207365637265742070617373776f7264203a29'))`
```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210708231106-b8093100-dffe-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20210708231106-b8093100-dffe-1.png)

## [题目二](https://blockchainctf.securityinnovation.com/#/) --Lock Box

```
pragma solidity 0.4.24;

import "../CtfFramework.sol";

contract Lockbox1 is CtfFramework`{`

    uint256 private pin;

    constructor(address _ctfLauncher, address _player) public payable
        CtfFramework(_ctfLauncher, _player)
    `{`
        pin = now%10000;
    `}`

    function unlock(uint256 _pin) external ctf`{`
        require(pin == _pin, "Incorrect PIN");
        msg.sender.transfer(address(this).balance);
    `}`

`}`
```
- 读取私有变量
- constructor只在构造的时候执行一次
[![](https://xzfile.aliyuncs.com/media/upload/picture/20210708231149-d1878906-dffe-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20210708231149-d1878906-dffe-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210708231200-d7d4867e-dffe-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20210708231200-d7d4867e-dffe-1.png)
