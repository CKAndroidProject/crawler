> 原文链接: https://www.anquanke.com//post/id/85737 


# 【漏洞分析】CVE-2017-3731：截断的数据包导致OpenSSL拒绝服务


                                阅读量   
                                **93078**
                            
                        |
                        
                                                                                                                                    ![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



##### 译文声明

本文是翻译文章，文章原作者，文章来源：mcafee.com
                                <br>原文地址：[https://securingtomorrow.mcafee.com/mcafee-labs/analyzing-cve-2017-3731-truncated-packets-can-cause-denial-service-openssl/?utm_source=twitter&amp;utm_campaign=Labs#sf61253943](https://securingtomorrow.mcafee.com/mcafee-labs/analyzing-cve-2017-3731-truncated-packets-can-cause-denial-service-openssl/?utm_source=twitter&amp;utm_campaign=Labs#sf61253943)

译文仅供参考，具体内容表达以及含义原文为准

****

[![](https://p4.ssl.qhimg.com/t010c8d648921d36cd7.png)](https://p4.ssl.qhimg.com/t010c8d648921d36cd7.png)

翻译：[啦咔呢](http://bobao.360.cn/member/contribute?uid=79699134)

稿费：100RMB（不服你也来投稿啊！）

投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿

**<br>**

**前言**

OpenSSL是一个流行的SSL开源库，被世界各地的各种软件和公司使用。1月份，OpenSSL发布了一个更新以修复多个漏洞。其中之一就是CVE-2017-3731，这可能导致由于程序崩溃而引发的拒绝服务。McAfee 实验室分析了此漏洞来为客户提供检测。 

<br>

**使用patch diff来找出修改的地方**

补丁修改了一些与各种密码算法相关的文件。对于本报告，我们将检查代码e_chacha20_poly1305.c。以下代码显示此文件的修补程序，取自[https://git.openssl.org/?p=openssl.git;a=commitdiff;h=2198b3a55de681e1f3c23edb0586afe13f438051](https://git.openssl.org/?p=openssl.git;a=commitdiff;h=2198b3a55de681e1f3c23edb0586afe13f438051) 。

[![](https://p1.ssl.qhimg.com/t01b20957936d0ed3fc.png)](https://p1.ssl.qhimg.com/t01b20957936d0ed3fc.png)

我们可以看到，添加了一个简单的步骤来检查变量长度的值与常量POLY1305_BLOCK_SIZE的大小关系，而紧接着下面我们看到变量“len”减去了这个常量。

如果我们查看声明就能发现，POLY1305_BLOCK_SIZE在文件poly1305.h中声明为“#define POLY1305_BLOCK_SIZE 16”。而变量len在e_chacha20_poly1305.c中定义为“unsigned int len;”。

因此，如果变量len小于16，它将导致整数下溢，也就是说，len的值将变得非常大。然后当该值被使用时，可能会导致正常程序流出现问题，因为len的值不正确。

<br>

**进一步挖掘**

我们可以看到在前面的图片中，这个len值被分配给“actx-&gt; tls_payload_length”。然后调用函数chacha20_poly1305_cipher。在此函数内，actx-&gt; tls_payload_length被分配给变量“plen”：

[![](https://p0.ssl.qhimg.com/t01ce9be57609eaf7ed.png)](https://p0.ssl.qhimg.com/t01ce9be57609eaf7ed.png)

注意，变量plen将得到从先前的len整数下溢导致的非常大的数值。我们可以进一步看到plen的值传递给函数poly1305_Update：

[![](https://p0.ssl.qhimg.com/t01fd55a826c819fb7b.png)](https://p0.ssl.qhimg.com/t01fd55a826c819fb7b.png)

Poly1305_Update调用函数Poly1305_blocks时将携带此大值：

[![](https://p1.ssl.qhimg.com/t010444e5437988985f.png)](https://p1.ssl.qhimg.com/t010444e5437988985f.png)

如果我们仔细看看函数，我们可以看到变量len包含一个非常大的整数值，但是却被用来作“while”循环中的计数器：

[![](https://p4.ssl.qhimg.com/t0108a3e82647f83c16.png)](https://p4.ssl.qhimg.com/t0108a3e82647f83c16.png)

我们还可以看到对函数U8TOU32的调用，该函数读取* inp（指针）的值，并且在循环的每次迭代中，* inp的值加上一次POLY1305_BLOCK_SIZE。因为len的值非常大，最终* inp将指向不可读的内存。尝试读取将导致访问异常错误 – 导致OpenSSL崩溃。

<br>

**从网络中利用漏洞**

要利用此漏洞，客户端需要使用chacha20_poly1305加密套件（或另一个加密漏洞，可从补丁diff中看出），并发送加密的握手消息，其中记录长度小于16个字节（在使用chacha20_poly1305加密套件的情况下）。这将导致整数下溢致使OpenSSL崩溃，我们可以在以下图像看到运行中的OpenSSL和Gnu Debugger：

[![](https://p1.ssl.qhimg.com/t01d3ccb03e1cb2dada.png)](https://p1.ssl.qhimg.com/t01d3ccb03e1cb2dada.png)

<br>

**结论**

OpenSSL非常流行，因此可以成为拒绝服务攻击的目标。这些类型的漏洞可能影响许多安装此组件的应用程序。我们建议用户将其使用的OpenSSL安装更新到最新版本。

McAfee 网络安全平台客户已经通过签名ID：0x45c09400受到关于此漏洞的保护。
