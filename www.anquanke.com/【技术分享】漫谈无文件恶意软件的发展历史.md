
# 【技术分享】漫谈无文件恶意软件的发展历史


                                阅读量   
                                **90313**
                            
                        |
                        
                                                                                                                                    ![](./img/85956/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



##### 译文声明

本文是翻译文章，文章原作者，文章来源：安全客
                                <br>原文地址：[https://zeltser.com/fileless-malware-beyond-buzzword/](https://zeltser.com/fileless-malware-beyond-buzzword/)

译文仅供参考，具体内容表达以及含义原文为准



[![](./img/85956/t0119721a91eb06d311.jpg)](./img/85956/t0119721a91eb06d311.jpg)

译者：[興趣使然的小胃](http://bobao.360.cn/member/contribute?uid=2819002922)

预估稿费：200RMB

投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿



**一、前言<br>**



究竟什么是“**无文件恶意软件（fileless malware）**”？谈到这个名词时，许多安全行业的专业人员都心有余悸，许多文章和产品手册在介绍无文件恶意软件时，总会顺带提到我们难以防御和分析这类威胁。我在这篇文章中会试着抛开这些陈词滥调，追溯无文件恶意软件的最初起源，并以此类恶意软件的几个样本为例，勾勒出这个名词的演变轮廓。

<br>

**二、这是一个热门话题**



人们在工业事件、私人会议以及在线讨论中经常会提到无文件恶意软件这个话题。原因可能在于这类威胁放大了传统端点安全技术的缺点，又给了新型安全技术展现实力的机会。

事实的确如此，Google趋势给出的资料表明，人们在2012年到2014年之间对这个名词鲜有问津，自2015年后人们对它的兴趣逐步提升，并在2017年到达了一个峰值。

[![](./img/85956/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p1.ssl.qhimg.com/t01f8900bf0ea826bdb.png)

       这种趋势与近年来公众对具备“无文件”能力的恶意软件的讨论不无关系，特别是在2017年，有大量关于这个话题的研究成果和出版物喷涌而出。

<br>

**三、什么是无文件恶意软件**



首先我们得明确一点，那就是“无文件恶意软件有时候还是会使用文件”。现如今，大多数人们在使用无文件恶意软件这个名词时，似乎约定俗成地使用了以下这个定义：

“无文件恶意软件是一种不需要在文件系统中存放恶意可执行文件的软件”。

这个定义对于利用恶意脚本或者文件系统中良性可执行文件进行传播的恶意软件来说是适用的。对于隐藏在注册表中恶意软件来说，这个定义也是正确的，虽然这种情况下注册表本身还是存储在Windows文件系统中。这个定义不需要考虑恶意文件的传播途径，不论是通过漏洞利用、社会工程学技巧还是滥用某些正常功能来进行传播，这个定义都是适用的。

虽然无文件恶意软件最初指的是那些不使用本地持久化技术、完全驻留在内存中的恶意代码，但这个术语的范围在逐渐扩大，现在也将那些依赖文件系统的某些功能以实现恶意代码激活和驻留的恶意软件包括在内。让我们一起回顾一下对这个术语的演变过程造成影响的那些恶意程序。

<br>

**四、2001-2003： Code Red以及SQL Slammer**



完全驻留在内存中的恶意代码肯定在21世纪前就已经存在。然而，直到2001年，Code Red蠕虫在互联网上肆意传播，才将“无文件恶意软件”这个名词带给普罗大众。我所能找到的最早与此有关的公开资料发布于2001年的夏天，当时卡巴斯基实验室发表了一份[公告](https://web-beta.archive.org/web/20020601140250/http:/www.kaspersky.com/news.asp?tnews=0&amp;nview=8&amp;id=214&amp;page=0)，其中提到：

“我们预测，在不久的将来，像Code Red之类的‘无文件’蠕虫将泛滥成灾，无法处理这类威胁的反病毒软件只能给大众带来安全风险”。

Code Red蠕虫使用了微软IIS web服务器中的一个漏洞进行传播，能够完全驻留在受害主机的内存中，详细的分析可以参考CAIDA的这篇[文章](https://www.caida.org/research/security/code-red/)。

一年半以后，另一个蠕虫（SQL Slammer）就像燎原野火一般传播。SQL Slammer利用的是微软SQL服务器中的一个漏洞。Robert Vamosi在2003年为ZDNet撰写的一篇[文章](http://www.zdnet.com/article/sql-slammer-how-it-works-prevent-it/)中，将这个蠕虫归类为“无文件”类别恶意软件，指出它“与Code Red类似，仅驻留在内存中”。

我也在Peter Szor（彼时正在赛门铁克工作的一名资深前辈）于2003年提交的一份专利申请中找到了一些资料。专利名为“签名提取系统及方法”，其中给出了无文件恶意软件的定义，如下所示：

“无文件恶意软件指的是不依赖文件、仅存在于内存中的恶意代码……更具体地说，无文件恶意代码……可以将自身附加到活动进程的内存空间中……”。

无文件恶意软件的原始定义与这个名词字面上的意思非常接近，指的是能够在没有残留文件的前提下保持活跃的那些恶意软件。

<br>

**五、2012：安装Lurk木马的僵尸程序**



我能找到与无文件恶意软件有关的另一份资料，是在Code Red和SQL Slammer蠕虫诞生的近十年之后。2012年，卡巴斯基实验室的Sergey Golovanov发表了一份[分析报告](https://web.archive.org/web/20121115032711/http:/www.securelist.com/en/blog/687/A_unique_fileless_bot_attacks_news_site_visitors)，介绍了某个没有文件落盘行为的僵尸程序（bot），其中提到：

“我们面对的是一个非常罕见的恶意软件，这种无文件程序不存在于硬盘文件中，仅在受感染计算机的内存中活动”。

这个僵尸程序利用了Java客户端的某个漏洞，仅在受感染的javaw.exe进程的内存空间中活动。Sergey提到这个僵尸程序具备安装[Lurk银行木马](https://securelist.com/blog/research/75040/lurk-banker-trojan-exclusively-for-russia/)的功能。

在2012年的早些时候，SecurityXploded的Amit Malik发表了一篇[技术短文](http://securityxploded.com/memory-execution-of-executable.php)，介绍了从互联网下载Windows程序后，如何在不保存到本地硬盘的前提下，实现Windows程序的“内存化或无文件执行”。

<br>

**六、2014：Powerliks、Angler以及Phase僵尸程序**

****

前面提到的程序完全驻留在内存中，不会在文件系统中留下任何明显的蛛丝马迹。因为这种特性，它们在系统重启后就消失得无影无踪。相比之下，2014年出现的Poweliks恶意软件是一种“无需文件的可持久化恶意软件”（G Data的[原话](https://blog.gdatasoftware.com/2014/07/23947-poweliks-the-persistent-malware-without-a-file)）。这个恶意软件利用了微软Word的某个漏洞来进入系统，使用带有shellcode的PowerShell以及JavaScript脚本实现内存中的执行功能。赛门铁克的Kevin Gossett对它的本地持久化技术进行了分析，其中提到：

“通常情况下，恶意软件会在注册表的Run键值中添加一个子项，指向某个恶意可执行文件以完成本地持久化。Poweliks将Run键值的子键指向rundll32.exe，利用这个合法的微软程序加载DLL文件，并向其传递几个参数。传递的参数中包括JavaScript代码，最终实现将Poweliks加载到内存中并执行的目的”。

一个月之后，安全研究员Kafeine发表一篇关于Angler漏洞利用工具的[分析文章](http://malware.dontneedcoffee.com/2014/08/angler-ek-now-capable-of-fileless.html)。恶意软件的攻击目标是存在漏洞的Java客户端，仅在受感染的javaw.exe进程的内存空间中活动。2016年，Palo Alto的安全研究员Brad Duncan在一篇[分析报告](http://researchcenter.paloaltonetworks.com/2016/04/afraidgate-major-exploit-kit-campaign-swaps-locky-ransomware-for-cryptxxx/)中提到，Angler开始出现安装Bedep下载器的行为，且在安装时不涉及到任何文件创建，因为Angler将下载器直接加载到内存中运行。

2014年年末，安全研究员MalwareTech发表了一篇分析报告，研究了一款名为[“Phase僵尸程序](https://www.malwaretech.com/2014/12/phase-bot-fileless-rootki.html)”的无文件rootkit。根据该报告内容，这款恶意软件可以“在不释放任何文件到本地磁盘、不创建自身进程的前提下安装到系统中。……Phase将可重新定位的恶意代码加密保存在注册表中，通过PowerShell读取并在内存中执行这段与具体位置无关的代码”。与Powerliks类似，这个恶意软件通过注册表的autorun键值，调用rundll32.exe执行JavaScript实现本地持久化。

<br>

**七、2014-2015：Duqu 2.0以及Kovter**

在2015年年中，卡巴斯基实验室发表了一份[报告](https://securelist.com/files/2015/06/The_Mystery_of_Duqu_2_0_a_sophisticated_cyberespionage_actor_returns.pdf)，详细介绍了某个高级组织在2014-2015年期间使用一款名为Duqu 2.0的复杂恶意软件平台开展攻击活动。他们在攻击活动使用了某个Windows漏洞来安装恶意软件，恶意软件完全隐藏在受感染主机的内存中。恶意软件没有实现本地持久化机制，相反，攻击者的目标是长时间上线的服务器，他们只需要在服务器重启后重新感染系统即可。

名为Kovter的另一个无文件恶意软件也在2015年引起了人们的关注。Kovter的感染方式与Powerliks十分相似。它最初由某个恶意可执行文件加载运行，将经过混淆或加密处理的程序保存在注册表后，恶意软件就将原始的加载程序从磁盘中删除。至少有一个Kovter变种通过创建快捷方式执行JavaScript以实现本地持久化。正如Airbus的Andrew Dove[所述](http://blog.airbuscybersecurity.com/post/2016/03/FILELESS-MALWARE-%E2%80%93-A-BEHAVIOURAL-ANALYSIS-OF-KOVTER-PERSISTENCE)，这个JavaScript脚本会启动一个能够执行shellcode的PowerShell脚本，所执行的shellcode会将恶意代码注入到一个非恶意的应用程序中，并执行这个应用程序。

<br>

**八、2016：PowerSniff、PowerWare以及August**



在2016年年中，Palo Alto Networks的Josh Grunzweig和Brandon Levene在一篇[文章](http://researchcenter.paloaltonetworks.com/2016/03/powersniff-malware-used-in-macro-based-attacks/)中介绍了PowerSniff这个恶意软件。恶意软件的感染路径从包含恶意宏的微软Word文档开始。PowerSniff的内存驻留技巧在某些方面与Kovter类似，使用了PowerShell脚本来执行shellcode，仅在内存中执行的shellcode可以解码并执行附加的恶意载荷。PowerSniff具备将恶意DLL临时保存到文件系统中的能力。

几周之后，Carbon Black的Mike Sconzo和Rico Valdez在一篇[文章](https://www.carbonblack.com/2016/03/25/threat-alert-powerware-new-ransomware-written-in-powershell-targets-organizations-via-microsoft-word/)中介绍了PowerWare这个恶意软件。与PowerSniff类似，PowerWare依然使用包含恶意宏的微软Office文档开始攻击活动，文档中的恶意宏最终会启动一个PowerShell脚本，不需要在文件系统中存放恶意可执行文件即可完成攻击流程。

在当年晚些时候，Proofpoint在另一篇[文章](https://www.proofpoint.com/us/threat-insight/post/august-in-december-new-information-stealer-hits-the-scene)中介绍了August这个恶意软件，该样本同样使用微软Word宏以及PowerShell来完成攻击过程。根据这篇文章，August会“从远程站点下载部分载荷，作为PowerShell的字节数组”，载荷的执行完全在内存中完成，不需要保存到文件系统中。

<br>

**九、2017：POSHSPY等**



在2017年初，卡巴斯基实验室在一篇文章中介绍了某款恶意工具，其恶意代码以Meterpreter为基础，完全在内存中活动。在文件系统方面，攻击者仅使用了合法的Windows实用工具，如sc（用来安装运行PowerShell的恶意服务）以及netsh（使用隧道方式来承载恶意网络流量）。

几个月之后，Mandiant的Matthew Dunwoody在一篇分析复杂攻击活动的[文章](https://www.fireeye.com/blog/threat-research/2017/03/dissecting_one_ofap.html)中也提到了无文件恶意代码。名为POSHSPY的恶意软件使用了系统提供的WMI（Windows Management Instrumentation）功能来实现本地持久化机制，同时使用PowerShell来执行攻击载荷。POSHSPY能够下载可执行文件，并将该文件保存到文件系统中。Matthew总结到：

“攻击者通过这种‘离地（living off the land）’攻击技术，实现了一个非常独立的后门，可以与之前更为传统和更为复杂的后门族群一起部署，以便在传统后门失效后还保留目标的控制权”。

这次攻击事件突出反映了入侵者的强大实力，即使他们只能够依赖系统内置的正常程序，他们也能在被感染系统上执行恶意载荷。

<br>

**十、“无文件恶意软件”的其他说法**



2012年，Sergey Golovanov在一篇文章中，最开始使用的是“无文件恶意软件”这个名词。非常有趣的是，现在这篇[文章](https://securelist.com/blog/virus-watch/32383/a-unique-bodiless-bot-attacks-news-site-visitors-3/)中，使用的是“无实体恶意软件”（bodiless malware）这个名词。卡巴斯基实验室在2016年之前使用的都是“[无实体恶意软件](https://business.kaspersky.com/bodiless-threat/6128/)”，但在2017年之后，他们在文章中又回到了“无文件恶意软件”这个说法。

此外，还有其他说法没有流行起来。2013年，“高级易变性威胁”（Advanced Volatile Thread，AVT）这个说法短暂浮出水面。根据[维基百科](https://en.wikipedia.org/wiki/Advanced_volatile_threat)的解释，该名词由Triumfant公司的John Prisco提出。“AVT”存在的时间并不长，2013年，Byron Acohido在《今日美国》的一篇[文章](https://www.usatoday.com/story/tech/2013/02/21/advanced-volatile-threat-malicious-software-pc-intrusions/1933975/)中，使用这个名词来指代存在后门的某个Apache软件。根据Piere-Marc Bureau（彼时是ESET的一员）的[说法](https://www.welivesecurity.com/2013/04/26/linuxcdorked-new-apache-backdoor-in-the-wild-serves-blackhole/)，这个后门“除了对web服务器文件进行修改之外，没有在硬盘上留下其他任何痕迹”。

相比之下，Carbon Black在2016年的一份[威胁报告](https://www.carbonblack.com/wp-content/uploads/2016/12/16_1214_Carbon_Black-_Threat_Report_Non-Malware_Attacks_and_Ransomware_FINAL.pdf)中，使用了与无文件恶意软件更为贴切的另一种说法。这篇报告中使用的是“无恶意软件攻击”这个名词。几个月之后，Michael Viscuso在公司的一篇[博文](https://www.carbonblack.com/2017/02/10/non-malware-fileless-attack/)中，对这个名词做出了解释，原话如下：

“无恶意软件攻击，指的是攻击者使用现有软件、被许可的应用程序以及已授权的协议来开展恶意活动。无恶意软件攻击无需下载任何恶意文件，即可获取计算机的控制权。无恶意软件攻击这个概念也可以代表无文件、内存化或‘离地’攻击”。

Gartner在2017年的一份[报告](https://www.gartner.com/technology/media-products/newsletters/carbon-black/1-3QTKW2U/index.html)中，与Carbon Black一样，使用了“无恶意软件攻击”这个名词。不过，一个月后，Gartner在的另一篇[文章](https://www.gartner.com/doc/3606019/ready-fileless-malware-attacks)中，改用了“无文件攻击”这个名词。

<br>

**十一、为什么写这篇文章**



我认为对于不同的场合，我们可以使用不同的说法。比如，对于仅仅依赖合法的系统管理工具以及其他非恶意软件的攻击事件，我更倾向于使用“无恶意软件攻击”这个说法，这种场景也就是人们常说的“离地”攻击场景。另外，如果恶意代码从来没有保存到本地硬盘中（比如恶意代码被注入到其他进程的内存空间中），我更倾向于使用“完全内存化恶意软件（memory-only malware）”这个说法。如果恶意软件不需要在文件系统中保存传统意义上的可执行文件来实现本地持久化，此时我认为使用“无文件恶意软件”也是可以的。

不幸的是，现在这些说法已经杂糅在一起。尽管“无文件恶意软件”代表各种含义，我们还是会坚持使用这个说法来描述前面提到的各种场景。只能感慨人类的语言不仅含义不清，而且总是在变，如果大家说的都是“C#”语言，说不定这个世界会变得更加美好 🙂

我之所以会关心这个术语，原因在于我在[Minerva](https://www.minerva-labs.com/)的工作是负责介绍某款反恶意软件产品的功能，我需要避免使用那些陈词滥调和毫无意义的短语。这款产品可以与其他端点安全工具配合使用，防御各种恶意软件，无论它们的攻击载荷是否需要保存到磁盘中。客户经常向我咨询我们对无文件恶意软件的处理方式，因此我决定写一篇综合调研文章，以便更好把握这个名词使用的方式和时机。

<br style="text-align: left">
