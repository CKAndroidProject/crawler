> 原文链接: https://www.anquanke.com//post/id/83392 


# 手把手教你修改二进制固件引导顺序


                                阅读量   
                                **78209**
                            
                        |
                        
                                                                                    



**[![](https://p5.ssl.qhimg.com/t01cbbb722a6568bd3c.jpg)](https://p5.ssl.qhimg.com/t01cbbb722a6568bd3c.jpg)**

**        本文作者:whitecell-lab  _D_D_******

**        壹、前言**

本文将讲解通过动态分析固件程序来读取启动顺序的具体步骤。

**        贰、实验流程**

A.在固件的设置界面中设置启动顺序为依次启动设备A和启动设备B。

B.通过单步进入和单步跳过等方法来追踪固件程序读取固件启动顺序的函数和将启动顺序列表值写入内存中的函数,及内存的物理地址;

C.修改固件启动顺序为硬盘和光驱;

D.反复执行A~C操作,确定固件程序读取固件启动顺序的函数和写入内存中的函数。

**        叁、修改过程**

通过以上逐步调试,首先找到固件程序中的CD19标识



[![](https://p0.ssl.qhimg.com/t012d811c9af6c80cc2.png)](https://p0.ssl.qhimg.com/t012d811c9af6c80cc2.png)



之后在调用CD19指令前的代码逐步设断点,找到了把启动顺序相关信息写进内存的函数和代码



[![](https://p2.ssl.qhimg.com/t0110653dc46ef4b2bb.jpg)](https://p2.ssl.qhimg.com/t0110653dc46ef4b2bb.jpg)



当执行该函数后,启动顺序的相关内容被写进内存,如图3所示。

通过分析发现,启动设备顺序相关信息被写入内存的段地址:

偏移地址 = F000:5F00。

[![](https://p1.ssl.qhimg.com/t0114dd4794a807bbcf.jpg)](https://p1.ssl.qhimg.com/t0114dd4794a807bbcf.jpg)



读取固件启动顺序列表和写启动顺序相关信息入内存中的函数为:

F000:01AF    E8941D             call near16ptr 1f46

当把启动顺序值写入内存成功后,固件程序执行返回指令,根据启动顺序的值去调用启动设备对应的函数。

[![](https://p2.ssl.qhimg.com/t010646dd3c9824da1f.jpg)](https://p2.ssl.qhimg.com/t010646dd3c9824da1f.jpg)

当执行完返回指令后语句后,内存不允许被修改:

[![](https://p1.ssl.qhimg.com/t0123eeeac334e2b362.jpg)](https://p1.ssl.qhimg.com/t0123eeeac334e2b362.jpg)

**        肆、嵌入代码**

在确定了固件写启动顺序进内存的函数之后,我们需要分析写进内存的启动顺序相关信息的特征码含义:

当启动顺序列表为启动设备A、启动设备B时。其内存中对应的值为:

F000:5F00  0200 00 01 48 48 01 00 4343

当启动顺序列表为启动设备B、启动设备A时,内存对应的值为:

F000:5F00  0200 00 00 48 48 01 01 4343

(经过实验分析知:其中,0002表示启动设备数,00表示第一个启动设备,01表示第二启动顺序,4848表示启动设备A;01表示第二个启动设备,00表示第一启动顺序,4343表示启动设备B。)

在分析清楚写进内存的启动顺序特征码的具体含义之后,我们也就找到了固件启动顺序的漏洞所在,接下来我们可以考虑做如下实验:在固件程序将固件启动顺序相关信息读取写入内存之后,我们先让计算机去执行我们嵌入的修改启动设备顺序的代码,然后再执行返回指令,出现预期实验结果。

根据启动顺序相关信息特征码编写好用来修改启动顺序的汇编源文件,编译成可执行程序之后截取有效代码部分:

[![](https://p4.ssl.qhimg.com/t011af3cf1d1408702f.jpg)](https://p4.ssl.qhimg.com/t011af3cf1d1408702f.jpg)

在二进制文件嵌入该代码。

[![](https://p5.ssl.qhimg.com/t012eff5e1ec32f8c3e.jpg)](https://p5.ssl.qhimg.com/t012eff5e1ec32f8c3e.jpg)

同时在写启动顺序入内存函数call   near16 ptr 1f46调用完成之后,增加一个跳转,转而去执行我们的代码,如图10所示。在我们的代码执行完成之后才去执行固件读取启动设备顺序的函数。

[![](https://p4.ssl.qhimg.com/t01c1b2cc1ac6786fbe.jpg)](https://p4.ssl.qhimg.com/t01c1b2cc1ac6786fbe.jpg)

执行完修改启动顺序的代码后内存F000:5F00中的值已经被修改,即启动顺序已经被我们修改:



[![](https://p4.ssl.qhimg.com/t01f7dcf6dd0c4057c4.jpg)](https://p4.ssl.qhimg.com/t01f7dcf6dd0c4057c4.jpg)



实验成功!
