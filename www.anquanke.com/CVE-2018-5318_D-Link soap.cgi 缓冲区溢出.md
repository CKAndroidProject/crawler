> 原文链接: https://www.anquanke.com//post/id/94289 


# CVE-2018-5318：D-Link soap.cgi 缓冲区溢出


                                阅读量   
                                **154439**
                            
                        |
                        
                                                            评论
                                <b>
                                    <a target="_blank">8</a>
                                </b>
                                                                                    



# [![](https://p5.ssl.qhimg.com/t01cca8b0927f8e5023.png)](https://p5.ssl.qhimg.com/t01cca8b0927f8e5023.png)

> 老板前一段给买了几款路由把玩，研究了下D-Link DIR 629、DIR 823这两款板子。发现在**soap.cgi**中存在几处栈溢出，均可以远程利用，并且其他型号的路由也有对soap这一部分代码的复用。

## 逆向分析与漏洞挖掘

因为是想挖几个能远程利用的洞，首先去看了HTTP服务，也就是**/htdocs/cgibin**。

D-Link HTTP服务由**cgibin**提供，并通过软链接的文件名进入到不同的处理分支：[![](https://p5.ssl.qhimg.com/t015c61dbb04a907e8c.jpg)](https://p5.ssl.qhimg.com/t015c61dbb04a907e8c.jpg)

在各个cgi处理函数中，会通过**cgibin_parse_request**来解析用户输入，其函数原型大致如下：

[![](https://p3.ssl.qhimg.com/t01a873ec8e5cc360a6.jpg)](https://p3.ssl.qhimg.com/t01a873ec8e5cc360a6.jpg)

参数**save_param_func**用于传入解析/存储HTTP请求的具体handler，读取HTTP请求后使用该handler具体处理用户输入。在**soapcgi_main（0x00418E28）**中传入了漏洞函数**vulnerable_sprintf_parser****（0x0041893C）**：

[![](https://p4.ssl.qhimg.com/t0108f14348964101a1.jpg)](https://p4.ssl.qhimg.com/t0108f14348964101a1.jpg)

跟进**vulnerable_sprintf_parser**可以发现程序未进行边界检查便将全局变量**g_http_soapaction**通过**sprintf**写到栈上：

[![](https://p4.ssl.qhimg.com/t01d43613e57baece34.jpg)](https://p4.ssl.qhimg.com/t01d43613e57baece34.jpg)

**g_http_soapaction**来自于**soapcgi_main**中对HTTP Header **SOAPACTION**字段的解析：

取**HTTP_SOAPACTION**：

[![](https://p4.ssl.qhimg.com/t01eca57120ee2defa2.jpg)](https://p4.ssl.qhimg.com/t01eca57120ee2defa2.jpg)

取**#**后的值：

[![](https://p3.ssl.qhimg.com/t01a97980575b60255d.jpg)](https://p3.ssl.qhimg.com/t01a97980575b60255d.jpg)

至此漏洞原理已经明了：**soapcgi_main**中未进行边界检查便将HTTP Header中的SOAPACTION字段存储至栈上，导致栈溢出。



## 漏洞利用

基础信息：

[![](https://p0.ssl.qhimg.com/t013ef042e5f66220ef.jpg)](https://p0.ssl.qhimg.com/t013ef042e5f66220ef.jpg)

MIPS大端序，开启了NX，未开启ASLR、PIE，只需要做个ROP。

溢出的崩溃现场如下：

[![](https://p5.ssl.qhimg.com/t01c303139d187cf752.jpg)](https://p5.ssl.qhimg.com/t01c303139d187cf752.jpg)

$S0、$S2-S3、$FP、$SP指向的内存可控，要编写ROP只能在这几个寄存器上做文章，最终用ropper在uClibc中找了个很不错的gadget：

[![](https://p5.ssl.qhimg.com/t014af64b2acb6549ba.jpg)](https://p5.ssl.qhimg.com/t014af64b2acb6549ba.jpg)

现在需要做的就是找到libc加载的实际基址。

在隔壁开锁王师傅的指导下把板子拆开，接上串口：

[![](https://p0.ssl.qhimg.com/t01915453d91bcc7394.jpg)](https://p0.ssl.qhimg.com/t01915453d91bcc7394.jpg)

成功获取到shell：

[![](https://p4.ssl.qhimg.com/t01e386cd5b213c6d80.png)](https://p4.ssl.qhimg.com/t01e386cd5b213c6d80.png)

拿到shell后读/proc/pid/maps就可以获取到libc的加载基址。

最终编写ROP如下：

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p4.ssl.qhimg.com/t018a3416b0e9701236.jpg)

攻击演示：

[![](https://p3.ssl.qhimg.com/t0137c8b54d3ce13fbc.png)](https://p3.ssl.qhimg.com/t0137c8b54d3ce13fbc.png)
