> 原文链接: https://www.anquanke.com//post/id/211769 


# 针对IKEv2的新型拒绝服务攻击


                                阅读量   
                                **128393**
                            
                        |
                        
                                                            评论
                                <b>
                                    <a target="_blank">1</a>
                                </b>
                                                                                                                                    ![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



##### 译文声明

本文是翻译文章，文章原作者Tristan Ninet, Axel Legay, Romaric Maillard, Louis-Marie Traonouez,Olivier Zendra，文章来源：
                                <br>原文地址：[https://ieeexplore.ieee.org/document/8887395](https://ieeexplore.ieee.org/document/8887395)

译文仅供参考，具体内容表达以及含义原文为准

[![](https://p1.ssl.qhimg.com/t01fa7aa7fc3021c9ae.png)](https://p1.ssl.qhimg.com/t01fa7aa7fc3021c9ae.png)



在以前的分析中，已显示IKEv2遭受认证漏洞，该漏洞被认为无法利用。通过设计和实施一种新颖的缓慢的拒绝服务攻击（将其称为偏差攻击Deviation Attack），表明该漏洞实际上是可利用的。解释了攻击的要求，提出了可能的对策，并对协议进行了两种可能的修改，均克服了该漏洞。



## 0x01 Introduction

虚拟专用网（VPN）已被公司，政府和人们使用了数十年。 VPN允许连接两个或多个远程IP实体，就像它们在单个局域网（LAN）中一样。 “实体”是指网络或一台机器。由于实体之间的网络可能是不可信的，因此连接实体通常意味着对它们之间的IP流量执行某种加密和某种地址转换。在公司中，实体可以代表旅行中的雇员或工作地点。最近，发现了面向更大范围公众的商业VPN服务的兴起。公司向个人消费者提供进入公司VPN之一的权限，以便消费者可以像在公司LAN之一中一样浏览互联网。许多人使用VPN服务来欺骗他们的位置，以便根据其地理位置访问拒绝给他们的服务。许多人还使用它们来逃避审查，因为VPN服务允许他们隐藏其与VPN服务公司之间的数据包内容。因此，VPN已成为现代安全互联网中的核心技术，并且VPN保持安全至关重要。

可以使用多种技术来创建VPN，其中广泛使用了Internet协议安全性（IPsec）体系结构。此外，密钥交换版本2（IKEv2）是用于设置IPsec VPN的主要协议之一。 IKEv2旨在确保两个对等方的相互认证，并自动生成将作为通信安全保证的共享密钥。因此，安全的VPN依赖IKEv2的安全性，而IKEv2的安全至关重要。

先前对IKEv2的分析表明，该协议仅满足一种弱形式的身份验证。这些分析显示了IKEv2的执行痕迹，该痕迹违反了强身份验证：倒数第二个身份验证缺陷。但是，此漏洞并未引起严重关注，因为它不怀疑IKEv2生成的共享密钥的保密性。

在本文中首先提供有关IKEv2的背景知识以及第二部分中对该协议的先前分析。在第三部分中设计了一种针对IKEv2的新型拒绝服务（DoS）攻击，该攻击利用了倒数第二个身份验证缺陷。称新颖的DoS攻击为“偏差攻击”。偏离攻击绕过了IKEv2中引入的所有抵制DoS攻击的措施。将彻底讨论偏差攻击的流程和详细信息，并计算出触发攻击的精确数量。为了非常具体地展示偏差攻击进行了介绍。从而攻击了IKEv2的开源实现。通过此实验实验性地验证了触发量的表达，并提供了源代码，以便读者可以轻松地重现攻击。

最后探索了仅使用当前协议规范所提供的保护实现的多种方法。但是仅发现缓解措施或不完整的解决方法。因此在更高层次上解决了这个问题：提出了两种昂贵的协议修改方案，它们都可以防止攻击。



## 0x02 Background

### <a class="reference-link" name="A.%20IKEv2%E5%8D%8F%E8%AE%AE"></a>A. IKEv2协议

互联网密钥交换版本2（IKEv2）是互联网协议安全体系结构（IPsec）中使用的经过身份验证的密钥交换协议。它的规范由互联网工程任务组（IETF）管理，当前的RFC是RFC 7296。 IKEv2的目标是允许两个对等方动态协商加密算法和密钥，以建立IPsec通信。因此，它旨在确保对等方的相互认证和协商密钥的保密性。 IKEv2的开源实现是strongSwan。

IPsec体系结构在网络层提供了安全性。它在RFC 4301中定义。 IPsec定义了建立虚拟专用网（VPN）的框架。取决于所使用的基础安全协议，IPsec提供在两个对等点之间交换的IP数据包的完整性/身份验证保护（AH协议）或机密性和完整性/身份验证保护（ESP协议）。 IPsec本身还提供了一些针对重放攻击的保护（但是，由IPsec保护的数据包的接收者可以决定是否使用此保护）。为了保护数据包，IPsec对等方在它们之间建立了安全关联（SA）。安全关联是两个对等方都同意的一组安全参数和密钥。设置SA要求对等方共享一些加密密钥，并涉及将条目添加到其安全关联数据库（SAD）。可以将密钥手动放入对等方的数据库中，但是，随着对等方数目的增加，维护此类配置变得很麻烦。为了简化大型VPN设置的管理，依靠IKEv2协议定义的加密材料的动态协商效率更高。

将请求消息和响应消息的关联称为交换。 IKEv2由三个主要交换机组成。 IKE SA INIT交换执行IKE SA的初始设置，该保护将用于保护IKEv2协议的后续交换。在此交换期间，对等方同意使用加密算法来保护进一步的IKEv2交换，并通过运行Diffie-Hellman协议来建立一些通用的加密材料。 IKE AUTH交换对对等方进行身份验证，验证IKE SA并设置流量SA（或子SA）。可以使用预共享密钥（PSK）或数字签名来完成身份验证。最后，CREATE CHILD SA兑换有两个不同的目的。首先，它可以用于为IKE SA重新命名，即用新的IKE SA替换旧的IKE SA。在这种情况下，用于执行Diffie-Hellman交换的有效负载（密钥交换有效负载）是必需的。其次，它可以用于创建新的流量SA或为现有SA重置密钥。在这种情况下，密钥交换有效负载是可选的。如果未提供，则新密钥仅来自IKE SA的密钥。在IKE SA的生命周期内，多次执行CREATE CHILD SA交换。 IKEv2的消息序列图如下图所示。

[![](https://p1.ssl.qhimg.com/t0167075fd0e5fd839c.png)](https://p1.ssl.qhimg.com/t0167075fd0e5fd839c.png)

在整篇文章中，将m1用作IKE SA INIT请求的缩写。因此，定义了项m2，m3和m4。使用m5作为包含AUTHENTICA TION FAILED通知有效负载的INFORMATIONAL消息的缩写。

### <a class="reference-link" name="B.%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C"></a>B.相关工作

在1999年，Meadows使用NRL协议分析器发现了IKEv1中的两个身份验证弱点[1]。第一个是反射攻击，第二个称为倒数第二个身份验证缺陷（penultimate authentication flaw ）。

2003年，IKEv2在AVISPA项目中正式验证。作者发现IKEv2也遭受倒数第二个身份验证缺陷。但是，他们说不能将其用于其他目的。无论如何，他们提出了一个对策：密钥确认。

在2010年，Cremers使用Scyther工具对IKEv2 [2]进行了广泛的分析。他确认IKEv2遭受倒数第二个身份验证缺陷，并且像AVISPA项目一样，得出结论，此漏洞的危害较小。<br>
倒数第二个身份验证缺陷是IKEv2的执行跟踪，它违反了Dolev-Yao对手模型中的弱协议身份验证属性。弱协议是Lowe在[3]中首次定义的属性。该属性表明“显然，只要代理A完成与代理B的协议，那么B之前就已经在运行协议，显然与A一起运行”。在Dolev Yao攻击者模型[4]中，入侵者可以拦截网络上的每条消息，了解消息的有效负载并根据其知识伪造新消息。

[![](https://p1.ssl.qhimg.com/t01ff62ea5cb714eb37.png)](https://p1.ssl.qhimg.com/t01ff62ea5cb714eb37.png)

倒数第二个身份验证缺陷的消息序列图如上图所示。在这种攻击中，A启动了一个会话作为发起者，并希望与C对话。但是，入侵者会偏离A发送给Responder B的每个消息以及每个消息B发送回A。各方正常进行，直到A收到m4消息为止。 AUTH有效负载未使用C的私钥签名，因此A不会设置子SA并发送m5消息。入侵者拦截m5消息并将其丢弃。最后，B与A建立了子SA，而A不想与B建立了子SA。这违反了响应者的弱协议。倒数第二个身份验证缺陷并不完全违反身份验证的直观定义，因为没有实际的模拟并且仍然可以满足保密要求。但是，在本文中表明，倒数第二个自动认证缺陷允许拒绝服务攻击。

### <a class="reference-link" name="C.%20DoS%E6%94%BB%E5%87%BB%E7%9A%84%E5%88%86%E7%B1%BB"></a>C. DoS攻击的分类

偏差攻击属于慢速DoS攻击（SDA）类别。 SDA是一种DoS攻击，需要非常低的带宽。为此，SDA通常通过利用某些应用程序层漏洞将目标锁定在主机上的侦听守护程序。实际上，通过利用应用程序中的漏洞，偏差攻击使IKEv2守护程序不可用，并且与传统的泛洪DoS技术相比，它需要非常低的带宽。

尽管使用高流量负载进行简单的拒绝服务似乎更容易，但是可以通过入侵检测系统（IDS）来保护免受经典洪泛技术的侵害，偏差攻击要难得多。



## 0x03 The Deviation Attack

### <a class="reference-link" name="A.%E5%88%9D%E6%AD%A5"></a>A.初步

假设存在称为发起方的N个IKEv2参与者，称为响应者的M个IKEv2参与者和一个称为受害者的IKEv2参与者。各方可以是IKEv2端点（也称为主机）或网关。各方通过IP网络Net（可以是Internet）连接。下图展示了攻击场景。

[![](https://p5.ssl.qhimg.com/t012502a15b83ef14a7.png)](https://p5.ssl.qhimg.com/t012502a15b83ef14a7.png)

将连接称为一组在IKEv2阶段1会话（一次IKE SA INIT交换和一次IKE AUTH交换）之后存储在一方的内存中的SA。因此，如果一切顺利，则连接表示包含新创建的IKE SA及其第一个子SA的SA集合。但是，如果身份验证成功，但流量选择器（TS）协商失败，然后连接仅表示新创建的IKE SA。

令L为受害者的负荷，即IKEv2应用程序以及与不是Probe或Initiator机器的机器的连接所占用的受害者内存量。为了简单起见，假设L在时间上是恒定的。还假定受害者的内存是静态受限的，即，受害者在攻击过程中无法获得更多的内存容量。令C为在受害者中分配给IKEv2的内存容量。假设C是经过精心选择的，并且C&gt; L。

当分配给参与方的内存没有考虑到时，就不会倾向于在该方的内存中建立连接。令m为存储与一个连接有关的所有数据所需的内存量。从一开始，当该方自安装以来未收到任何IKEv2消息时，该方内存中的连接就会过时。一段时间后，以及一些未答复的重新输入密钥请求或保持活动请求，该方将删除该连接。假设S为一开始就处于连接失效状态的平均时间停留在受害者的内存中。

让Intruder成为一台连接到Net的机器。设t = 0为攻击开始，D为攻击持续时间。为简单起见，假设发起方以t = 0和t = D之间的恒定速率σ向响应方发送m1消息。以每秒IKE消息的数量（而不是以每秒的数据包的数量）表示σ。如果有碎片）。还假设，在t = 0时，没有发起方与受害人建立任何SA。

入侵者向机器发送消息，当入侵者在网络上拦截该邮件，将消息的目标IP地址更改为机器的IP地址，然后将消息发送回网络。当入侵者在网上拦截邮件时，原始收件人不会收到该信息。

令Φ（t）为：“受害者在时间t处于拒绝服务状态”。

定义以下命题：

Req1 入侵者可以拦截发起方发送给响应方的每个IP数据包。截获后，入侵者可以丢弃该消息，也可以将其向受害人转移。这些能力是Dolev-Yao [4]能力的子集。

Req2 所有发起方均使用签名模式进行身份验证。

Req3 所有发起方均受受害者信任。这意味着受害人的对等授权数据库允许与所有发起方伙伴建立连接。

Req4 发起方发送的所有m1消息均包含至少一个受害者可以接受的SA提议。

### <a class="reference-link" name="B.%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B"></a>B.攻击流程

假设满足Req1，Req2，Req3和Req4。攻击进行如下。入侵者拦截发起方发送给响应方的所有m1消息。考虑一下某个发起者发送给某个响应者的一个特定m1消息的含义。

多亏Req1，入侵者才将请求转向受害者。作为响应，因为满足Req4，所以受害者将m2消息发送给发起方。发起方接收它，并向响应方发送m3消息。入侵者将m3消息发送给受害者。

在接收到m3消息后，向身份验证者发起对Initiator的身份验证成功，因为身份验证是使用签名模式（Req2）完成的，并且因为发起者受到了受害者的信任（Req3）。但是，TS和密码算法协商可能会失败（在大多数情况下，TS协商会失败）。如果TS和加密算法协商失败，则仅存储一个IKE SA。如果TS和加密算法协商未失败，则将存储一个IKE SA和一个Child SA。根据对“连接”的定义，此时，受害者已与Initiator建立了一个连接。然后，受害者将m4消息发送给发起方。

收到m4消息后，启动器将使身份验证步骤失败，因为它打算与响应者而不是与受害者交谈。因此，发起方将m5消息发送给响应方。感谢Req1，入侵者拦截了该通知并将其删除。结果，在受害者的内存中添加了意外连接。

在本文中仅探讨内存耗尽是拒绝服务的可能原因。如果满足Req1，Req2，Req3和Req4，则存在一个吞吐量σ，它使入侵者能够引起拒绝服务。更正式地：

定理III.1：如果满足Req1，Req2，Req3和Req4，则：

[![](https://p3.ssl.qhimg.com/t01271062bff1c54b41.png)](https://p3.ssl.qhimg.com/t01271062bff1c54b41.png)

证明：由于受害者的内存受到静态限制，存在吞吐量σ，以使在攻击过程中的某个时候，受害者由于内存耗尽而处于拒绝服务状态。

### <a class="reference-link" name="C.%E6%9C%80%E5%B0%8F%E5%90%9E%E5%90%90%E9%87%8F%E5%92%8CDoS%E6%97%B6%E9%97%B4"></a>C.最小吞吐量和DoS时间

现在，可以将Σmem定义为触发内存耗尽的最小吞吐量。

定义III.1

[![](https://p3.ssl.qhimg.com/t01013f34c8410bc90e.png)](https://p3.ssl.qhimg.com/t01013f34c8410bc90e.png)

当σ&gt;Σmem时，将Ts mem（σ）定义为DoS的开始时间，将Te mem（σ）定义为DoS的结束时间。

定义III.2: 令σ&gt;Σmem，定义：

[![](https://p0.ssl.qhimg.com/t016ec15124ca07304f.png)](https://p0.ssl.qhimg.com/t016ec15124ca07304f.png)

定理III.2：

[![](https://p2.ssl.qhimg.com/t014926e4cda8790cca.png)](https://p2.ssl.qhimg.com/t014926e4cda8790cca.png)

此外，当σ&gt;Σmem时，内存耗尽将在以下位置开始和结束：

[![](https://p5.ssl.qhimg.com/t01e536c845d2120b30.png)](https://p5.ssl.qhimg.com/t01e536c845d2120b30.png)

证明：

总结发起方发送给响应方的所有m1消息的含义，在时间t，受害者已在其内存中安装了σ×t连接。但是，所有这些连接从一开始就是陈旧的，因此它们会在S秒后删除。因此，在时间t，受害者内存中存在的意外连接数为σ×min（t，S）。因此，在以下情况下，只有在以下情况下，受害者才会在时间t耗尽内存：

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p2.ssl.qhimg.com/t01dd0c96785dc5e076.png)

由于攻击持续了D秒钟，因此仅在以下情况下，攻击才会导致内存耗尽：

[![](https://p5.ssl.qhimg.com/t01540122903693a8a2.png)](https://p5.ssl.qhimg.com/t01540122903693a8a2.png)

得出Σmem表达式。现在假设σ&gt;Σmem。内存耗尽将在以下时间立即开始：

[![](https://p2.ssl.qhimg.com/t01abc005c69d96151c.png)](https://p2.ssl.qhimg.com/t01abc005c69d96151c.png)<br>
内存耗尽将持续到移除连接并停止攻击为止，即直到Te mem（σ）= max（D，S）。

### <a class="reference-link" name="D.%E5%81%8F%E5%B7%AE%E6%94%BB%E5%87%BB%E7%9A%84%E8%AE%A8%E8%AE%BA"></a>D.偏差攻击的讨论

1）使用预共享密钥时的偏差攻击：请注意，不要求受害者使用签名模式进行身份验证。换句话说，即使身份验证是非对称执行的，受害人使用签名，而发起者计算机使用PSK，攻击仍然有效。此外，可能存在比在本文中强加的要求更宽松的要求。例如，当发起方机器和受害者使用PSK相互通信时，并且此PSK与发起方机器和响应方机器相互通信所使用的PSK相同时，就有可能发生偏差攻击。如果这两个PSK不同，则攻击将不起作用。

2）为什么发起方不拒绝消息p3：在偏离攻击的上下文中，发起方看到m2消息的源IP地址不是发起方发送的m1消息的目标地址。乍一看，这种观察可能是一个奇怪情况的见证。但是，IKEv2 RFC特别指出：“传入的IKE数据包仅使用数据包的SPI映射到IKE SA，而不使用（例如）数据包的源IP地址”。这就是启动者不拒绝M2消息的原因。

3）一种获取足够数量偏离请求的方法：为使攻击起作用，需要在足够短的时间内从发起方伙伴向响应方发送的IKE SA INIT请求的速率足够。如果这种情况永远不会发生，则入侵者可能有一种解决方法：在给定的时间内，它可以丢弃所有来自发起方并发往响应方的消息。在一些未答复的IKEv2保持活动请求或一些未答复的CREATE CHILD SA请求之后，发起方可以将其与响应方的连接视为断开，并可以发送新的IKE SA INIT请求以每个断开的连接。例如，如果将连接配置为在断开时自动建立备份（strongSwan中的选项“ closeaction = restart”），或者在出站IP数据包到达时自动建立连接（strongSwan选项“ auto=route”）。



## 0x04 Attacking an IKEv2 Implementation

为了具体展示“偏差攻击”的含义，攻击了StrongSwan开源IKEv2的实现。实验代码可在 [https://gitlab.inria.fr/tninet/demo](https://gitlab.inria.fr/tninet/demo) 中找到。实验还允许验证定理III.2中给出的表达式Ts mem。

### <a class="reference-link" name="A.%E8%AE%BE%E7%BD%AE"></a>A.设置

1）全局设置：在实验中，目标IKEv2实现是strongSwan版本5.1.2。除另有说明外，对软件使用默认选项。

为了重现攻击，创建了2个代表受害者和入侵者的Linux虚拟机（VM），以及代表N个发起者的Ndemo VM，其中Ndemo是可配置的参数。因为只需要响应者的IP地址，所以没有实例化它们。此外创建了一个名为Probe的VM，其目的是检测最终的拒绝服务。

所有计算机都通过同一个本地（虚拟）网络（代表Net）连接，并且它们是唯一与之相连的计算机。使用本地网络可以使轻松地通过Intruder再现数据包的偏差，如下所述。此外，它可以确保对网络工作传播时间和守护程序资源负载的更多控制。

创建一个称为CA的证书颁发机构。为Probe，Victim和每个启动者生成由CA签名的证书及其关联的私钥。将各自的证书和私钥以及CA的证书放置在Probe，受害者和每个发起方中。

2）实现Initiators：出于实际原因，决定不创建通用场景的N个发起者，而是仅创建Ndemo发起者，每个发起者向响应者发送N/Ndemo m1消息。此外，使发起者打算仅与一个响应者同行进行对话。这使实施Intruder更加容易，因为那样的话Intruder只需要欺骗一个IP地址（请参阅下文以了解Intruder为何执行欺骗）。

对于strongSwan，在如下所示的启动器中设置rightid选项。 “％”符号强制strongSwan不要在IKE AUTH请求中发送IDr。

[![](https://p5.ssl.qhimg.com/t016dd6200704f044b2.png)](https://p5.ssl.qhimg.com/t016dd6200704f044b2.png)

发起方尝试以可配置的速率σ与响应方建立连接。会在可配置的时间D之后停止攻击。

3）实现Intruder：为了重现入侵者的数据包偏差，使用了ARP缓存中毒攻击。在这种攻击中，入侵者将ARP答复发送给所有发起者，并将其MAC地址绑定到响应者的IP。这样，发起者发送到响应者的所有数据包都会被入侵者拦截。为了进行这种攻击，使用Intruder中的arpspoof工具。然后，使用Linux iptables命令将流量重定向到受害人，并丢弃AUTHENTICATION FAILED通知。当然，仅由于使用本地网络，才可能使用此方法。实际上，当Net不是本地网络时，必须使用其他方式进行偏离。

4）实现Victim：使用Linux控制组（Cgroups）为软件分配恰好为C的（可配置）内存给受害者。请注意，在设置中，发起者发送的TS有效载荷对于受害人而言不是有效的主张。因此，连接将仅由一个无子女的IKE SA（包含两个单向SA）组成。在实验中观察到，当没有可用软件存储空间时，Victim的Linux内存不足killer（OOMkiller）将杀死该软件进程。这导致所有已安装的SA丢失。这是不受欢迎的行为：设置所有SA的备份可能需要一些时间，同时挂起使用流量SA的受保护IP流。为了观察实验中的内存耗尽，因此禁用了受害者的内核和软件对照组的内存不足killer。

不希望Probe影响受害者的内存能力。因此，以受害者的短暂身份建立了探针的连接，即，探针的连接在短时间内从受害者的内存中删除。为此，为受害者中的StrongSwan使用了特定的选项。在实验代码的README.md文件中对此进行了说明。

5）实施探针：探针VM尝试每两秒钟建立一个新的IPsec连接（可配置）。对于每次尝试，五秒钟后（可配置），Probe会检查尝试是否成功并报告结果。如果连续两次尝试失败（可配置），则认为Probe被拒绝了。

### <a class="reference-link" name="B.%E9%AA%8C%E8%AF%81DoS%E6%97%B6%E9%97%B4%E8%A1%A8%E8%BE%BE"></a>B.验证DoS时间表达

回想一下，L是受害者的负载，即IKEv2应用程序（以及与不是Probe或Initiator机器的机器的连接，但实验中没有这些机器）连接所占用的受害者内存量。 C是在受害者中分配给IKEv2的内存容量。 m是存储与一个连接有关的所有数据所需的内存量。 S是从一开始就已经过时的连接失效的平均时间。最后，σ是发起方向响应方发送m1消息的速率。

为了通过实验验证Ts mem的表达，在设置的背景下测量软件的L和m。验证L和m为常数（即它们不依赖于C或σ），并在元组（C，σ）变化时测量Ts mem（**measured** Ts mem）。

要测量L，只需测量未安装连接时软件所使用的内存量。要测量m，以给定的吞吐量通过大量连接填充Victim的内存，然后将内存增加量除以连接数量。有几种方法可以衡量进程使用的内存量。为了与限制软件可用内存（使用cgroup）的方式保持一致，采用存储在软件cgroup文件memory.usage中的值（以字节为单位）。

还在实验过程中测量了σ（**measured** σ），发现它不同于配置的σ（**conf igured** σ）。这很可能是由于虚拟化造成的。为使定理III.2的实验验证不受配置的σ和测得的σ不同的事实的影响，使用测得的σ计算定理III.2预测的Ts mem值（**Expected** Ts mem）。

### <a class="reference-link" name="C.%E7%BB%93%E6%9E%9C"></a>C.结果

strongSwan与IKEv2的RFC有一点不同。当IKE AUTH请求IDr有效负载与响应者的任何身份都不对应时，strongSwan会通知未找到匹配的对等配置，并取消IKE SA的建立。在RFC中，其含义如下：“如果发起者提出的IDr对于响应者不可接受，则响应者可以使用其他IDr完成交换”。换句话说，如果IDr与它的身份之一不对应，则响应者可能仍会安装Child SA，并使用其他IDr来完成交换。

IKE AUTH请求IDr有效负载在RFC和strongSwan中都是可选的。因此，strongSwan采取的行为和上面描述的行为对于偏差攻击而言包含以下含义：当启动器计算机运行strongSwan并配置为不发送IDr有效负载时，攻击就会起作用。但是，当它们运行strongSwan并配置为发送IDr有效负载时，攻击将不起作用，因为IDr等于响应者计算机的身份，而不是受害者的身份。在IKE AUTH请求中不发送IDr有效负载的情况并非罕见，因为它可以将响应者的身份隐藏给活动的攻击者。

[![](https://p4.ssl.qhimg.com/t0134e89eb1e571fac6.png)](https://p4.ssl.qhimg.com/t0134e89eb1e571fac6.png)

对L和m的度量证实L和m不依赖于C或σ（或很小）。获得L≈1 MB和m≈18.805 kB。上图显示了对Ts mem进行测量的结果。测度接近定理III.2预测的值：获得的平均相对误差为1.3％，最大相对误差为2.4％。



## 0x05 Counter Measures

### <a class="reference-link" name="A.%E5%B0%9D%E8%AF%95%E4%BF%9D%E6%8A%A4%E5%BD%93%E5%89%8D%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%9E%E7%8E%B0"></a>A.尝试保护当前协议的实现

无法承受偏差攻击目标的用户需要立即提供保护。在本节中显示了IKEv2中引入的用于抵御DoS攻击的cookie和拼图机制对于抵制偏差攻击没有用。然后，注意到Dead Peer Detection可能只是一个较小的缓解措施，并考虑了两种预防攻击但遭受重大弊端的措施：使用PSK身份验证和为受害者提供足够的资源。

（1）现有的DoS对策：引入cookie机制以保护IKEv2避免由于收到大量IKE SA INIT请求而导致内存耗尽。如果采用了该机制，则当响应者检测到大量的半开放式IKE SA时，它将使用包含cookie的IKEv2 INFORMATIONAL消息来响应每个IKE SA INIT请求（不包含cookie）。 然后，发起方再次发送添加了cookie的相同请求，然后响应者验证cookie和请求是否匹配。这意味着攻击者需要将其发送的IKE SA INIT请求保留在内存中。因此，这使得攻击者填充网关的半开放SA数据库的成本更高。但是，在偏差攻击中，cookie将由发起方而非入侵者处理。因此，激活Cookie绝对不会影响Intruder的内存需求。因此，就内存而言，它不会增加攻击的成本。请注意，cookie机制还增加了受害人接收IKE SA INIT请求与使用新SA填充其内存之间的时间。但这既不会增加攻击者需要偏离的数据包的吞吐量，也不会增加偏差攻击成功所需的持续时间。

谜题机制( puzzle mechanism)是cookie机制的一种改进。现在，发起者需要记住其请求并解决难题，然后再次发送其请求。像cookie机制一样，谜题机制对于响应者而言也是无状态的。困惑会增加攻击CPU的成本。但是，在偏离攻击中，需要解决发起方问题的是发起方，而不是入侵者。因此，像Cookie这样的难题对对抗偏差攻击毫无用处。

2）使用一组配置良好的参数：使用一组配置良好的参数确定一种减轻偏差攻击的方法：使用Dead Peer Detection（DPD）。 DPD是IKEv2中的一项可选机制。实际上，在strongSwan中，默认情况下未启用它。使用DPD时，只要一方发现最近未在IKE SA或其任何子级SA上收到流量，则它可能会向SA的对等方发送保持活动请求。如果对等方没有响应，则在多次重传之后，该方可以从其内存中删除IKE SA及其所有子SA。在偏差攻击的情况下，DPD降低S，即从一开始就处于连接失效状态的平均时间停留在内存中。由于Σmem与S成反比，因此DPD使得使用偏差攻击难以实现内存耗尽。

但是，将S降低太多会在网络上造成过载，因此S不能太低。当在strongSwan中启用DPD时，使用其他选项的默认值，则有S = 195s，它将Σmem乘以18。因此，DPD仅可减轻内存消耗。

3）预共享密钥身份验证：正如指出的那样，如果将PSK用于身份验证，则不可能发起偏差攻击，前提是Initiator机器和Victim不与Initiator机器和受害者共享相同的PSK。因此，使用PSK是一种对策。但是，PSK和证书不能完全满足相同的需求。当对等体的数量相对较少时，将使用PSK。如果不是这种情况，则必须考虑另一对策。

4）为受害者提供足够的资源：解决内存耗尽的一种方法是为受害者提供足够的内存容量，以处理尽可能多的连接。令Nt为受害人信任的对等体数。回想一下，m是用于存储一个连接的内存量。然后，将需要为受害者提供至少Nt×m的内存。如果例如Nt = 106（例如，在物联网环境中），需要23GB的内存来防止攻击。这种对策是有效的，但是IKEv2不应依赖于对用户的这种建议。

B.改进协议规范<br>
试图保护当前协议的实现或者不足以防止偏差攻击，或者存在明显的缺陷。因此，提议对协议规范进行两次修改，以阻止其对偏差攻击的脆弱性。

1）使用IDr有效负载：一种修改协议的方法是使IKE AUTH请求中的IDr有效负载成为必需，并由响应者修改其处理。适当的行为是，如果IDr不可接受（如下所述），则不安装子SA，而是通过向发起方发送AUTHENTICATION FAILED通知来取消IKE SA的建立。<br>
IPsec和IKEv2规范应在PAD中有一个新的要求字段。将此字段称为本地ID字段。为了保持一致性，还应将RFC 4301描述的ID字段重命名为远程ID字段。本地ID字段将是ID的非空列表。每个ID与ID字段的格式相同（例如，可以使用通配符）。当IKE AUTH请求到达时，PAD查找完成。当远程ID字段和本地ID字段分别与IDi和IDr有效负载匹配时，PAD条目将与请求匹配。

请注意，strongSwan已经实现了本地ID字段。它对应于ipsec.conf配置文件的lef tid属性。然而，IDr修改具有一个缺点。总结来说，爱丽丝使用未经修改的协议启动了与鲍勃的IKEv2会话。IKEv2的设计既可以隐藏来自被动攻击者的身份，也可以隐藏来自主动攻击者的Bob的身份。它不会向活跃的攻击者隐藏爱丽丝的身份，因为Alice首先使用IDi有效载荷揭示了自己的身份。攻击者可以通过假冒Bob的IP地址来学习此身份。

现在假设使用IDr方法修改协议。通过使用入侵者模仿Bob的相同攻击，入侵者现在可以了解Bob的身份，甚至可以证明Alice打算与Bob对话。换句话说，此修改有效，但响应者的身份将不再对活动的攻击者隐藏。如果可以在ID有效载荷中找到敏感信息，则可能会出现问题。这是常见的情况，因为人们经常使用专有名称（DN），其中给出了国家/地区，机构名称和电子邮件地址。

2）添加密钥确认：有一种方法可以修改IKEv2-Sig，该方法不需要在通过密码验证之前公开响应者ID。添加了第三个ex更改，称为密钥确认和书面KEY CONF。此交换与IKEv2保持活动交换完全相同：空的INFORMATIONAL请求和空的INFORMATIONAL响应。要求响应者仅在收到有效的KEY CONF请求后才安装其连接，而发起者仅在收到有效的KEY CONF响应后才安装其连接。关键确认首先由Basin等人提出。 [3]中的方法作为对倒数第二个身份验证缺陷的对策。由于偏差攻击利用了后者，因此密钥确认是偏差攻击的对策。

另一种修改可能是简单地将强制性的AUTH SUCCESS消息作为对IKE AUTH响应的确认。但是，在IKEv2中，除错误消息外，所有消息均成对存在。这是因为IKEv2是通过UDP承载的，因此，确保已收到请求的唯一方法是等待响应消息并设置重传，以防它未到达（直到超时）。通过KEY CONF响应，启动器现在可以确定在安装连接时，响应器已经安装了它。

将交换添加到协议可以看作是其成本的增加，因为建立连接将花费更多时间。但是KEY CONF消息只需要很少的时间和计算能力即可生成和处理，因为没有非对称密码或密钥派生操作可以执行。因此，这是防止偏差攻击的非常有效的解决方案。



## 0x06 Conclusion and Future Work

在本文中设计了一种针对IKEv2的新型慢速拒绝服务攻击：偏差攻击。解释了其工作流程，并精确评估了其要求和后果。为了具体演示攻击，针对strongSwan开源实现成功地实施了攻击。

IKEv2在现代基础设施中占据的中心地位无疑使需要采取对策。讨论了保护当前协议实现的可用方法的效率。但是，它们都不是完整的解决方案。更糟糕的是，IKEv2中引入的用于抵制DoS攻击的cookie和谜题机制对于抵御偏差攻击完全无效。因此，在更高层次上解决了该问题，并提出了对该协议的两种可能的修改，均可以防止攻击。

最后，正如所看到的，本文概述了身份验证协议的弱协议属性的重要性。违反它不一定意味着违反保密性，但是已经证明它可以允许其他攻击。特别是，当协议在双方的内存中建立某些连接时，可能会导致DoS攻击。验证TLS，SSH和其他有状态身份验证协议的弱协议可能会很有趣。



## Reference

[1] C. Meadows, “Analysis of the internet key exchange protocol using the nrl protocol analyzer,” in Proceedings of the 1999 IEEE Symposium on Security and Privacy, 1999.

[2] C. Cremers, “Key exchange in ipsec revisited: Formal analysis of ikev1 and ikev2,” in European Symposium on Research in Computer Security. Springer, 2011.

[3] G. Lowe, “A hierarchy of authentication specifications,” in mProceedings 10th Computer Security Foundations Workshop,Jun 1997.

[4] D. Dolev and A. Yao, “On the security of public key protocols,” IEEE Transactions on Information Theory, Mar 1983.
