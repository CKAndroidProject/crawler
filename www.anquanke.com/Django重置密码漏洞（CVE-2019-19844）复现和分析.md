> 原文链接: https://www.anquanke.com//post/id/196044 


# Django重置密码漏洞（CVE-2019-19844）复现和分析


                                阅读量   
                                **1309723**
                            
                        |
                        
                                                                                                                                    ![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



[![](https://p0.ssl.qhimg.com/t011e477c9ba91cb4f1.jpg)](https://p0.ssl.qhimg.com/t011e477c9ba91cb4f1.jpg)



## 前言

[CVE-2019-19844](https://nvd.nist.gov/vuln/detail/CVE-2019-19844)是Django重置密码功能的一个漏洞。Django的密码重置表单使用不区分大小写的查询来获取输入的邮箱地址对应的账号。一个知道邮箱地址和账号对应关系的攻击者可以精心构造一个和该账号邮箱地址不同，但经过Unicode大小写转换后相同的邮箱地址，来接收该账户的密码重置邮件，从而实现账户劫持的攻击目标。

本文较为详细地记录了该漏洞的复现过程，简要分析了漏洞成因，讨论了攻击所需的条件。



## 复现

基于Python 3.6.0，Django 3.0.0和MariaDB 10.4.11复现漏洞。

### <a class="reference-link" name="%E5%87%86%E5%A4%87%E7%8E%AF%E5%A2%83"></a>准备环境

首先安装Python 3.6.0和MariaDB 10.4.11，然后安装有漏洞的Django版本3.0.0：

```
pip install django==3.0.0
```

全部安完后创建数据库`cve_2019_19844_test`：

```
MariaDB [(none)]&gt; CREATE DATABASE cve_2019_19844_test;
```

新建Django项目`cve_2019_19844_test`：

```
django-admin startproject cve_2019_19844_test
```

需对项目`cve_2019_19844_test`的配置文件`setting.py`做一些修改。将`LANGUAGE_CODE`为`zh-hans`，这样Django就会显示汉语界面了。修改数据库相关配置为使用MariaDB：

```
DATABASES = `{`
    'default': `{`
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'cve_2019_19844_test',
        'USER': 'root',
        'PASSWORD': 'root',
        'HOST': 'localhost',
        'PORT': '3306',
    `}`
`}`
```

在文件末尾添加发送邮件相关的配置，示例如下。

```
EMAIL_USE_SSL = True
EMAIL_HOST = 'smtp.qq.com'  # 如果是 163 改成 smtp.163.com
EMAIL_PORT = 465
EMAIL_HOST_USER = 'xxx@qq.com' # 帐号
EMAIL_HOST_PASSWORD = 'p@ssw0rd'  # 密码
DEFAULT_FROM_EMAIL = EMAIL_HOST_USER
```

为使用MariaDB做数据库，还需在`__init__.py`中添加：

```
import pymysql
pymysql.install_as_MySQLdb()
```

接着执行以下命令创建数据表：

```
python manage.py migrate
```

然后创建一个用户，用户名是`werner`，邮箱地址是`[i@werner.wiki](mailto:i@werner.wiki)`：

```
python manage.py createsuperuser
```

[![](https://p5.ssl.qhimg.com/t01fdcf951a197c8dae.png)](https://p5.ssl.qhimg.com/t01fdcf951a197c8dae.png)

启动Web服务：

```
python manage.py runserver
```

在浏览器中访问[http://127.0.0.1:8000/admin/](http://127.0.0.1:8000/admin/)，看到如下图所示的登录页面，并没有重置密码的功能。

[![](https://p3.ssl.qhimg.com/t01c590e50edc302ce0.png)](https://p3.ssl.qhimg.com/t01c590e50edc302ce0.png)

Django没有默认开启重置密码功能，从[官方文档](https://docs.djangoproject.com/zh-hans/3.0/topics/auth/default/#module-django.contrib.auth.views)找到了开启该功能的方法。我们需要编辑`urls.py`，引入一些url配置。修改后的`urls.py`如下所示。

```
from django.contrib import admin
from django.urls import path
from django.urls import include    # 此行是新增的

urlpatterns = [
    path('admin/', admin.site.urls),
    path('accounts/', include('django.contrib.auth.urls')),    # 此行是新增的
]
```

然后访问[http://127.0.0.1:8000/accounts/password_reset/](http://127.0.0.1:8000/accounts/password_reset/)，看到如下图所示的重置密码页面。

[![](https://p1.ssl.qhimg.com/t01f3db0c3cd3e8cbb2.png)](https://p1.ssl.qhimg.com/t01f3db0c3cd3e8cbb2.png)

根据文档，Django会生成一个可以重置密码的一次性链接，并把这个链接发到用户的邮箱中。如果邮箱地址不存在，Django不会发送邮件，但仍然显示“密码重置链接已经发送”，以避免攻击者探测一个邮箱地址是否为某个用户所有。

输入邮箱`[i@werner.wiki](mailto:i@werner.wiki)`测试一下，成功收到了密码重置邮件，如下图所示。

[![](https://p5.ssl.qhimg.com/t0114a579bb09a8b932.png)](https://p5.ssl.qhimg.com/t0114a579bb09a8b932.png)

点击其中的链接就可以重置密码了。至此，环境准备完毕。

### <a class="reference-link" name="%E5%A4%8D%E7%8E%B0%E6%BC%8F%E6%B4%9E"></a>复现漏洞

根据漏洞描述我们知道问题出在Unicode大小写转换。Unicode号称万国码，包含各种语言，有些语言的字母在进行大小写转换时就会出现奇怪的现象。如小写德文字母“ß”转换成大写是“SS”，再转换成小写就变成了“ss”，大小写转换竟然不可逆，甚至连字符数量都发生了变化。在Python中进行测试截图如下。

[![](https://p3.ssl.qhimg.com/t01d7c6880b2b96efa2.png)](https://p3.ssl.qhimg.com/t01d7c6880b2b96efa2.png)

在准备环境时我们填写的用户邮箱是`[i@werner.wiki](mailto:i@werner.wiki)`，刚好土耳其文和阿塞拜疆文中的字母“ı”转换成大写是英文字母“I”，再转换成小写就变成了英文字母“i”。知道以上信息，攻击者就可以发起攻击。首先注册域名`werner.wikı`（假设这个域名存在），然后搭建邮件服务器，设置邮箱`[i@werner.wik](mailto:i@werner.wik)ı`，最后在Django重置密码的表单中填入这个邮箱地址，提交后攻击者就可以收到用户`werner`的密码重置邮件了。如下图所示，Django的确发送了密码重置邮件，但由于收件邮箱的域名无法解析，所以一直处于发送中的状态。

[![](https://p3.ssl.qhimg.com/t01a2e6a1bb458a6aad.png)](https://p3.ssl.qhimg.com/t01a2e6a1bb458a6aad.png)

勉强算是成功复现了漏洞。这里为何不使用`ı[@werner](https://github.com/werner).wiki`呢？因为`[@werner](https://github.com/werner).wiki`使用的邮件系统不支持地址中包含`ı`。现实中的攻击者常常也会面临这个问题，实际上攻击者很可能无法任意注册和用户同后缀的邮箱，便只能修改邮箱后缀了。在这个例子中顶级后缀`wikı`是不存在的。但攻击者任然可能成功攻击，比如被攻击的是`[xxx@baidu.com](mailto:xxx@baidu.com)`，攻击者就可以构造`xxx[@ba](https://github.com/ba)ıdu.com`。从阿里云查询到域名`baıdu.com`还没有被注册。

[![](https://p2.ssl.qhimg.com/t01396dad04abf5952a.png)](https://p2.ssl.qhimg.com/t01396dad04abf5952a.png)



## 分析

### <a class="reference-link" name="%E9%97%AE%E9%A2%98%E4%BB%A3%E7%A0%81"></a>问题代码

通过阅读修复此漏洞的[commit](https://github.com/django/django/commit/302a4ff1e8b1c798aab97673909c7a3dfda42c26)可以找到和该漏洞相关的代码如下所示：

```
def get_users(self, email):
        """Given an email, return matching user(s) who should receive a reset.
        这里的email就是重置密码表单中用户填写的邮箱地址
        """
        active_users = UserModel._default_manager.filter(**`{`
            '%s__iexact' % UserModel.get_email_field_name(): email,
            'is_active': True,
        `}`)
        return (u for u in active_users if u.has_usable_password())
```

在我们的复现中`UserModel.get_email_field_name()`返回值是`email`，也就是说重置密码功能是通过如下的语句查询用户的：

```
active_users = UserModel._default_manager.filter(email__iexact=email, is_active=True)
```

注意在查询邮箱地址时使用了`iexact`，不区分大小写。我们在Django shell中测试一下，用如下语句确实可以查询到用户：

```
UserModel._default_manager.filter(email__iexact='i@werner.wikı', is_active=True)
```

截图如下。

[![](https://p0.ssl.qhimg.com/t017a49e63493673765.png)](https://p0.ssl.qhimg.com/t017a49e63493673765.png)

那么去掉`iexact`是否可以呢？测试发现是可以的，截图如下。

[![](https://p5.ssl.qhimg.com/t0106889b510816d644.png)](https://p5.ssl.qhimg.com/t0106889b510816d644.png)

这是因为MariaDB数据库默认不区分大小写。我们在创建MariaDB数据库时没有指定`COLLATE`，便取了默认值`utf8_genera_ci`，其中`ci`的含义是`case insensitive`。若在创建数据库时指定`COLLATE`为`utf8_bin`（将字符串中的每一个字符用二进制数据存储，区分大小写）：

```
CREATE DATABASE cve_2019_19844_test DEFAULT CHARACTER SET utf8 COLLATE utf8_bin;
```

再重复上面的测试，发现不管有没有`iexact`都无法复现漏洞。此外，若是使用sqlite做数据库就无法复现漏洞，而使用PostgreSQL却可以复现漏洞。这么想来这一漏洞的真正成因是数据库特性。

将数据库改回可以复现漏洞的状态，开启MariaDB的SQL日志，记录到Django实际执行的SQL语句是：

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p0.ssl.qhimg.com/t019d3ce7729f17b0ad.png)

复制这个语句将它粘贴到MariaDB控制台中执行，发现果然能查到数据，如下图所示。

[![](https://p4.ssl.qhimg.com/t013da387efd59b8a63.png)](https://p4.ssl.qhimg.com/t013da387efd59b8a63.png)

MariaDB是运行在Windows上的，一开始我在CMD中登录MariaDB控制台，执行上述SQL语句发现查询不出数据，使用`chcp`命令将CMD编码改为UTF-8也不行。后来在Linux中登录MariaDB控制台（连接的还是运行在Windows上的同一个MariaDB）测试成功。

**总结漏洞成因**：Django发送重置密码邮件时会发送到用户输入的邮箱地址，而不是从数据库中查询出的邮箱地址。Django重置密码功能没有特殊处理Unicode字符串。某些数据库（在某种配置下）进行字符串匹配时不区分大小写，会自动进行Unicode大小写转换。Unicode大小写转换不是简单的一对一关系，而是复杂的多对多关系。某些不是英文字母的Unicode字符在进行大小写转换后会变成英文字母，攻击者输入特殊构造的含有这种字符的邮箱地址便可以接收到特定账户的密码重置邮件。

### <a class="reference-link" name="%E5%8F%AF%E5%88%A9%E7%94%A8%E7%9A%84Unicode%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"></a>可利用的Unicode大小写转换

似乎若某个Unicode字符本身不是英文字母，但在经过大小写转换后会变成一个或多个英文字母，那么这个Unicode大小写转换就是可以利用的。现在我们想做的是找出所有可利用的Unicode大小写转换。诚然，一个小写字母的大写字母是什么和一个大写字母的小写字母是什么应该由自然语言决定，但在计算机领域，这种转换关系被定义成了几张映射表：一个字母对一个字母的大小写转换映射定义在[UnicodeData.txt](ftp://ftp.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt)中，一个字母对多个字母的大小写转换映射定义在[SpecialCasing.txt](ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt)中。遍历这几张映射表，找到了如下表所列的可能可以利用的Unicode大小写转换。

<th style="text-align: center;">字符</th><th style="text-align: center;">Unicode编码</th><th style="text-align: center;">转换</th><th style="text-align: center;">转后字母</th><th style="text-align: center;">转换后字母编码</th>
|------
<td style="text-align: center;">[ı](https://www.fileformat.info/info/unicode/char/0131/index.htm)</td><td style="text-align: center;">U+0131</td><td style="text-align: center;">大写</td><td style="text-align: center;">I</td><td style="text-align: center;">U+0073</td>
<td style="text-align: center;">[ſ](https://www.fileformat.info/info/unicode/char/017F/index.htm)</td><td style="text-align: center;">U+017F</td><td style="text-align: center;">大写</td><td style="text-align: center;">S</td><td style="text-align: center;">U+0083</td>
<td style="text-align: center;">[ß](https://www.fileformat.info/info/unicode/char/00DF/index.htm)</td><td style="text-align: center;">U+00DF</td><td style="text-align: center;">大写</td><td style="text-align: center;">SS</td><td style="text-align: center;">U+0053 U+0053</td>
<td style="text-align: center;">[ﬀ](https://www.fileformat.info/info/unicode/char/FB00/index.htm)</td><td style="text-align: center;">U+FB00</td><td style="text-align: center;">大写</td><td style="text-align: center;">FF</td><td style="text-align: center;">U+0046 U+0046</td>
<td style="text-align: center;">[ﬁ](https://www.fileformat.info/info/unicode/char/FB01/index.htm)</td><td style="text-align: center;">U+FB01</td><td style="text-align: center;">大写</td><td style="text-align: center;">FI</td><td style="text-align: center;">U+0046 U+0049</td>
<td style="text-align: center;">[ﬂ](https://www.fileformat.info/info/unicode/char/FB02/index.htm)</td><td style="text-align: center;">U+FB02</td><td style="text-align: center;">大写</td><td style="text-align: center;">FL</td><td style="text-align: center;">U+0046 U+004C</td>
<td style="text-align: center;">[ﬃ](https://www.fileformat.info/info/unicode/char/FB03/index.htm)</td><td style="text-align: center;">U+FB03</td><td style="text-align: center;">大写</td><td style="text-align: center;">FFI</td><td style="text-align: center;">U+0046 U+0046 U+0049</td>
<td style="text-align: center;">[ﬄ](https://www.fileformat.info/info/unicode/char/FB04/index.htm)</td><td style="text-align: center;">U+FB04</td><td style="text-align: center;">大写</td><td style="text-align: center;">FFL</td><td style="text-align: center;">U+0046 U+0046 U+004C</td>
<td style="text-align: center;">[ﬅ](https://www.fileformat.info/info/unicode/char/FB05/index.htm)</td><td style="text-align: center;">U+FB05</td><td style="text-align: center;">大写</td><td style="text-align: center;">ST</td><td style="text-align: center;">U+0053 U+0054</td>
<td style="text-align: center;">[ﬆ](https://www.fileformat.info/info/unicode/char/FB06/index.htm)</td><td style="text-align: center;">U+FB06</td><td style="text-align: center;">大写</td><td style="text-align: center;">ST</td><td style="text-align: center;">U+0053 U+0054</td>
<td style="text-align: center;">[K](https://www.fileformat.info/info/unicode/char/212A/index.htm)</td><td style="text-align: center;">U+212A</td><td style="text-align: center;">小写</td><td style="text-align: center;">k</td><td style="text-align: center;">U+0083</td>

但进一步测试发现，只有前两行，一个字母对一个字母的大写转换是可以利用的。例如把用户邮箱改为`[ss@werner.wiki](mailto:ss@werner.wiki)`，用`ß[@werner](https://github.com/werner).wiki`查询不出来。

[![](https://p1.ssl.qhimg.com/t011d19584968f5f747.png)](https://p1.ssl.qhimg.com/t011d19584968f5f747.png)

这应该和MariaDB的底层实现有关，超出了本文范围，按下不表。

### <a class="reference-link" name="%E5%A6%82%E4%BD%95%E4%BF%AE%E5%A4%8D"></a>如何修复

Django做了两处改动来修复这个漏洞：
1. 从数据库检索出可能匹配的帐户列表后，再使用专门的Unicode字符串比较函数来比较用户输入的邮箱地址和数据库中检索出的邮箱地址是否相等。这样无论后端使用怎样的数据库都避免了这一漏洞。
1. 在发送重置密码邮件时，发送到数据库中检索出的邮箱地址，不再发送到用户输入的邮箱地址。这样攻击者就算能绕过Unicode字符串比较函数的检查也无法接收到密码重置邮件。
### <a class="reference-link" name="%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6"></a>利用条件

为利用这一漏洞，至少需满足以下条件：
- Django启用了找回密码功能(默认未启用)；
- 使用的数据库配置为不区分Unicode大小写；
- 攻击者知道被攻击账户的邮箱地址；
- 被攻击账户的邮箱地址中要含有字母i或s；
- 被攻击账户的邮箱系统要支持非ASCII字符的地址且攻击者可以任意注册或可利用的域名存在且没有被注册。
所以在现实世界中这一漏洞可能很难利用，故而危害较低。



## 总结

原以为这是一个很简单的漏洞，结果花了好几天时间才勉强强复现了这个漏洞，大致搞懂了漏洞成因。

虽然这一漏洞很难利用，但它具有启发意义：若是编程语言中没有特殊处理Unicode字符串而数据库不区分Unicode大小写，那么便可能可以使用`ı`和`ſ`绕过某些安全措施。



## 参考
1. [Django security releases issued: 3.0.1, 2.2.9, and 1.11.27](https://www.djangoproject.com/weblog/2019/dec/18/security-releases/)
1. [使用 Django 的验证系统：验证视图](https://docs.djangoproject.com/zh-hans/3.0/topics/auth/default/#module-django.contrib.auth.views)
1. [Unicode 大小写折叠](https://www.elastic.co/guide/cn/elasticsearch/guide/current/case-folding.html)
1. [Fixed CVE-2019-19844 — Used verified user email for password reset requests.](https://github.com/django/django/commit/302a4ff1e8b1c798aab97673909c7a3dfda42c26)
1. [https://github.com/django/django/blob/3.0/django/contrib/auth/forms.py#L272-L275](https://github.com/django/django/blob/3.0/django/contrib/auth/forms.py#L272-L275)
1. [MySQL开启日志记录查询/执行过的SQL语句](https://blog.csdn.net/maoxinwen1/article/details/79590228)
1. [Character Properties, Case Mappings &amp; Names FAQ](http://www.unicode.org/faq/casemap_charprop.html)