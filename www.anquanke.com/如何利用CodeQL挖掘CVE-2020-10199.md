
# 如何利用CodeQL挖掘CVE-2020-10199


                                阅读量   
                                **489190**
                            
                        |
                        
                                                            评论
                                <b>
                                    <a target="_blank">2</a>
                                </b>
                                                                                                                                    ![](./img/202987/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



[![](./img/202987/t016bfff31e3cc7d67b.jpg)](./img/202987/t016bfff31e3cc7d67b.jpg)



## 前言

挖掘Java漏洞时候存在一个痛点在已知漏洞点的情况下，如何找到可控点，以及确定一条具体的数据流.

前几天看到[@Alvaro](https://github.com/Alvaro) Muñoz 利用codeql挖掘到[CVE-2020-10199]Nexus Repository Manager远程代码执行漏洞.于是就对codeql产生强烈的好奇心,怼了几天codeql语法和CVE案例。抠出挖掘该CVE的Ql代码



## Codeql

对Codeql具体介绍可以参考：[https://help.semmle.com/](https://help.semmle.com/)

使用codeql能够很明确搜索出方法调用的数据流, QL代码编写思路相当于在一个代码数据库中利用编写的逻辑搜索出可能的调用点。重点是确定Souce和Sink搜索逻辑.



## 漏洞原理简要分析

该漏洞是由于未做过滤造成表达式注入,作者确定漏洞点执行函数`buildConstraintViolationWithTemplate,`其该方法中`bean.getMessage()`返回结果`message`并未使用`stripJavaEl`方法过滤造成表达式注入

[![](./img/202987/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p3.ssl.qhimg.com/t01ac2de7e0b1f60bb4.png)

最后调用`org.hibernate.validator.internal.engine.messageinterpolation#interpolate`,执行插入操作并解析恶意字符串，造成表达式注入.

[![](./img/202987/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p0.ssl.qhimg.com/t01d45af8ab764b6ac4.png)



## HelperBean bean#message

编写Codeql最重要的是先确定数据流的Sink点即污染点字段.这里跟进`org.sonatype.nexus.validation.HelperBean#getMessage`方法.返回message值.该值经由HelperBean方法传入

[![](./img/202987/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p0.ssl.qhimg.com/t018d1d0dc3760eab2b.png)

### <a class="reference-link" name="Ql%E4%BB%A3%E7%A0%81"></a>Ql代码

这里直接给出代码并做简单讲解：搜索出流经`HelperBean`方法中`message`字段的数据流

isSink方法搜索逻辑: 定义参数p,该参数p由被调用的`HelperBean`方法使用且该p参数名为message

isSouce方法搜索逻辑：由于不清楚哪里数据源最终经过该sink，所以直接使用source.asExpr()调用所有可能的表达式作为数据流.

```
import java
import semmle.code.java.dataflow.FlowSources


class Config extends DataFlow::Configuration{
    Config(){
        this = "1"
    }
    override predicate isSource(DataFlow::Node source){
        exists(source.asExpr()) 
    }
    override predicate isSink(DataFlow::Node sink){
        exists(
            Parameter p | p = sink.asParameter() and p.getCallable().getName() = "HelperBean" and p.getName() = "message"
        )
    }


}

from Config config ,DataFlow::PathNode source, DataFlow::PathNode sink
where config.hasFlowPath(source, sink)
select source.getNode().getLocation(),source,sink
```

### <a class="reference-link" name="%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C"></a>搜索结果

Run Query

[![](./img/202987/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p2.ssl.qhimg.com/t01122e5ea794f449fe.png)



## AbstractGroupRepositoriesApiResource#validateGroupMembers

根据搜索结果，这里最可疑的**souce**就是**AbstractGroupRepositoriesApiResource:92**.点击该结果跟进，Codeql很友好对污染点respositoryName进行标记。向上溯源得到`respositoryName`值最终由`request`中获取.

[![](./img/202987/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p0.ssl.qhimg.com/t01877f03d73a9243d2.png)

### <a class="reference-link" name="Ql%E4%BB%A3%E7%A0%81"></a>Ql代码

现在就是需要确定`AbstractGroupRepositoriesApiResource#validateGroupMembers()`方法由哪里调用.

isSink方法搜索逻辑：定义参数p,该参数p由被调用的`validateGroupMembers`方法使用且该p参数名为request

isSouce方法搜索逻辑：这里souce原本是用Codeql自带`RemoteFlowSource`获取，但是发现并没有结果。所以这里直接用souce.asExpr()搜索全局表达式。

```
import java
import semmle.code.java.dataflow.FlowSources

class Config extends DataFlow::Configuration{
    Config(){
        this = "1"
    }
    override predicate isSource(DataFlow::Node source){
       exists(source.asExpr())
       }
    override predicate isSink(DataFlow::Node sink){
        exists(
            Parameter p | p = sink.asParameter() and p.getCallable().getName() = "validateGroupMembers" and p.getName() = "request"

        )
    }


}
// 得到可能可控的函数
from Config config ,DataFlow::PathNode source, DataFlow::PathNode sink
where config.hasFlowPath(source, sink)
select source, sink
```

### <a class="reference-link" name="%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C"></a>搜索结果

Run Query

[![](./img/202987/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p3.ssl.qhimg.com/t0171567b52ff1f1749.png)

其中`GolangGroupRepositoriesApiResource`就是该漏洞调用的可控点.

[![](./img/202987/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p3.ssl.qhimg.com/t01298d59e3d740defe.png)



## 结语

原文有误，还请师傅们斧正。希望师傅们喜欢



## 参考链接

[https://help.semmle.com/wiki/display/CBJAVA/Override+of+method](https://help.semmle.com/wiki/display/CBJAVA/Override+of+method)<br>[https://help.semmle.com/QL/ql-explore-queries.html](https://help.semmle.com/QL/ql-explore-queries.html)<br>[https://help.semmle.com/qldoc/java/](https://help.semmle.com/qldoc/java/)

[https://www.youtube.com/watch?v=irrYp3wdtsw](https://www.youtube.com/watch?v=irrYp3wdtsw)

[https://securitylab.github.com/advisories/GHSL-2020-011-nxrm-sonatype](https://securitylab.github.com/advisories/GHSL-2020-011-nxrm-sonatype)
