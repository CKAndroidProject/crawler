> 原文链接: https://www.anquanke.com//post/id/215927 


# CVE-2020-23938：安博士杀毒软件TfFRegNt.SYS驱动 DOS漏洞分析


                                阅读量   
                                **113162**
                            
                        |
                        
                                                            评论
                                <b>
                                    <a target="_blank">2</a>
                                </b>
                                                                                    



[![](https://p5.ssl.qhimg.com/t01b6a41bb279f8ebf0.jpg)](https://p5.ssl.qhimg.com/t01b6a41bb279f8ebf0.jpg)

作者： 极光无限维阵漏洞研究员 — lawhack**<br>**

## 摘要

**漏洞类型：**内核内存越界读

**漏洞危害：**BSOD

**漏洞成因：**未能对传入的参数进行有效验证，对读取内存的边界值控制不严格，导致超过了原有内存的2字节进行越界读取。

**挖掘方式：**代码审计

**漏洞编号：**CVE-2020-23938

**漏洞定位：**在安博士的Ahnlab V3 Lite(4.0.8.3)产品中，其中的文件过滤驱动服务为AntiStealth_V3LITE40F(4.11.0.1)，对应的驱动文件名称为TfFRegNt.SYS。

**漏洞触发函数：**sub_4091FE



## 漏洞分析

#### <a class="reference-link" name="1%E3%80%81%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3%E6%A6%82%E8%BF%B0"></a>1、漏洞相关概述

在进行代码分析前，我们首先需要对漏洞相关信息进行确认，下文将为大家分为四个步骤进行详解。

第一步，首先我们需要查看该驱动的服务属性：

[![](https://p3.ssl.qhimg.com/t011f17d476b8e2271f.png)](https://p3.ssl.qhimg.com/t011f17d476b8e2271f.png)

第二步，确认访问用户层对内核层驱动时需要的符号链接：

[![](https://p4.ssl.qhimg.com/t01460149e1b2874cbf.png)](https://p4.ssl.qhimg.com/t01460149e1b2874cbf.png)

第三步，查看安全属性：

[![](https://p3.ssl.qhimg.com/t01e44022e049d81719.png)](https://p3.ssl.qhimg.com/t01e44022e049d81719.png)

[![](https://p3.ssl.qhimg.com/t01b25051cc3e17bf60.png)](https://p3.ssl.qhimg.com/t01b25051cc3e17bf60.png)

如上图所示，我们发现必须通过管理员权限才能对该驱动进行读写。

第四步，我们还需要查看该驱动的设备属性：

[![](https://p4.ssl.qhimg.com/t0179ce23d9ccad247e.png)](https://p4.ssl.qhimg.com/t0179ce23d9ccad247e.png)

可以看出，该驱动运用的是BUFFERED_IO的缓冲读写方式，这意味着用户的输入会被拷贝到内核的内存空间中。

#### <a class="reference-link" name="2%E3%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"></a>2、代码分析

我们利用ida打开TfFRegNt.SYS，查找它处理IOCTL函数的地址，首先跟踪到处理分发函数的地方，如下图所示：

[![](https://p0.ssl.qhimg.com/t0154c95d9d13b42639.png)](https://p0.ssl.qhimg.com/t0154c95d9d13b42639.png)

然后在sub_4087B2中对函数类型进行判断：

[![](https://p2.ssl.qhimg.com/t01eed14ea2c3e56c16.png)](https://p2.ssl.qhimg.com/t01eed14ea2c3e56c16.png)

最终我们可以得到用户的IOCTL处理函数为sub_4095A0，代码如下：

[![](https://p5.ssl.qhimg.com/t01ef838c16d8037a09.png)](https://p5.ssl.qhimg.com/t01ef838c16d8037a09.png)

接下来经过前面的校验后，我们进入sub_4091FE函数：

[![](https://p4.ssl.qhimg.com/t017eb3efd8fb25f100.png)](https://p4.ssl.qhimg.com/t017eb3efd8fb25f100.png)

在该函数中，我们将会触发越界访问：

[![](https://p4.ssl.qhimg.com/t014171463365d999a4.png)](https://p4.ssl.qhimg.com/t014171463365d999a4.png)

可以看出，触发漏洞的IOCTL code为0x82000028，在处理该请求时，大家可以尝试将传入的systembuf[1]+8作为索引，来读取从用户层地址映射的内核地址数据，而此处的值是用户层可以控制的，因此通过精心构造的参数可以导致产生读取越界。如果越界读的地址并没有经过初始化，则会触发page_fault_in_nonpaged_area异常导致kernel bug check，最终导致系统crash蓝屏。

[![](https://p0.ssl.qhimg.com/t015b0327930d9e7171.png)](https://p0.ssl.qhimg.com/t015b0327930d9e7171.png)

#### <a class="reference-link" name="3%E3%80%81%20%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95"></a>3、 漏洞调试

当我们搭建好双机调试环境后，就可以开始试着调试下整个漏洞的触发过程，首先在0x95a0函数偏移下断点：

[![](https://p0.ssl.qhimg.com/t01fb6c758cd43f800d.png)](https://p0.ssl.qhimg.com/t01fb6c758cd43f800d.png)

接着运行poc程序，windbg中断，查看调用堆栈：

[![](https://p2.ssl.qhimg.com/t0175e2ff7538926dd5.png)](https://p2.ssl.qhimg.com/t0175e2ff7538926dd5.png)

由此我们可以确认这是由poc程序发起的io请求。

接下来该程序会对IRP进行解析，我们能得到current_stack_location的数据，之后进一步获取io的请求code，进行对比并执行对应的处理。该函数的第二个参数即为的当前的IRP指针：

[![](https://p4.ssl.qhimg.com/t01fc0784689a9fc368.png)](https://p4.ssl.qhimg.com/t01fc0784689a9fc368.png)

然后我们查看用户数据在内核内存上的映射，如下所示：

[![](https://p3.ssl.qhimg.com/t018f598e0abf9d95de.png)](https://p3.ssl.qhimg.com/t018f598e0abf9d95de.png)

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p1.ssl.qhimg.com/t01cc1ff744e21586d7.png)

相应的内存属性也需要确认：

[![](https://p1.ssl.qhimg.com/t01e610c49da3bddefa.png)](https://p1.ssl.qhimg.com/t01e610c49da3bddefa.png)

此时该内存块的首地址和尾地址分别为0xc3600000、0xd3600000。

下面是我对该内存地址数据的判断：

[![](https://p2.ssl.qhimg.com/t018174a34acf93c3da.png)](https://p2.ssl.qhimg.com/t018174a34acf93c3da.png)

运行时的数据如下：

[![](https://p5.ssl.qhimg.com/t01ef9c60223a2c588d.png)](https://p5.ssl.qhimg.com/t01ef9c60223a2c588d.png)

我们可以看到经过计算后访问的地址是0xd3600000，这是上个内存块的尾地址，但该地址尚未分配，所以会导致kernel bug check，最终导致内核崩溃。

[![](https://p3.ssl.qhimg.com/t01cf4f9fdf6a522d16.png)](https://p3.ssl.qhimg.com/t01cf4f9fdf6a522d16.png)



## 漏洞修复建议

事实上，我们在访问内存之前，驱动对该处的参数就已经做过了检查，但是检查的并不是很严格：

[![](https://p2.ssl.qhimg.com/t01f5a3ee8079d9dce0.png)](https://p2.ssl.qhimg.com/t01f5a3ee8079d9dce0.png)

在第三处判断中应该判断前两个参数的和是否大于等于输入长度，如果是则返回0，代表参数不正确。前两个参数之和是字符串的最大索引长度，因为字符串的索引是从0开始的，所以必然要小于字符串长度。
