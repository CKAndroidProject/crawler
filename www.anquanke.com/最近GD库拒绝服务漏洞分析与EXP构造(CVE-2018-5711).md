> 原文链接: https://www.anquanke.com//post/id/97786 


# 最近GD库拒绝服务漏洞分析与EXP构造(CVE-2018-5711)


                                阅读量   
                                **135788**
                            
                        |
                        
                                                                                                                                    ![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



[![](https://p1.ssl.qhimg.com/t012cb8bce1f25dd9ab.jpg)](https://p1.ssl.qhimg.com/t012cb8bce1f25dd9ab.jpg)



## 0x00 前言

最近爆出PHP GD库拒绝服务攻击漏洞，影响的版本比较多。官方上有漏洞的报告，但是看下来还是有不懂的地方，于是下载源码自己分析下。



## 0x01 漏洞分析

```
There is a do-while in file `ext/gd/libgd/gd_gif_in.c` and function `LWZReadByte_`
do `{`
    sd-&gt;firstcode = sd-&gt;oldcode =
    GetCode(fd, &amp;sd-&gt;scd, sd-&gt;code_size, FALSE, ZeroDataBlockP);
`}` while (sd-&gt;firstcode == sd-&gt;clear_code);

https://github.com/php/php-src/blob/c5767db441e4db2a1e07b5880129ad7ce0b25b6f/ext/gd/libgd/gd_gif_in.c#L460


The implementation of `GetCode` is in `GetCode_`

static int
GetCode_(gdIOCtx *fd, CODE_STATIC_DATA *scd, int code_size, int flag, int *ZeroDataBlockP)
`{`
    int           i, j, ret;
    unsigned char count;

    ... 

    if ((count = GetDataBlock(fd, &amp;scd-&gt;buf[2], ZeroDataBlockP)) &lt;= 0)
        scd-&gt;done = TRUE;

    ...
`}`

https://github.com/php/php-src/blob/c5767db441e4db2a1e07b5880129ad7ce0b25b6f/ext/gd/libgd/gd_gif_in.c#L376

As you can see, `GetDataBlock` will read the image data and return the length. If EOF, returned -1. But the variable `count` is `unsigned char`, will always be positive value. So the line `scd-&gt;done = TRUE` will never be executed.
```

根据官方的报告，`LWZReadByte_` 这个函数会造成死循环，原因是由于`count`变量是`unsigne char`,永远不会是负数，从而无法判断图片是否读取完毕，造成`scd-&gt;done = TRUE`无法执行，一开始没有想到这个报告很懒，还疑问那岂不是所有的`GIF`图片都会造成拒绝服务了（还真去拿普通的GIF图片试了试）。

其实还要满足`sd-&gt;firstcode == sd-&gt;clear_code`才能造成死循环。

```
do `{`
    sd-&gt;firstcode = sd-&gt;oldcode =
    GetCode(fd, &amp;sd-&gt;scd, sd-&gt;code_size, FALSE, ZeroDataBlockP);
`}` while (sd-&gt;firstcode == sd-&gt;clear_code);
```

那为什么报告中要指出`scd-&gt;done = TRUE`无法执行。看这个函数上面，发现有一个`if`的判断，如果`scd-&gt;done`为`True`,则会直接返回`-1`。那么`sd-&gt;firstcode == sd-&gt;clear_code`永远不会成立了，造成循环退出。所以`scd-&gt;done`一定不能为`True`。<br>[gd_gif_in.c#L389](https://github.com/php/php-src/blob/c5767db441e4db2a1e07b5880129ad7ce0b25b6f/ext/gd/libgd/gd_gif_in.c#L389)

```
if ( (scd-&gt;curbit + code_size) &gt;= scd-&gt;lastbit) `{`
    if (scd-&gt;done) `{`
        if (scd-&gt;curbit &gt;= scd-&gt;lastbit) `{`
            /* Oh well */
        `}`
        return -1;
    `}`
    scd-&gt;buf[0] = scd-&gt;buf[scd-&gt;last_byte-2];
    scd-&gt;buf[1] = scd-&gt;buf[scd-&gt;last_byte-1];

    if ((count = GetDataBlock(fd, &amp;scd-&gt;buf[2], ZeroDataBlockP)) &lt;= 0)
        scd-&gt;done = TRUE;

    scd-&gt;last_byte = 2 + count;
    scd-&gt;curbit = (scd-&gt;curbit - scd-&gt;lastbit) + 16;
    scd-&gt;lastbit = (2+count)*8 ;
`}`
```

上面仅仅是为了满足不返回`-1`，但是还要满足返回结果等于`sd-&gt;clear_code`。接下来的`ret`结果由下面的代码控制。通过构造GIF,可以控制`ret`的返回结果。而`sd-&gt;clear_code`也是可以控制。从而达到死循环。<br>[gd_gif_in.c#L407](https://github.com/php/php-src/blob/c5767db441e4db2a1e07b5880129ad7ce0b25b6f/ext/gd/libgd/gd_gif_in.c#L407)

```
if ((scd-&gt;curbit + code_size - 1) &gt;= (CSD_BUF_SIZE * 8)) `{`
    ret = -1;
`}` else `{`
    ret = 0;
    for (i = scd-&gt;curbit, j = 0; j &lt; code_size; ++i, ++j) `{`
        ret |= ((scd-&gt;buf[i / 8] &amp; (1 &lt;&lt; (i % 8))) != 0) &lt;&lt; j;
    `}`
`}`

scd-&gt;curbit += code_size;
return ret;
```



## 0x02 EXP构造

漏洞成因分析完了，知道EXP的关键点是控制`sd-&gt;clear_code`与`GetCode_`函数返回结果一致。

### <a class="reference-link" name="1.%E6%8E%A7%E5%88%B6sd-&gt;clear_code"></a>1.控制sd-&gt;clear_code

首先分下`sd-&gt;clear_code`是从哪里获取的。

获取函数的参数`input_code_size`，然后再把`1`左移`input_code_size`位。得到`sd-&gt;clear_code`。<br>[gd_gif_in.c#L431](https://github.com/php/php-src/blob/c5767db441e4db2a1e07b5880129ad7ce0b25b6f/ext/gd/libgd/gd_gif_in.c#L431)

```
static int
LWZReadByte_(gdIOCtx *fd, LZW_STATIC_DATA *sd, char flag, int input_code_size, int *ZeroDataBlockP)
`{`
    int code, incode, i;

    if (flag) `{`
        sd-&gt;set_code_size = input_code_size;
        sd-&gt;code_size = sd-&gt;set_code_size+1;
        sd-&gt;clear_code = 1 &lt;&lt; sd-&gt;set_code_size ;
        sd-&gt;end_code = sd-&gt;clear_code + 1;
        sd-&gt;max_code_size = 2*sd-&gt;clear_code;
        sd-&gt;max_code = sd-&gt;clear_code+2;
```

再追踪下调用`LWZReadByte`函数的地方，并且`flag`为`TRUE`。这里看到`input_code_size`为`c`。<br>[gd_gif_in.c#L586](https://github.com/php/php-src/blob/c5767db441e4db2a1e07b5880129ad7ce0b25b6f/ext/gd/libgd/gd_gif_in.c#L586)

```
if (LWZReadByte(fd, &amp;sd, TRUE, c, ZeroDataBlockP) &lt; 0) `{`
    return;
`}`
```

再追踪下`c`从哪里来的，通过`ReadOK`从`fd`获取到的。其实也就是读取GIF图片里面一个字节。<br>[gd_gif_in.c#L569](https://github.com/php/php-src/blob/c5767db441e4db2a1e07b5880129ad7ce0b25b6f/ext/gd/libgd/gd_gif_in.c#L569)

```
if (! ReadOK(fd,&amp;c,1)) `{`
    return;
`}`
```

前面使用`ReadOK`函数读取GIF图片的一些信息，比如`GIF89a`、`高`、`宽`之类的。到这里读取到是哪个字节?读取的是`UBYTE LZWMinimumCodeSize`。如下图所示：

[![](https://p4.ssl.qhimg.com/t0136970485859d3bef.png)](https://p4.ssl.qhimg.com/t0136970485859d3bef.png)

所以更改`UBYTE LZWMinimumCodeSize`的值则可以控制`sd-&gt;clear_code`的值。

### <a class="reference-link" name="2.%E6%8E%A7%E5%88%B6GetCode_%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9Cret"></a>2.控制GetCode_返回结果ret

接下来就是控制`GetCode_`的返回结果ret,由如下代码控制。<br>[gd_gif_in.c#L389](https://github.com/php/php-src/blob/c5767db441e4db2a1e07b5880129ad7ce0b25b6f/ext/gd/libgd/gd_gif_in.c#L389)

```
if ( (scd-&gt;curbit + code_size) &gt;= scd-&gt;lastbit) `{`
    if (scd-&gt;done) `{`
        if (scd-&gt;curbit &gt;= scd-&gt;lastbit) `{`
            /* Oh well */
        `}`
        return -1;
    `}`
    scd-&gt;buf[0] = scd-&gt;buf[scd-&gt;last_byte-2];
    scd-&gt;buf[1] = scd-&gt;buf[scd-&gt;last_byte-1];

    if ((count = GetDataBlock(fd, &amp;scd-&gt;buf[2], ZeroDataBlockP)) &lt;= 0)
        scd-&gt;done = TRUE;

    scd-&gt;last_byte = 2 + count;
    scd-&gt;curbit = (scd-&gt;curbit - scd-&gt;lastbit) + 16;
    scd-&gt;lastbit = (2+count)*8 ;
`}`

if ((scd-&gt;curbit + code_size - 1) &gt;= (CSD_BUF_SIZE * 8)) `{`
    ret = -1;
`}` else `{`
    ret = 0;
    for (i = scd-&gt;curbit, j = 0; j &lt; code_size; ++i, ++j) `{`
        ret |= ((scd-&gt;buf[i / 8] &amp; (1 &lt;&lt; (i % 8))) != 0) &lt;&lt; j;
    `}`
`}`

scd-&gt;curbit += code_size;
return ret;
```

最为关键的是如下代码。

```
for (i = scd-&gt;curbit, j = 0; j &lt; code_size; ++i, ++j) `{`
    ret |= ((scd-&gt;buf[i / 8] &amp; (1 &lt;&lt; (i % 8))) != 0) &lt;&lt; j;
`}`
```

`scd-&gt;buf`是通过`GetDataBlock`获取到如下图data蓝色部分。内容全部为一样，因为可以使`scd-&gt;buf[i / 8]`保证获取到一个固定值。便于控制`ret`的结果。

[![](https://p3.ssl.qhimg.com/t01255d60c9fefcd952.png)](https://p3.ssl.qhimg.com/t01255d60c9fefcd952.png)

还有`（1 &lt;&lt; (i % 8))`，这个值是`1、2、4、8、16、32、64、128`的循环。综合这两点，是可以控制`ret`值了。

比如：如果想返回结果为`2`，`code_size`控制为`2`的时候，再`scd-&gt;buf[i/8]= 0xAA`满足下面条件就可以返回`2`的结果。

```
scd-&gt;buf[i/8]&amp;1==0 and scd-&gt;buf[i/8]&amp;2!=0 and scd-&gt;buf[i/8]&amp;4==0 and scd-&gt;buf[i/8]&amp;8!=0 and scd-&gt;buf[i/8]&amp;16==0 and scd-&gt;buf[i/8]&amp;32!=0 and scd-&gt;buf[i/8]&amp;64==0 and scd-&gt;buf[i/8]&amp;128!=0
```

### <a class="reference-link" name="3.%E5%AE%8C%E6%95%B4%E6%9E%84%E9%80%A0EXP%E8%BF%87%E7%A8%8B"></a>3.完整构造EXP过程

在`LZWMinimumCodeSize`设置为`1`。那么`sd-&gt;clear_code`值为`2`。这个时候`GetCode`返回的值也必须是`2`。

```
do `{`
    sd-&gt;firstcode = sd-&gt;oldcode =
        GetCode(fd, &amp;sd-&gt;scd, sd-&gt;code_size, FALSE, ZeroDataBlockP);
`}` while (sd-&gt;firstcode == sd-&gt;clear_code);
return sd-&gt;firstcode;
```

此时`code_size`为`2`。

```
for (i = scd-&gt;curbit, j = 0; j &lt; code_size; ++i, ++j) `{`
    ret |= ((scd-&gt;buf[i / 8] &amp; (1 &lt;&lt; (i % 8))) != 0) &lt;&lt; j;
`}`
```

意味着或运算两次。我们把第一次`((scd-&gt;buf[i /  8]  &amp;  (1  &lt;&lt;  (i %  8)))  !=  0)  &lt;&lt; j`结果控制为0，第二次结果控制为2。这样0或2结果还是2。

```
ret=ret|((scd-&gt;buf[i /  8]  &amp;  (1  &lt;&lt;  (i %  8)))  !=  0)  &lt;&lt; j;
ret=ret|((scd-&gt;buf[i /  8]  &amp;  (1  &lt;&lt;  (i %  8)))  !=  0)  &lt;&lt; j;
```

那该怎么做尼？`scd-&gt;buf[i/8]`一直是固定值，`(1  &lt;&lt;  (i %  8)))`是`1、2、4、8、16、32、64、128`的循环(至于为什么是这个循环，有点复杂，枯燥而且很长，由兴趣的可以自己下载php源码进行调试)，写个python脚本遍历一下。寻找`scd-&gt;buf[i /  8]`为哪个固定值的时候，可以满足上面提出的条件。下面python脚本跑出结果`x`的值是`170(0XAA)`。

```
for x in range(0,255):
    if(x&amp;1==0 and x&amp;2!=0 and x&amp;4==0 and x&amp;8!=0 and x&amp;16==0 and x&amp;32!=0 and x&amp;64==0 and x&amp;128!=0):
        print(x)
```

于是对正常的图片进行如下填充就完成EXP的构造了<br>[![](https://p3.ssl.qhimg.com/t01448e6ccd6cdcc6c3.png)](https://p3.ssl.qhimg.com/t01448e6ccd6cdcc6c3.png)

再看下官方给出的EXP<br>[![](https://p0.ssl.qhimg.com/t0141a971a060c887ed.png)](https://p0.ssl.qhimg.com/t0141a971a060c887ed.png)

`code_size`为`4`，所以python脚本如下：

```
for x in range(0,255):
    if(x&amp;1==0 and x&amp;2==0 and x&amp;4==0 and x&amp;8!=0 and x&amp;16==0 and x&amp;32==0 and x&amp;64==0 and x&amp;128!=0):
        print(x)
```

跑出结果`x`为`136（0x88）`。图片里面也是用`0x88`填充的。



## 0x03参考

[https://bugs.php.net/bug.php?id=75571](https://bugs.php.net/bug.php?id=75571)
