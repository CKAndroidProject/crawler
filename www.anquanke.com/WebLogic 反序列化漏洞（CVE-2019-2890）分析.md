> 原文链接: https://www.anquanke.com//post/id/190154 


# WebLogic 反序列化漏洞（CVE-2019-2890）分析


                                阅读量   
                                **992574**
                            
                        |
                        
                                                                                    



[![](https://p5.ssl.qhimg.com/t0134235cdb08e2e7fe.png)](https://p5.ssl.qhimg.com/t0134235cdb08e2e7fe.png)



## 漏洞简介

2019年10月16日，WebLogic官方发布了安全补丁公告，修复了包含CVE-2019-2890等高危漏洞。Weblogic在利用T3协议进行远程资源加载调用时，默认会进行黑名单过滤以保证反序列化安全。漏洞CVE-2019-2890绕过了Weblogic的反序列化黑名单，使攻击者可以通过T3协议对存在漏洞的Weblogic组件实施远程攻击，但该漏洞利用条件较高，官方也归类为需要身份认证。

[![](https://p3.ssl.qhimg.com/t0123646d554ccb8c70.png)](https://p3.ssl.qhimg.com/t0123646d554ccb8c70.png)



## 影响版本

WebLogic Server 10.3.6.0

WebLogic Server 12.1.3.0

WebLogic Server 12.2.1.3



## 漏洞分析

漏洞代码位于weblogic.jar中weblogic.wsee.jaxws.persistence.PersistentContext.class文件，它的readObject函数调用了readSubject函数，readSubject函数中使用了ObjectInputStream.readObject来反序列化对象。

[![](https://p3.ssl.qhimg.com/t01bb4e25557e471f52.png)](https://p3.ssl.qhimg.com/t01bb4e25557e471f52.png)

查看对应的writeObject的逻辑，只要我们给对应的localObjectOutputStream.writeObject()序列化一个恶意对象，则PersistentContext对象被反序列化时，它的readObject函数被调用，readSubject函数中对恶意对象进行反序列化。因此通过T3发送精心伪造的PersistentContext对象，则可成功绕过黑名单检查。

[![](https://p2.ssl.qhimg.com/t013237880349c21003.png)](https://p2.ssl.qhimg.com/t013237880349c21003.png)



## 漏洞复现

为了让writeObject函数中的localObjectOutputStream.writeObject()序列化一个恶意对象，我们直接对PersistentContext类进行修改。

打开idea新建一个项目，引入需要的Jar文件。在项目中新建一个package，名为weblogic.wsee.jaxws.persistence，在这个包下创建PersistentContext.class文件，复制原来的内容进行修改。

我们在PersistentContext.class文件中新增一个getObject()函数，用于获取恶意对象。然后把localObjectOutputStream.writeObject()函数的参数替换。

[![](https://p5.ssl.qhimg.com/t018aa1278cc8866d7a.png)](https://p5.ssl.qhimg.com/t018aa1278cc8866d7a.png)

然后在项目中创建一个Poc.class文件，新建PersistentContext对象对其进行序列化操作，序列化后存储到poc文件中。

此时我们使用T3发送payload发现靶机日志提示报错：

[![](https://p4.ssl.qhimg.com/t01e8a8a619a26a7abc.png)](https://p4.ssl.qhimg.com/t01e8a8a619a26a7abc.png)

根据报错提示定位到代码，发现readSubject函数中有个解密过程：

[![](https://p5.ssl.qhimg.com/t01af96a2ee95c2db4b.png)](https://p5.ssl.qhimg.com/t01af96a2ee95c2db4b.png)

此时我们再次检查writeSubject函数，猜测序列化时加密没有成功，导致反序列化时解密报错：

[![](https://p0.ssl.qhimg.com/t012e3c222f3f325804.png)](https://p0.ssl.qhimg.com/t012e3c222f3f325804.png)

跟进加密函数：

[![](https://p1.ssl.qhimg.com/t01c1e80085d6918db8.png)](https://p1.ssl.qhimg.com/t01c1e80085d6918db8.png)

由于我们idea建立的项目中没有SerializedSystemIni.dat文件，直接返回null，因此加密没有成功，导致反序列化失败。

[![](https://p3.ssl.qhimg.com/t01e3dbd05d6456d4f4.png)](https://p3.ssl.qhimg.com/t01e3dbd05d6456d4f4.png)

因此我们需要修改writeSubject()函数，但由于getEncryptionService属性为private，需再新建EncryptionUtil.class文件,把getEncryptionService()函数属性改成public：

[![](https://p2.ssl.qhimg.com/t01a24fed2d6310025f.png)](https://p2.ssl.qhimg.com/t01a24fed2d6310025f.png)

并且把SerializedSystemIni.dat文件复制到我们idea项目中。由于SerializedSystemIni.dat是密钥文件，各不相同且无法猜解，这里也就是这个漏洞需要身份认证的原因。

此时再测试发送payload，可爱的计算器成功弹出。

[![](https://p2.ssl.qhimg.com/t013cce9dee05b445dc.png)](https://p2.ssl.qhimg.com/t013cce9dee05b445dc.png)



## 安全建议

1、禁用 T3 协议：如果您不依赖 T3 协议进行JVM通信，可通过暂时阻断 T3 协议缓解此漏洞带来的影响。

2、排查弱口令

3、升级补丁



## 相关链接

[https://www.oracle.com/security-alerts/cpuoct2019.html](https://www.oracle.com/security-alerts/cpuoct2019.html)
