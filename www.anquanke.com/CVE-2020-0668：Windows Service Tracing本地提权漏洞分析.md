
# CVE-2020-0668：Windows Service Tracing本地提权漏洞分析


                                阅读量   
                                **812767**
                            
                        |
                        
                                                                                                                                    ![](./img/199011/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



##### 译文声明

本文是翻译文章，文章原作者itm4n，文章来源：itm4n.github.io
                                <br>原文地址：[https://itm4n.github.io/cve-2020-0668-windows-service-tracing-eop/](https://itm4n.github.io/cve-2020-0668-windows-service-tracing-eop/)

译文仅供参考，具体内容表达以及含义原文为准

[![](./img/199011/t011ed72dd26eb91c3a.jpg)](./img/199011/t011ed72dd26eb91c3a.jpg)



## 0x00 前言

在本文中，我将与大家分享我在Windows Service Tracing中找到的一个任意文件移动漏洞。根据测试结果，该漏洞影响从Vista到10的所有Windows版本。由于XP系统中已存在该功能，因此该漏洞可能会影响更早的版本。

Service Tracing是Windows系统中很早就存在的一个功能，可以追溯到XP时代，但更早系统中可能已经包含该功能。Service Tracing可以提供正在运行的服务和模块的基础调试信息，配置起来非常方便，本地用户只要编辑`HKLM\SOFTWARE\Microsoft\Tracing`下的某些注册表键值即可。

Windows系统中，服务或者模块会关联某些注册表项，其中每个键都包含6个值（即具体的设置信息）。这里我们主要关注其中3个值：`EnableFileTracing`（启用/禁用“跟踪”功能）、`FileDirectory`（设置输出日志文件的具体位置）及`MaxFileSize`（设置日志文件的最大文件大小）。

当启用`EnableFileTracing`选项后，目标服务会将日志文件写入用户选择的目录中。当输出文件大小超过`MaxFileSize`时，该文件会被系统移动（将`.LOG`扩展名替换为`.OLD`），创建一个新的日志文件。

借助于James Forshaw的[符号链接测试工具](https://github.com/googleprojectzero/symboliclink-testing-tools)，我们很容易就能构造利用工具，只需要将目标目录设置为挂载点，指向`\RPC Control`对象目录，然后创建如下2个符号链接：

1、从`MODULE.LOG`到我们拥有的某个文件的符号链接（该文件大小必须大于`MaxFileSize`）；

2、从`MODULE.OLD`到系统上任意文件的符号链接（比如`C:\Windows\System32\WindowsCoreDeviceInfo.dll`）。

最后，我们选择以`NT AUTHORITY\SYSTEM`权限运行的服务作为目标来触发文件移动操作，然后利用Update Session Orchestrator服务来获得任意代码执行权限。



## 0x01 服务跟踪

前面简单提到过，任何本地用户都能配置Service Tracing功能，只要编辑某些注册表项，修改`HKLM\SOFTWARE\Microsoft\Tracing`下的键值即可。

我们可以使用Windows Sysinternals工具集中的`AccessChk`工具，验证普通用户具备相关注册表项下几乎所有子项的的`Read`/`Write`权限：

[![](./img/199011/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p5.ssl.qhimg.com/t01206a8649e37b1960.png)

为了演示方便，下文中我将以`RASTAPI`模块为例，这也是我利用代码中用到的模块。由于`IKEEXT`服务会用到该模块，因此我们可以通过启动任意VPN连接来触发事件日志行为。涉及到的相关注册表键值默认设置如下图所示，其他服务及模块也使用了完全相同的值。

[![](./img/199011/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p4.ssl.qhimg.com/t014f19d6cbe76cc63c.png)

从本地攻击者角度来看，比较有趣的几个值如下所示：

<th style="text-align: center;">名称</th><th style="text-align: center;">可取值</th><th style="text-align: center;">描述</th>
|------
<td style="text-align: center;">`EnableFileTracing`</td><td style="text-align: center;">`0` – `1`</td><td style="text-align: center;">开始/停止写入日志文件</td>
<td style="text-align: center;">`FileDirectory`</td><td style="text-align: center;">字符串</td><td style="text-align: center;">某个目录的绝对路径</td>
<td style="text-align: center;">`MaxFileSize`</td><td style="text-align: center;">`0x00000000` – `0xffffffff`</td><td style="text-align: center;">输出日志文件最大值</td>

我们可以修改这些值，实现如下目标：

1、将`EnableFileTracing`修改为`0`或者`1`，强制特定服务或模块开始或停止将调试信息写入日志文件。

2、通过`FileDirectory`设置日志文件的具体位置。

3、通过`MaxFileSize`设置输出文件的最大大小值。

这里唯一要注意的是我们无法选择输出文件的名称，该名称取决于被调试服务或模块的名称，但我们可以通过符号链接轻松解决该问题。



## 0x02 任意文件移动漏洞

了解前面信息后，我们可以澄清该漏洞的利用过程。

### <a class="reference-link" name="%E5%9C%BA%E6%99%AF1%EF%BC%9AMaxFileSize%E4%B8%BA%E9%BB%98%E8%AE%A4%E5%80%BC"></a>场景1：MaxFileSize为默认值

在这个测试案例中，我将`C:\LOGS`设置为输出目录，启用文件跟踪功能。

[![](./img/199011/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p1.ssl.qhimg.com/t016810ef8cde73fb31.png)

现在，如果我们希望目标服务开始写入该文件，就必须生成某些事件。这里最简单的一种方法就是使用`rasdial`命令，配合`PBK`文件来初始化任意一个VPN连接。

[![](./img/199011/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p3.ssl.qhimg.com/t01994dcc732f04b32d.png)

这种方法行之有效，`NT AUTHORITY\SYSTEM`用户会写入日志文件。目前日志文件大小约为`24KB`。

[![](./img/199011/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p3.ssl.qhimg.com/t01a54650e6df064a27.png)

### <a class="reference-link" name="%E5%9C%BA%E6%99%AF2%EF%BC%9AMaxFileSize%E4%B8%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%80%BC"></a>场景2：MaxFileSize为自定义值

在上一个测试用例中，输出日志文件的最终大小约为`24KB`。因此，这里我们要将`MaxFileSize`设置为`0x4000`（即16,384个字节），然后重新开始测试。

[![](./img/199011/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p4.ssl.qhimg.com/t01f924d3dea332fb57.png)

根据Process Monitor的分析结果，捕捉到的相关事件总结如下：

1、服务会获取日志文件的基础信息。我们可以看到`EndOfFile`的偏移量为`23,906`，这也是目前文件的大小值。由于我们设定的最大文件大小值为`16,384`字节，因此这里系统会判断没有更多空间可用。

2、服务调用`SetRenameInformationFile`，其中`FileName=C:\LOGS\RASTAPI.OLD`。由于系统认为当前文件已满，因此会将`C:\LOGS\RASTAPI.LOG`移动为`C:\LOGS\RASTAPI.OLD`。

3、服务创建一个新的`C:\LOGS\RASTAPI.LOG`文件，开始写入数据。

[![](./img/199011/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p4.ssl.qhimg.com/t0148f4d0654fba3f87.png)

这里的文件移动操作由`NT AUTHORITY\SYSTEM`执行。因此，我们可以利用这一点将用户所有的文件移动到系统中的任意位置，比如`C:\Windows\System32\`。



## 0x03 漏洞利用

利用过程非常简单，可以总结如下：

1、创建（或拷贝）大小超过`0x8000`（`32,768`）字节的一个文件。

2、创建一个新的目录（`C:\EXPLOIT\mountpoint\ for example`），将其设置为指向`\RPC Control`的一个挂载点。

3、创建如下符号链接：

```
\RPC Control\RASTAPI.LOG -&gt; \??\C:\EXPLOIT\FakeDll.dll (owner = current user)
\RPC Control\RASTAPI.OLD -&gt; \??\C:\Windows\System32\WindowsCoreDeviceInfo.dll
```

4、在注册表中配置如下值：

```
FileDirectory = C:\EXPLOIT\mountpoint
MaxFileSize = 0x8000 (32,768‬ bytes)
EnableFileTracing = 1
```

5、使用Windows API中的`RasDial`函数，触发与`RASTAPI`相关的事件。

6、触发Update Session Orchestrator服务，使其在`NT AUTHORITY\SYSTEM`上下文中加载相关DLL。

漏洞利用过程如下图所示：

[![](./img/199011/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://itm4n.github.io/assets/2020-02-14-cve-2020-0668-windows-service-tracing-eop/00_demo.gif)



## 0x04 参考资料
<li>MSRC – CVE-2020-0668<br>[https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-0668](https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-0668)
</li>
<li>Windows利用技巧：利用任意文件写入实现本地权限提升<br>[https://googleprojectzero.blogspot.com/2018/04/windows-exploitation-tricks-exploiting.html](https://googleprojectzero.blogspot.com/2018/04/windows-exploitation-tricks-exploiting.html)
</li>
<li>符号链接测试工具<br>[https://github.com/googleprojectzero/symboliclink-testing-tools](https://github.com/googleprojectzero/symboliclink-testing-tools)
</li>
<li>UsoDllLoader<br>[https://github.com/itm4n/UsoDllLoader](https://github.com/itm4n/UsoDllLoader)
</li>