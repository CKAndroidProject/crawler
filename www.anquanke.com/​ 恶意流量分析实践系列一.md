
# ​ 恶意流量分析实践系列一


                                阅读量   
                                **829978**
                            
                        |
                        
                                                            评论
                                <b>
                                    <a target="_blank">7</a>
                                </b>
                                                                                                                                    ![](./img/200312/AAffA0nNPuCLAAAAAElFTkSuQmCC)
                                                                                            



[![](./img/200312/t01d4f37a7d565230cf.png)](./img/200312/t01d4f37a7d565230cf.png)



## 前言

最近研究恶意流量分析，网上似乎相关的文章不多，而且能讲清楚为什么的也近乎没有，这次借完成报告的机会，写几篇相关文章系列，希望能以初学者的视角，探索流量分析中的奥秘，来发掘恶意流量的行为模式。本系列分析的PCAP包均来至于[malware-traffic-analysis.net](http://malware-traffic-analysis.net/training-exercises.html)（除非有特殊说明）。<br>[点这里下载PCAP](https://pan.baidu.com/s/1f5WiiH-v08Jtq2meAZHA0w) 提取码：`fnuf`



## 从TCP到HTTP

我们使用**WireShark**打开本次分析的PCAP包，先输入TCP过滤如下图：

[![](./img/200312/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p5.ssl.qhimg.com/t01a2927215dfa0b7c0.png)

这里我们先简单回忆部分TCP协议知识点：

> **SYN**:同步标志<br>**FIN**: 关闭标志<br>**ACK**: 响应标志<br>**PSH**: DATA传输标志<br>**RST**: 链接重置标志<br>**Seq**: 序列号<br>**Ack**: 确认号<br>**Len**: 携带数据长度

在Flags字段可以清楚的观察到所有属性值，如同：

[![](./img/200312/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p4.ssl.qhimg.com/t0179366ef2a818d06d.png)

我们可以很清楚的体现出一次一次http从链接到关闭的完整过程：首先是三次握手，之后客户端发起一次TCP请求即是HTTP请求,实际上就是GET一次，GET这一行实际上属于他上面一个的TCP中，我们可以观察这两行的值

[![](./img/200312/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p5.ssl.qhimg.com/t0177b412999a1bfd34.png)

[![](./img/200312/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p5.ssl.qhimg.com/t0113a4da65a9d704b6.png)

之后随机服务器返回一次TCP，Ack=594,实际是由客户端上一次请求时Len+1所得，并非是随机生成，同时自身携带Len=762长度的data,客户端收到数据后发送一个关闭请求，其中Seq=594，Ack为服务端之前返回的Len+1即为763，之后服务端发送Seq=763,Ack=595的确认关闭包，完成后发送一次关闭链接的包，最后由客户端发送一个Seq=595,Ack=764的确认包，一次HTTP结束，这其中实际上HTTP就是被封装在一次TCP中，由此我们可以很清楚的看出TCP协议主要作用于链接通信过程（所以称TCP为传输层协议），而发送的数据主要被封装在HTTP协议中便于客户端和服务器打包以及解析（所以称为应用成协议），因为其定义数据报文格式便于解析，所以被广泛应用，但其缺点也体现出来，每一次CS（客户端服务端）交互都是一次TCP建立，到关闭的过程，实际上当大量请求作于服务器时，会极其消耗其资源，所以便提出长连接，以及由其发展出的WebSocket技术，之后有机会在做介绍，在实际应用开发过程中，基本每种语言都给我们提供了socket API（套接字编程）,这极大的简化了开发者的开发网络应用的周期，特别是各种应用框架的诞生，又更进一步减轻了开发网络应用的学习成本，Python的Flask，Sanic, Django等，这里不做详细介绍，后面有机会在出专题系列，对了值得一提的还有一种RPC开发模式，gRPC等一类用于使用该模式快速开发的玩意才属于框架，扯远了。

回归正题，上面我们简要分析一次完整的HTTP协议，剩余的可以自行了解HTTP协议细节，我们之后的分析多为恶意流量分析的实践，遇到新的协议，我也会做一下分析。



## HTTP前奏DNS

当我们直接打开该PCAP包时，不做过滤时，在最开头可以看见两行DNS如图：

[![](./img/200312/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p1.ssl.qhimg.com/t014460417e0b5e20fe.png)

### <a class="reference-link" name="DNS%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90"></a>DNS简要分析

首先我们选中第一行，查看其协议属性

[![](./img/200312/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p2.ssl.qhimg.com/t01e8c7f8992368c1e0.png)

可以发现DNS协议的下层协议为UDP传输协议，UDP和TCP的最大区别可以理解为UDP只管发送，不用考虑是否发送成功，TCP则需要考虑是否发送成功，不成功则重发的机制，<br>
DNS协议开头为Transaction ID为标识字段,2字节,用于辨别DNS应答报文是哪个请求报文的响应<br>**Flags标志位有如下属性:**

> <p>**QR**: 查询/响应,1为响应,0为查询<br>**Opcode**: 查询或响应类型,这里0表示标准,1表示反向,2表示服务器状态请求<br>**AA**: 授权回答,在响应报文中有效,待会儿再看<br>**TC**: 截断,1表示超过512字节并已被截断,0表示没有发生截断<br>**RD**: 是否希望得到递归回答<br>**RA**: 响应报文中为1表示得到递归响应<br>**zero**: 全0保留字段<br>**Questions**: (问题数),2字节,通常为1<br>**Answer RRs**: (资源记录数),Authority RRs(授权资源记录数),Additional RRs(额外资源记录数)通常为0<br>
字段Queries为查询或者响应的正文部分,分为Name Type Class<br>**Name** (查询名称):这里是ping后的参数,不定长度以0结束<br>**Type** (查询类型):2字节,这里是主机A记录.其各个取值的含义如下:</p>
<blockquote>
<table>
<thead><tr>
<th style="text-align: center;">值</th>
<th style="text-align: center;">助记符</th>
<th style="text-align: center;">说明</th>
</tr></thead>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">A</td>
<td style="text-align: center;">IPv4地址</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">NS</td>
<td style="text-align: center;">名字服务器</td>
</tr>
<tr>
<td style="text-align: center;">5</td>
<td style="text-align: center;">CNAME</td>
<td style="text-align: center;">规范名称。定义主机的正式名字的别名</td>
</tr>
<tr>
<td style="text-align: center;">6</td>
<td style="text-align: center;">SOA</td>
<td style="text-align: center;">开始授权。标记一个区的开始</td>
</tr>
<tr>
<td style="text-align: center;">11</td>
<td style="text-align: center;">WKS</td>
<td style="text-align: center;">熟知服务，定义主机提供的网络服务</td>
</tr>
<tr>
<td style="text-align: center;">12</td>
<td style="text-align: center;">PTR</td>
<td style="text-align: center;">指针。把IP地址转化为域名</td>
</tr>
<tr>
<td style="text-align: center;">13</td>
<td style="text-align: center;">HINFO</td>
<td style="text-align: center;">主机信息，给出主机使用的硬件和操作系统的表述</td>
</tr>
<tr>
<td style="text-align: center;">15</td>
<td style="text-align: center;">MX</td>
<td style="text-align: center;">邮件交换。把邮件改变路由送到邮件服务器</td>
</tr>
<tr>
<td style="text-align: center;">28</td>
<td style="text-align: center;">AAAA</td>
<td style="text-align: center;">IPv6地址</td>
</tr>
<tr>
<td style="text-align: center;">252</td>
<td style="text-align: center;">AXFR</td>
<td style="text-align: center;">传送整个区的请求</td>
</tr>
<tr>
<td style="text-align: center;">255</td>
<td style="text-align: center;">ANY</td>
<td style="text-align: center;">对所有记录的请求</td>
</tr>
</tbody>
</table>

**Class** :2字节,IN表示Internet数据,通常为1

在上图我们可以发现Queries 中查询的域名为：<br>`va872g.g90e1h.b8.642b63u.j985a2.v33e.37.pa269cc.e8mfzdgrf7g0.groupprograms[.]in`

我们在来看看`192.168.138.2`（看IP，其属于本地域名服务器）返回的应答，其中在Answers字段返回了Address值为：62.75.195.236，即是上方域名的地址，也就是之后客户发起HTTP请求的目标服务器地址，如下图：

[![](./img/200312/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p0.ssl.qhimg.com/t011c6176ee5c6b3346.png)

一次正常的DNS请求以返回大概就长这样，当然域名有点不正常，之后我们在分析，这里我们回忆一下DNS部分细节，很多相关文章百度都能找到，这里简要说明，首先DNS是递归查询的：

1 查本地hosts

2 查本地DNS解析缓存

3 查本地DNS服务器解析区域（可以在TCP/IP中设置参数）

4 本地DNS服务器解析过的映射

5 查转发

6 查root

7 查归属服务器

8 查下级DNS服务器

9 同上

以上过程均是上已过程未查询到的后的查询步骤，由此我们这里就可以想到是否可以通过DNS搭建隧道？

### <a class="reference-link" name="DNS%E9%9A%A7%E9%81%93%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"></a>DNS隧道原理简述

DNS隧道的优点在于其通过服务器53端口来进行通信，而53端口正常来说属于域名服务查询专属端口，防火墙规则一般在严格都会允许此端口通信，所以CS(Cobalt Strike)其DNS通信模式成为其一大特色<br>
DNS隧道一般分为两种直接连接和中继连接，直接连接相对简单，就是将数据封装隐藏在Client和DNS Server 通信的协议包中，但隐蔽性较弱，而且在指定DNS Server时容易被监测到，而中继连接相对来说，更加隐蔽，但速度会很慢，因为Client发送的数据包要经过多个节点才能到达我指定的DNS Server(其实就类似伪造一台DNS Server 当然也许大佬神仙们真有一台权威DNS Server也说不一定哈)，同时我们还需要**规避Client本地的DNS缓存**，这里有一个很有意思的算法**DGA域名生成算法**，该算法主要被恶意软件用于生成为随机域名，有效绕过黑名单检测，尝试连接，寻找C2中控。后面有机会做一份详细介绍，当然针对该随机生成域名的算法是否有防御策略呢？攻防无绝对，实际上也有许多文章讨论过针对DGA域名生成算法的检测方法，这里打住，不然又跑题了，至于搭建DNS隧道的方法，这里不再多提，借助CS会很简单，GitHub上也又相应的DNS隧道脚本[dnscat2](https://github.com/search?q=dnscat2&amp;type=)这个可以搜索一下，至于利用DNS传输文件，则需要注意DNS数据长度限制。



## HTTP中的恶意行为分析

提及恶意流量分析，我自己经过分析某些恶意软件，以及某些APT攻击活动中使用的恶意样本文件，总结些经验，就如今来说大部分恶意软件，以及C&amp;C Server多使用http流量交互（不局限于此），左图为某Any[.]run上某恶意样本的网络行为报告，可以发现其完全使用HTTP以及DNS来进行通信，实现控制，这里不对该样本做详细分析

[![](./img/200312/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p2.ssl.qhimg.com/t01a2f096727542ced4.png)

因此，很多时候，我们在做手工流量包分析时，可以先从HTTP流量行为上分析入手，可能理清思路要快很多。对了这里有个小技巧，我们可以先把PCAP包丢到VT上看一下，当然如果又IDS告警文件就更好了。

[![](./img/200312/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p4.ssl.qhimg.com/t0110b88fa9154425c3.png)

可以发现 其有exploit-kit malware trojan等标签，简单判断该流量是否携带恶意行为。

### <a class="reference-link" name="%E6%81%B6%E6%84%8F%E7%9A%84HTTP%E8%A1%8C%E4%B8%BA%E7%89%B9%E5%BE%81"></a>恶意的HTTP行为特征

我们来开始分析该PCAP包中的流量行为，在分析流量行为前，我更喜欢先把角色列出来，也就是我们先把相关IP列一下，这里使用PA-Tool Kit，如同：

[![](./img/200312/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p4.ssl.qhimg.com/t0110b6fe2d970f5acd.png)

PA-Tool Kit的插件可以帮我们快速的整理出IP段范围，以及HTPP请求等。<br>
我们可以先尝试过滤`http.response`开始，如图：

[![](./img/200312/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p3.ssl.qhimg.com/t01f9a10eaa7d82ccf4.png)

随后我们仅分析恶意服务返回的数据报文里面是否携带相关恶意代码，这里我们很简单就能想到去找找有没有恶意的js代码，我们选中第一行，右键追踪流—&gt;HTTP

[![](./img/200312/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p4.ssl.qhimg.com/t0103392c1b7745034f.png)

随后我们发现其创造了一个flash object, iframe,同时设置了一个恶意src，我们继续看下一行响应果然确实为一个flash

[![](./img/200312/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p2.ssl.qhimg.com/t01aa232dae36c3f5f9.png)

我们尝试导入出来丢入VT上看一下

[![](./img/200312/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p3.ssl.qhimg.com/t01c74e784f774b2d28.png)

果然，我们可以看出来这是使用了CVE-2015-0311,这里有一篇该CVE报告<br>[漏洞追踪：Flash严重漏洞（CVE-2015-0311）详细技术分析](https://www.freebuf.com/vuls/57925.html)

[![](./img/200312/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p2.ssl.qhimg.com/t01bbbd47c48a4b34c0.png)

这里不对该CVE做详细讨论，我们继续看下一行请求

[![](./img/200312/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p5.ssl.qhimg.com/t0142c42584a1f1c439.png)

所以我们已经基本拿到了恶意请求的参数，这里我们就可以追踪一下b51开头的参数

[![](./img/200312/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p5.ssl.qhimg.com/t01541d5fd5e2e5e0c9.png)

提取出来，上VT

[![](./img/200312/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p0.ssl.qhimg.com/t019649a5e04c2f52c9.png)

这里我们不对该样本分析，一是年代久远，二这里我们注意讨论流量行为，这里完全PC已经被下载该文件后已经被感染<br>
感染后的流量行为：

[![](./img/200312/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p4.ssl.qhimg.com/t011f73c35aa4850f5f.png)



## 感染型的HTTP恶意行为简单总结

从上面的分析过程中，我们可以简单的总结出一种规律，在恶意的HTTP行为中有2个这样的特征：

> 1 奇奇怪怪的URL,当然也并非所有类似的URL都指向恶意站点，所以我们可以通过在线的威胁情报网站来查询入：微步，VT等
2 返回数据里面携带恶意参数，入恶意js脚本等，恶意文件等，但如今各种加密反侦察技术也使得人工分析还是需要大量的人力成本



## 恶意流量行为总结

在学习恶意分析的过程中，我花了很多时间去思考恶意流量和白流量的本质区别，就现在来说从行为上去分类他们确实是一个不错的idea,由此也提出一个问题，什么才是恶意行为呢？其实比较简单，我们这样想，如果一个陌生人来你家打砸抢，行窃，对你的财产等等造成损失，你是否就认同这陌生人的行为就是恶意的，同理在一系列的流量行为，其造成引发的结果是否对原住者造成损失，由此判断其是否属于恶意流量行为，总结来说，有一下几点：

> <ol>
<li>
**攻击型行为**：发送扫描包，或携带漏洞payload的字段的攻击型数据包</li>
<li>
**破坏型行为**：例如通过大量发送SYN包而不接受返回，造成的网络服务崩溃（DDOS）等</li>
<li>
**感染型行为**：通过存在漏洞的组件或软件植入恶意代码（shellcode等），来下载恶意样本，得到控制权限</li>
<li>
**窃密型行为**：如各种rat，trojan等，进行数据窃取的恶意行为，这里下次遇见有该特征的流量包，会做详细分析介绍</li>
</ol>

本次分析前由于是第一期，所以有了比较 站篇幅的协议基础铺垫，下期我们讲侧重于分析感染链式的HTTP流量行为。



## 参考链接

[七夜安全博客-DNS反弹shell](https://mp.weixin.qq.com/s/s18ntS2EPOHxmXSIgM_4YA)
